{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/chocolate.js","path":"js/chocolate.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/images/1655176266176.png.jpg","path":"images/1655176266176.png.jpg","modified":0,"renderable":0},{"_id":"source/images/bg2.jpg","path":"images/bg2.jpg","modified":0,"renderable":0},{"_id":"source/images/bg1.jpg","path":"images/bg1.jpg","modified":0,"renderable":0},{"_id":"source/images/bg3.png","path":"images/bg3.png","modified":0,"renderable":0},{"_id":"source/images/touxiang.jpg","path":"images/touxiang.jpg","modified":0,"renderable":0},{"_id":"source/images/touxiang3.jpg","path":"images/touxiang3.jpg","modified":0,"renderable":0},{"_id":"source/images/touxiang2.jpg","path":"images/touxiang2.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/Vue笔记.md","hash":"fabc8a1b80c7bb6a35ed46776831ece8edf742a3","modified":1655270934360},{"_id":"source/_posts/test.md","hash":"26aed8b6d971279d32d0557bda03b7295934f225","modified":1655270934355},{"_id":"source/_posts/面试笔记.md","hash":"1c111fc71cc16c76607f8371963363bafda53efc","modified":1655270988054},{"_id":"source/_posts/test2.md","hash":"a48e867a800ab2833e36049bf12ce0ca76df1f04","modified":1655272638796},{"_id":"source/_data/link.yml","hash":"6737f6121470b7654308386d3b27dfddcd043dcb","modified":1655216410677},{"_id":"source/categories/index.md","hash":"b5bea1c2548b9799e171af0cf627b8054846cb10","modified":1655190683129},{"_id":"source/link/index.md","hash":"a5533f3fff5d7b818dd0f67255d885bf34b9ea37","modified":1655190723263},{"_id":"source/images/1655176266176.png.jpg","hash":"6c6d9cb0495a5b7f94a653f067a901de43ad93f7","modified":1655262427210},{"_id":"source/tags/index.md","hash":"5cf162f2b76164201d4da078c70d3eb225279102","modified":1655268967725},{"_id":"source/images/bg2.jpg","hash":"35fff0f33df8c7174bcde6ed2a00e6f841afa24d","modified":1655269292709},{"_id":"source/images/bg1.jpg","hash":"db88b65e171e2c7c0adc150ff2e7d251be65303f","modified":1655269285626},{"_id":"source/images/touxiang.jpg","hash":"6623c6e879f3f993d4dacf47e18b411d286cb4af","modified":1655102605977},{"_id":"source/images/touxiang2.jpg","hash":"1374ddeb675c7bf8ef3a1cbbc36ea38293f5a8a0","modified":1655262711355},{"_id":"source/images/touxiang3.jpg","hash":"8046de5a3d038696bab0f1c3c9dddb0fb6f8313d","modified":1655268854459},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"66b4889591d0f36696c4d363412c753b6fe25519","modified":1655182275758},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"390288cffa0aa1338c02e7f240bafa6eef1d4f4c","modified":1655182275939},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1655182275697},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"08afd014fd27019909f341a2ad6162665958c6d6","modified":1655182275757},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"bf1e7d13b179a17f1c851033eddf5944ea5993d4","modified":1655182275755},{"_id":"node_modules/hexo-theme-butterfly/.github/stale.yml","hash":"5e8ea535424e8112439135d21afc5262c0bc0b39","modified":1655182275948},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"d1bb560698eb8b0079495b7b18b44facb610f9fd","modified":1655182275944},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"1e37a3695d50e3e61d7c36e58a6dac872a4a56cd","modified":1655182275944},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"947f794e862bb2813e36887f777bdb760f70a322","modified":1655182275950},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1655182275769},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"28b6f0c39155651d747eb595e0a283bc97be2e09","modified":1655182275948},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1655182275784},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1655182275822},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1655182275836},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1655182275857},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1655182275844},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"67e4f5a66d4b8cabadbaad0410628364ee75e0ae","modified":1655182275941},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1655182275942},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1655182275946},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1655182275945},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1655182275761},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"594a977ebe8d97e60fa3d7cb40fc260ded4d8a58","modified":1655182275764},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"60921c262c1d0740e0abf6bfd73e00b779989ccc","modified":1655188234143},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"54511ed299a3bcf4ecbb62e3078f6b0611ccbd2c","modified":1655182275812},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"da27c20f0e672103b984e135eb2fe7770ca7fcce","modified":1655182275826},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1655182275837},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1655182275852},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"699d0d2cff233628752956c4434125c8203f7d63","modified":1655182275850},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1655182275710},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/config.js","hash":"a12b9f11d7d3f52de5b2090d2805d7303e0187a5","modified":1655182275719},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"b4940a5c73d3a5cd8bb5883e3041ecdd905a74e0","modified":1655182275723},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1655182275745},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"3cfc46c749e2fd7ae9c2a17206238ed0e0e17e7d","modified":1655182275753},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1655182275740},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"21379ed2dccb69c43b893895c9d56238c11e5f43","modified":1655182275741},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1655182275713},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1655182275715},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1655182275737},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"b4cd617c619d1a0df93603721a6fa1317526174b","modified":1655182275724},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"d368a8830e506c8b5eb6512b709ec8db354d5ea1","modified":1655182275743},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1655182275717},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1655182275720},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"f79c99f6c5b626c272dc2bed2b0250d6b91bb28a","modified":1655182275721},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1655182275725},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1655182275722},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1655182275727},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1655182275736},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1655182275736},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1655182275746},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1655182275747},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1655182275914},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"4890a40366d6443f8b8942a4e9a6dce9fe3494f5","modified":1655182275936},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1655182275707},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1655182275759},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1655182275705},{"_id":"node_modules/hexo-theme-butterfly/source/js/chocolate.js","hash":"e69d19b7085a7b112b3139bf355a2baa5c99a1a0","modified":1655290146442},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1655182275734},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1655182275751},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1655182275752},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1655182275835},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1655182275767},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"8f41fa9732ea654a10f6e666d9c782c7e27e5ea6","modified":1655182275788},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1655182275787},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1655182275811},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1655182275834},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1655182275848},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"65a23b5170204e55b813ce13a79d799b66b7382c","modified":1655182275845},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1655182275853},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1655182275813},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1655182275831},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"19a05dccfbffdf31cfa48c3208542b924637303d","modified":1655182275842},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"78a3abd90bb3c18cd773d3d5abac3541e7f415e5","modified":1655182275833},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1655182275853},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1655182275827},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1655182275828},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1655182275770},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"b9ebb02af8ccf43e3f73be43db19254fa913c57b","modified":1655182275843},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1655182275784},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1655182275793},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"fed069baa9b383f57db32bb631115071d29bdc60","modified":1655182275803},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1655182275858},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1655182275841},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1655182275849},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1655182275768},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1655182275798},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1655182275838},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"460c37caeed6e6e72c1e62292e6c5e9699dd5937","modified":1655182275839},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1655182275846},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"bae2f32ac96cebef600c1e37eaa8467c9a7e5d92","modified":1655182275856},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1655182275772},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1655182275774},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1655182275773},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1655182275776},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1655182275775},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1655182275777},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1655182275778},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1655182275780},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1655182275779},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1655182275780},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1655182275782},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1655182275781},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1655182275821},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"644d520fe80cc82058467708ab82ccad313b0c27","modified":1655182275895},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"714f19e7d66df84938bd1b82b33d5667abe1f147","modified":1655182275908},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1655182275905},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1655182275933},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"ca58af8903eb1d1d05edae54fc2e23aeac6da6c5","modified":1655182275876},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1655182275880},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1655182275881},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"26be2afa9d4e7016cf3c42a6cd166f01e8e4ad5c","modified":1655182275894},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"d97c1722ce0fcc319f1f90ec2d51f9d746748e2b","modified":1655182275898},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"ef21990de28bd75dcd0f88b8d616e1a7a137502f","modified":1655182275917},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1655182275921},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"15056fba0bd5a45ea8dc97eb557f6929ff16797a","modified":1655182275923},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1655182275926},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1655182275926},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"bd88ee30ebf8ca2e7b4d3a034c317fd61733921f","modified":1655182275927},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"8314e9749eb1ae40c4bae9735b7a6638b2d6876a","modified":1655182275934},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1655182275929},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"f67177310f5594954b25a591d186d28d5d450b18","modified":1655182275888},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"69f8e9414526dfda3af9a71c8e528fdd0ecbbfe5","modified":1655182275925},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1655182275872},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"6f4b4ede52305bce9b22c8c897dcbde8af6e2ce4","modified":1655182275874},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1655182275879},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1655182275882},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1655182275893},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"826dae759062d8f84eb2bf5ab8fdb80e0f79d58b","modified":1655182275906},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1655182275932},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"51e45625929d57c9df3ba9090af99b9b7bb9a15b","modified":1655182275873},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"39d61cbe0c1e937f83ba3b147afaa29b4de2f87d","modified":1655182275912},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"25e58a7a8bda4b73d0a0e551643ca01b09ccd7e5","modified":1655182275918},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1655182275878},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"a310e48f826a4cacc55d8e68f43806e5085554f6","modified":1655182275896},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1655182275899},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1655182275914},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1655182275903},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1655182275915},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"08493b66b9f31f2bd3e9a3115017a0ce16142b20","modified":1655182275920},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1655182275930},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1655182275934},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1655182275700},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"ce8131b712dca80f289015aef75f86e727f62981","modified":1655182275712},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1655182275728},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1655182275785},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1655182275789},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1655182275790},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1655182275810},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1655182275814},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1655182275858},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1655182275796},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1655182275801},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"58406a7a3bf45815769f652bf3ef81e57dcd07eb","modified":1655182275861},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1655182275814},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1655182275797},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"5f648086a33a32d169a2f8d8c549c08aa02f67db","modified":1655182275868},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"e4b7bf91a29bd03181593b63e1f3ee1103af2e48","modified":1655182275864},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"693d999777dd16e0566d29ac3203d4c167b2f9a7","modified":1655182275797},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"2d8fc3fb8f9aec61400acf3c94070bd8539058f8","modified":1655182275800},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"591ef23c583690bd74af0cafb09af64ba5bd8151","modified":1655182275806},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"22e2ef30fe5eb1db7566e89943c74ece029b2a8e","modified":1655182275807},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"9302837f1e35f153323bb4f166514c7e96e8ecdd","modified":1655182275823},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"e4850f2c9ba5f6b2248808f7257662679e0fab0a","modified":1655182275816},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1655182275826},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"81c6070e06ecc2244040c7007566d7972f46ec4e","modified":1655182275862},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1655182275864},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1655182275865},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"15462d1ed04651ad3b430c682842ac400f6f9b47","modified":1655182275869},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1655182275817},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"31b007dc0f3de52176f278012ecf17a4bcecde2c","modified":1655182275824},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"f4dc7d02c8192979404ae9e134c5048d3d0a76e2","modified":1655182275830},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"8e33aca36a4d3ae9e041ba05ced8eff56ae38f77","modified":1655182275832},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1655182275795},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1655182275808},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1655182275818},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"233907dd7f5b5f33412701d2ccffbc0bbae8707b","modified":1655182275859},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1655182275866},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"dd0bc119029b62dce5dc965d5de7377e438fa29a","modified":1655182275870},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"e8245d0b4933129bb1c485d8de11a9e52e676348","modified":1655182275766},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1655182275820},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"178c9cdcc4ce5a006885b24ce4a3d624e4734899","modified":1655182275828},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1655182275762},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1655182275764},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1655182275820},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"f61d63724ea5c5f352568b3a16bde023affefbe5","modified":1655182275851},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1655182275890},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1655182275908},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1655182275892},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1655182275916},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1655182275911},{"_id":"source/images/bg3.png","hash":"311c1a7a031d44980557734b26416491069e0165","modified":1655277732256},{"_id":"public/search.xml","hash":"b972962e5626e6f766c96ce0fb2ffbbf418fd148","modified":1655358245240},{"_id":"public/404.html","hash":"b9fed2123ab3cda434b31cffbfc3413b6adf596a","modified":1655358245240},{"_id":"public/categories/index.html","hash":"6190acb32e906ab76bbd5e1567503a3944e0783f","modified":1655358245240},{"_id":"public/link/index.html","hash":"ab708781e208afa2761fda259b7ad3233f212645","modified":1655358245240},{"_id":"public/tags/index.html","hash":"9e0a78c619245276963ef68568aea448f3c507bf","modified":1655358245240},{"_id":"public/2022/06/15/Vue笔记/index.html","hash":"eebee8a7e164894c6019965899d0470856f0aa28","modified":1655358245240},{"_id":"public/2022/06/15/面试笔记/index.html","hash":"9d767231dc270d2e6c6ed31551c2eb6d434347df","modified":1655358245240},{"_id":"public/2022/06/15/test2/index.html","hash":"10a1b2cdf94d18cbd40ddf7dc2293ebbde2d8aa8","modified":1655358245240},{"_id":"public/2022/06/14/test/index.html","hash":"1c91ee1b505c80df7f53fd94a16efde0aec3b223","modified":1655358245240},{"_id":"public/archives/index.html","hash":"b1e5680ea81ca30e9e5f4dcbc90b35ca62523fdd","modified":1655358245240},{"_id":"public/archives/2022/index.html","hash":"466c710549e028ed74315b10db7fe201d95db5ee","modified":1655358245240},{"_id":"public/archives/2022/06/index.html","hash":"cb76e94137463debb7b2d0d8e424d84c46095f5c","modified":1655358245240},{"_id":"public/index.html","hash":"c7db7bdde696812ed2de1d80fee6ec20ce7151b8","modified":1655358245240},{"_id":"public/images/1655176266176.png.jpg","hash":"6c6d9cb0495a5b7f94a653f067a901de43ad93f7","modified":1655358245240},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1655358245240},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1655358245240},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1655358245240},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655358245240},{"_id":"public/js/chocolate.js","hash":"4657da8b13cc578bbe948db62b761a8c9c538bfb","modified":1655358245240},{"_id":"public/js/search/algolia.js","hash":"ce8131b712dca80f289015aef75f86e727f62981","modified":1655358245240},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1655358245240},{"_id":"public/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1655358245240},{"_id":"public/css/index.css","hash":"39eb770cde03e6f0854636f4d6e06319202a6be6","modified":1655358245240},{"_id":"public/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1655358245240},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1655358245240},{"_id":"public/images/bg2.jpg","hash":"35fff0f33df8c7174bcde6ed2a00e6f841afa24d","modified":1655358245240},{"_id":"public/images/touxiang.jpg","hash":"6623c6e879f3f993d4dacf47e18b411d286cb4af","modified":1655358245240},{"_id":"public/images/bg1.jpg","hash":"db88b65e171e2c7c0adc150ff2e7d251be65303f","modified":1655358245240},{"_id":"public/images/touxiang2.jpg","hash":"1374ddeb675c7bf8ef3a1cbbc36ea38293f5a8a0","modified":1655358245240},{"_id":"public/images/touxiang3.jpg","hash":"8046de5a3d038696bab0f1c3c9dddb0fb6f8313d","modified":1655358245240},{"_id":"public/images/bg3.png","hash":"311c1a7a031d44980557734b26416491069e0165","modified":1655358245240}],"Category":[],"Data":[{"_id":"link","data":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}],"Page":[{"title":"分类","date":"2022-06-14T07:11:06.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-06-14 15:11:06\ntype: \"categories\"\n---\n","updated":"2022-06-14T07:11:23.129Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl4glk6rk00002wtm2wphc85z","content":"","site":{"data":{"link":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}},"cover":"./images/touxiang2.jpg","excerpt":"","more":""},{"title":"友情链接","date":"2022-06-14T07:11:33.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2022-06-14 15:11:33\ntype: \"link\" \n---\n","updated":"2022-06-14T07:12:03.263Z","path":"link/index.html","comments":1,"layout":"page","_id":"cl4glk6rp00022wtm732xh601","content":"","site":{"data":{"link":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}},"cover":"./images/touxiang2.jpg","excerpt":"","more":""},{"title":"标签","date":"2022-06-14T07:10:10.000Z","type":"tags","top_img":"./images/touxiang.jpg","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-06-14 15:10:10\ntype: \"tags\"\ntop_img: ./images/touxiang.jpg\n---\n","updated":"2022-06-15T04:56:07.725Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl4glk6rq00032wtm9tougzng","content":"","site":{"data":{"link":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}},"cover":"./images/touxiang2.jpg","excerpt":"","more":""}],"Post":[{"title":"Vue笔记","data":"2022-6-15","description":"这里是description","copyright_author":"wxb","copyright_author_href":"https://xxxxxx.com","copyright_url":"https://xxxxxx.com","copyright_info":"此文章版权归wxb所有，如有转载，请註明来自原作者","_content":"\n#  笔记\n\n开启服务器：npm run serve\n\n关闭服务器:两次ctrl+c \n\n## 脚手架文件结构\n\n\t├── node_modules \n\t├── public\n\t│   ├── favicon.ico: 页签图标\n\t│   └── index.html: 主页面\n\t├── src\n\t│   ├── assets: 存放静态资源\n\t│   │   └── logo.png\n\t│   │── component: 存放组件\n\t│   │   └── HelloWorld.vue\n\t│   │── App.vue: 汇总所有组件\n\t│   │── main.js: 入口文件\n\t├── .gitignore: git版本管制忽略的配置\n\t├── babel.config.js: babel的配置文件\n\t├── package.json: 应用包配置文件 \n\t├── README.md: 应用描述文件\n\t├── package-lock.json：包版本控制文件\n\n## 关于不同版本的Vue\n\n1. vue.js与vue.runtime.xxx.js的区别：\n    1. vue.js是完整版的Vue，包含：核心功能 + 模板解析器。\n    2. vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。\n2. 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。\n\n## vue.config.js配置文件\n\n1. 使用vue inspect > output.js可以查看到Vue脚手架的默认配置。\n2. 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh\n\n## ref属性\n\n1. 被用来给元素或子组件注册引用信息（id的替代者）\n2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）\n3. 使用方式：\n    1. 打标识：```<h1 ref=\"xxx\">.....</h1>``` 或 ```<School ref=\"xxx\"></School>```\n    2. 获取：```this.$refs.xxx```\n\n## props配置项\n\n1. 功能：让组件接收外部传过来的数据，传过来的数据都会存储在vc(组件实例对象)身上，可以直接通过this.name获取\n\n2. 传递数据：```<Demo name=\"xxx\"/>```  直接在标签里面传递数据即可\n\n3. 接收数据：\n\n    1. 第一种方式（只接收）：```props:['name'] ```\n\n    2. 第二种方式（限制类型）：```props:{name:String}```\n\n    3. 第三种方式（限制类型、限制必要性、指定默认值）：\n\n    3. 且required和default不会同时限定的\n    \n        ```js\n        props:{\n        \tname:{\n        \ttype:String, //类型\n        \trequired:true, //必要性\n        \tdefault:'老王' //默认值\n        \t} \n        }\n        ```\n    \n    > 1. 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。\n    > 2. props的优先级要高于data，Vue会先读取props中的数据\n    >\n    > \n\n## mixin(混入)\n\n1. 功能：可以把多个组件共用的配置提取成一个混入对象，就是有多个子组件中具有相同的功能或者属性时，我们可以将这些共用的配置封装成一个mixin.js，并将其暴露，最后可以被各个组件导入并使用\n\n2. 使用方式：\n\n    第一步定义混合：\n\n    ```js\n    {\n        data(){....},\n        methods:{....}\n        ....\n    }\n    ```\n\n    第二步导入 \n\n    ```js\n    import {xxx,xxx} from '../mixin'\n    ```\n    \n    第三步使用混入：\n    \n    ​\t全局混入：```Vue.mixin(xxx)``` ，全局混入是在main.js中导入并使用的\n    ​\t局部混入：```mixins:['xxx']\t``` ，局部混入是在应用到这个共用配置的子组件中导入并使用的\n\n## 插件\n\n1. 功能：用于增强Vue\n\n2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n\n3. 步骤：a. 首先定义一个插件plugins.js\n\n    ​\t\t   b. 在main.js中导入import\n\n    ​\t\t   c. 在main.js中应用导入后的组件 Vue.use(plugins,参数1，参数2···)\n\n3. 定义插件：\n\n    ```js\n    对象.install = function (Vue, options) {\n        // 1. 添加全局过滤器\n        Vue.filter(....)\n    \n        // 2. 添加全局指令\n        Vue.directive(....)\n    \n        // 3. 配置全局混入(合)\n        Vue.mixin(....)\n    \n        // 4. 添加实例方法\n        Vue.prototype.$myMethod = function () {...}\n        Vue.prototype.$myProperty = xxxx\n    }\n    ```\n\n4. 使用插件：```Vue.use(插件名,使用者传入的参数)```\n\n## scoped样式\n\n1. 作用：让样式在局部生效，防止冲突。因为多个子组件中的样式类名可能会有相同的，那么这时加上了scoped后，该样式只在该子组件内生效\n2. 写法：```<style scoped>```\n\n## 总结TodoList案例(组件间的通信)\n\n1. 组件化编码流程：\n\n    ​\t(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n\n    ​\t(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n\n    ​\t\t\t1).一个组件在用：放在组件自身即可。\n\n    ​\t\t\t2). 一些组件在用：放在他们共同的父组件上（<span style=\"color:red\">状态提升</span>）例子中表现为将todoList数据放在总组件App中，供下面的子组件来使用。\n\n    ​\t(3).实现交互：从绑定事件开始。\n\n2. props适用于：\n\n    ​\t(1).父组件 ==> 子组件 通信 (爷爷组件==>子组件时，需要爷爷组件先传给父组件，再通过父组件传给子组件)\n\n    ​\t(2).子组件 ==> 父组件 通信（要求父先给子一个函数），这个函数定义在父组件中，并通过子组件标签来将这个函数传给子组件，\n\n    ​\t\t\t\t\t\t\t子组件再通过props将该函数接收，接收之后子组件的vc身上就会多出来这一个函数，直接可以利用this.func(para)调用。\n\n3. 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！\n\n4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\n\n## webStorage\n\n1. 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n\n2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n\n3. 相关API：\n\n    1. ```xxxxxStorage.setItem('key', 'value');```\n        \t\t\t\t该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。不论是sessionStorage还是localStroage都是以key：value键值对的形式来进行数据存储的\n\n    2. ```xxxxxStorage.getItem('person');```\n\n        ​\t\t该方法接受一个键名作为参数，返回键名对应的值。\n\n    3. ```xxxxxStorage.removeItem('key');```\n\n        ​\t\t该方法接受一个键名作为参数，并把该键名从存储中删除。\n\n    4. ``` xxxxxStorage.clear()```\n\n        ​\t\t该方法会清空存储中的所有数据。\n\n4. 备注：\n\n    1. SessionStorage存储的内容会随着浏览器窗口关闭而消失。\n    \n    2. LocalStorage存储的内容，需要手动清除才会消失(1.用户自主地清空浏览器地缓存 2.用户点击了实现清空clear()的操作)。\n    \n    3. ```xxxxxStorage.getItem(xxx)```如果xxx对应的value获取不到，那么getItem的返回值是null。\n    \n    4. ```JSON.parse(null)```的结果依然是null。\n    \n    5. 本地存储和会话存储都不能存储对象，不过可以通过JSON.stringify()将对象先转化为字符串存储到xxxStroage中\n    \n       获取的时候再通过 JSON.parse()将存储的字符串再转化为对象\n\n## 组件的自定义事件\n\n1. 一种组件间通信的方式，适用于：<strong style=\"color:#3cb371\">子组件 ===> 父组件</strong>\n\n2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style=\"color:#3cb371\">事件的回调函数在A中，因为这个回调函数就是用来接收子组件传过来的数据</span>）。\n\n3. 绑定自定义事件：\n\n    1. 第一种方式，在父组件中：```<Demo @atguigu=\"test\"/>```  或 ```<Demo v-on:atguigu=\"test\"/>``` 第一种直接在标签里面绑定自定义事件 注意这里的回调函数test是不需要写参数的，他需要在methods中实现的时候才加上参数实现test(data)\n\n    2. 第二种方式，在父组件中：第二种首先需要在目标的子组件上定义ref属性，再在本组件的mounted钩子中完成事件绑定\n\n        ```js\n        <Demo ref=\"demo\"/>\n        ......\n        mounted(){\n           this.$refs.xxx.$on('atguigu',this.test)\n        }\n        ```\n\n    3. 若想让自定义事件只能触发一次，可以使用```.once```修饰符，或```$once```方法。\n\n4. 触发自定义事件：```this.$emit('atguigu',要传递的数据)```\t\t要传递的数据就是在触发自定义事件的时候，以参数的形式传给对应的回调函数\n\n5. 解绑自定义事件```this.$off('atguigu')```\n\n6. 组件上也可以绑定原生DOM事件（例如@click），需要使用```.native```修饰符（@click.native）。否则，会默认他是一个自定义事件！\n\n7. 注意：通过```this.$refs.xxx.$on('atguigu',回调)```绑定自定义事件时，回调<span style=\"color:#3cb371\">要么配置在methods中</span>，<span style=\"color:#3cb371\">要么用箭头函数</span>，否则this指向会出问题！\n\n## 全局事件总线（GlobalEventBus）\n\n1. 一种组件间通信的方式，适用于<span style=\"color:#3cb371\">任意组件间通信</span>。\n\n2. 安装全局事件总线：<span style=\"color:#3cb371\">事件总线有两个要求：1. 需要让所有的组件都能够访问的到    2. 且身上具有$on,$emit等api</span>\n\n   ```js\n   new Vue({\n   \t......//beforeCreate()注意在这个创建之前钩子中进行设置\n   \tbeforeCreate() {\n   \t\tVue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm\n       //1.因为将这个总线(傀儡)$bus放在Vue的原型对象上，那么所有的vc组件实例对象都能够通过原型链向上找到这个总线$bus\n       //2.且这个$bus就是vm，因为这样他身上才会有$on,$off,$emit等api\n   \t},\n       ......\n   }) \n   ```\n\n3. 使用事件总线：\n\n   1. 接收数据组件<span style=\"color:#3cb371\">(绑定事件)</span>：A组件想接收数据，则在A组件中给$bus绑定自定义事件<span style=\"color:#3cb371\">(在mounted钩子中进行绑定，一挂载就绑定)</span>，事件的<span style=\"color:#3cb371\">回调留在A组件自身。</span>\n\n      ```js\n      methods(){\n        demo(data){......}\n      }\n      ......\n      mounted() {\n        this.$bus.$on('xxxx',this.demo)\n      }\n      ```\n\n   2. 提供数据组件<span style=\"color:#3cb371\">(触发事件)</span>：```this.$bus.$emit('xxxx',数据)``` <span style=\"color:#3cb371\">提供数据的组件，需要在本组件方法内$emit触发事件总线中绑定的事件，并通过参数来传送数据</span>\n\n4. 接收数据的组件最好在beforeDestroy钩子中，用this.$bus.$off去解绑<span style=\"color:#3cb371\">当前组件所用到的</span>事件。\n\n## 消息订阅与发布（pubsub）\n\n1.   一种组件间通信的方式，适用于<span style=\"color:#3cb371\">任意组件间通信</span>。\n\n2. 使用步骤：\n\n   1. 安装pubsub：```npm i pubsub-js```\n\n   2. 引入: ```import pubsub from 'pubsub-js'``` 用到pubsub的vue组件都需要引入\n\n   3. 接收数据<span style=\"color:#3cb371\">(订阅消息)</span>：A组件想接收数据，则在A组件中订阅消息，订阅的<span style=\"color:#3cb371\">回调留在A组件自身。</span>\n\n      ```js\n      methods(){\n          //一定要注意订阅消息时，后面的回调函数中第一个参数是固定的msgName为本次消息名，这里用_来占位，后面的data才是真正的获取的数据\n        demo(_,data){......}\n      }\n      ......\n      //消息的订阅也是在组件挂载完毕的钩子中完成的\n      mounted() {\n        this.pid = pubsub.subscribe('消息名',this.demo) //订阅消息\n\t     //注意订阅消息后，会返回一个订阅id，这个id是用来找到这个消息，并取消订阅\n      }\n\t   ```\n   \n\t4. 提供数据<span style=\"color:#3cb371\">(发布消息)</span>：```pubsub.publish('消息名',数据)```\n\t\n\t5. 最好在beforeDestroy钩子中，用```pubsub.unsubscribe(this.pid)```去<span style=\"color:#3cb371\">取消订阅。</span>\n\t\n## nextTick\n\n1. 语法：```this.$nextTick(回调函数)```\n2. 作用：在下一次 DOM 更新结束后执行其指定的回调。在对原dom做出修改后，Vue重新解析模板后生成的新dom，这时我们对这个新dom进行一些操作时，需要通过$nextTick(function{})中的回调来实现\n3. 什么时候用：当改变数据后<span style=\"color:#3cb371\">(例如修改了data中的值)</span>>，要基于更新后的新DOM进行某些操作时<span style=\"color:#3cb371\">(例如修改后，会有一个input框的生成，我们想要在input框生成后就立即获取焦点focus())</span>>，这时要在nextTick所指定的回调函数中执行(完成获取焦点的操作)。\n\n## Vue封装的过渡与动画\n\n1. 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。\n\n2. 动画可以引入第三方的动画库(animate.css) 添加指定的name，appear-active-class，leave-active-class即可完成动画效果\n\n3. 写法：\n\n   1. 准备好样式：\n\n      - 元素进入的样式：\n        1. v-enter：进入的起点\n        2. v-enter-active：进入过程中\n        3. v-enter-to：进入的终点\n      - 元素离开的样式：\n        1. v-leave：离开的起点\n        2. v-leave-active：离开过程中\n        3. v-leave-to：离开的终点\n\n   2. 使用```<transition>```包裹要过渡的元素，并配置name属性：\n\n      ```vue\n      <transition name=\"hello\">\n      \t<h1 v-show=\"isShow\">你好啊！</h1>\n      </transition>\n      ```\n\n   3. 备注：若有多个元素需要过渡，则需要使用：```<transition-group>```，且每个元素都要指定```key```值。\n\n## vue脚手架配置代理\n\n以下都通过axios来发送ajax请求：1.首先先安装axios包： npm i axios\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t   2.导入axios：import axios from 'axios'\n\n实现跨域：1.cors <span style=\"color:#3cb371\">真正解决了跨域问题</span>\n\n​\t\t\t\t 2.jsonp <span style=\"color:#3cb371\">jsonp实现跨域的本质是通过script标签的src属性在引入外部资源时，不受到同源限制的特点来实现的，但是只能解决get请求，要求前后端配合写法</span>\n\n​\t\t\t\t 3.利用代理服务器<span style=\"color:#3cb371\">（开启代理服务器的两种方式：1.通过Nginx     2.通过vue-cli脚手架）</span>\n\n文件中的两个服务器开启方式：文件中打开cmd，命令node server1/server2   \n\n关闭服务器：ctrl+c\n\n\n\n### 方法一\n\n​\t在vue.config.js中添加如下配置：\n\n```js\ndevServer:{\n  proxy:\"http://localhost:5000\"\n}\n```\n\n说明：\n\n1. 优点：配置简单，请求资源时直接发给前端（8080）即可。\n2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。\n3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （如果前端有这个资源，也就是根目录public下有的资源，那么就优先匹配前端资源，不会再去转发给目标服务器了）\n\n### 方法二\n\n​\t编写vue.config.js配置具体代理规则：\n\n```js\nmodule.exports = {\n\tdevServer: {\n      proxy: {\n      '/api1': {// 匹配所有以 '/api1'开头的请求路径\n        target: 'http://localhost:5000',// 代理目标的基础路径，也就是只写到端口号即可，不用写到具体的资源路径\n        changeOrigin: true,\n        pathRewrite: {'^/api1': ''}// pathRewrite路径重写，里面是一个key:value键值对形式\n          //   ^/api1表示把所有的以api1开头的路径，把这段路径修改为空，即没有了/api1\n      },\n      '/api2': {// 匹配所有以 '/api2'开头的请求路径\n        target: 'http://localhost:5001',// 代理目标的基础路径\n        changeOrigin: true,\n        pathRewrite: {'^/api2': ''}\n      }\n    }\n  }\n}\n/*\n   changeOrigin设置为true时(代理服务器撒谎了，说自己的host与代理服务器的目标服务器相同都为localhost:5000)，服务器收到的请求头中的host为：localhost:5000\n   changeOrigin设置为false时(代理服务器如实回答)，服务器收到的请求头中的host为：localhost:8080\n   changeOrigin默认值为true\n*/\n```\n\n说明：\n\n1. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。\n2. 缺点：配置略微繁琐，请求资源时必须加前缀。\n\n## 插槽\n\n1. 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style=\"color:#3cb371\">父组件 ===> 子组件</strong> 。\n\n2. 分类：默认插槽、具名插槽、作用域插槽\n\n3. 使用方式：\n\n   1. 默认插槽：\n\n      ```vue\n      父组件中：\n              <Category>\n                 <div>html结构1</div>\n              </Category>\n      子组件中：\n              <template>\n                  <div>\n                     <!-- 定义插槽 -->\n                     <slot>插槽默认内容...</slot>\n                  </div>\n              </template>\n      ```\n\n   2. 具名插槽：\n\n      ```vue\n      父组件中：\n              <Category>\n                  <template slot=\"center\">\n                    <div>html结构1</div>\n                  </template>\n      \t\t<!--- 当我使用了template时，指定插槽也可以用下面的方式v-slot:footer-->\n                  <template v-slot:footer>\n                     <div>html结构2</div>\n                  </template>\n              </Category>\n      子组件中：\n              <template>\n                  <div>\n                     <!-- 定义插槽 -->\n                     <slot name=\"center\">插槽默认内容...</slot>\n                     <slot name=\"footer\">插槽默认内容...</slot>\n                  </div>\n              </template>\n      ```\n\n   3. 作用域插槽：\n\n      1. 理解：<span style=\"color:#3cb371\">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在子组件Category中，但使用数据所遍历出来的结构由父组件App决定）\n\n      1. 作用域插槽必须通过template标签进行包裹\n\n      2. 具体编码：\n      \n         ```vue\n         父组件中：\n         \t\t<Category>\n                     <!--- 这里可以利用对象的解构赋值，这样就直接可以使用games获取到scopeData.games的属性值-->\n                     <!--- scope=\"{games}\"-->\n         \t\t\t<template scope=\"scopeData\">\n         \t\t\t\t<!-- 生成的是ul列表 -->\n         \t\t\t\t<ul>\n         \t\t\t\t\t<li v-for=\"g in scopeData.games\" :key=\"g\">{{g}}</li>\n         \t\t\t\t</ul>\n         \t\t\t</template>\n         \t\t</Category>\n         \n         \t\t<Category>\n         \t\t\t<template slot-scope=\"scopeData\">\n         \t\t\t\t<!-- 生成的是h4标题 -->\n         \t\t\t\t<h4 v-for=\"g in scopeData.games\" :key=\"g\">{{g}}</h4>\n         \t\t\t</template>\n         \t\t</Category>\n         子组件中：\n                 <template>\n                     <div>\n                         <slot :games=\"games\"></slot>\n                     </div>\n                 </template>\n         \t\t\n                 <script>\n                     export default {\n                         name:'Category',\n                         props:['title'],\n                         //数据在子组件自身\n                         data() {\n                             return {\n                                 games:['红色警戒','穿越火线','劲舞团','超级玛丽']\n                             }\n                         },\n                     }\n                 </script>\n         ```\n\n## Vuex\n\n### 1.概念\n\n​\t\t在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。\n\n### 2.何时使用？\n\n​\t\t多个组件需要共享数据时\n\n### 3.搭建vuex环境\n\n1. 创建文件：```src/store/index.js```\n\n   ```js\n   //引入Vue核心库\n   import Vue from 'vue'\n   //引入Vuex\n   import Vuex from 'vuex'\n   //应用Vuex插件\n   Vue.use(Vuex)\n   \n   //准备actions对象——响应组件中用户的动作，相当于服务员\n   const actions = {}\n   //准备mutations对象——修改state中的数据，相当于厨师\n   const mutations = {}\n   //准备state对象——保存具体的数据，相当于最后的菜品\n   const state = {}\n   \n   //创建并暴露store\n   export default new Vuex.Store({\n   \tactions,\n   \tmutations,\n   \tstate\n   })\n   ```\n\n2. 在```main.js```中创建vm时传入```store```配置项\n\n   ```js\n   //引入Vue\n   import Vue from 'vue'\n   //引入App\n   import App from './App.vue'\n   //引入插件\n   import vueResource from 'vue-resource'\n   //关闭Vue的生产提示\n   Vue.config.productionTip = false\n   //使用插件\n   Vue.use(vueResource)\n   //1.引入store\n   import store from './store'\n   \n   //创建vm\n   new Vue({\n   \tel: '#app',\n   \t//注意一定要在vm里面定义使用\n   \tstore,//2.定义store，这样vm以及所有的vc身上都会有$store了，都可以通过this.$store来调用\n   \trender: h => h(App),\n   \tbeforeCreate() {\n   \t\tVue.prototype.$bus = this\n   \t}\n   })\n   ```\n\n###    4.基本使用\n\n1. 初始化数据、配置```actions```、配置```mutations```，操作文件```store.js```\n\n   ```js\n   //引入Vue核心库\n   import Vue from 'vue'\n   //引入Vuex\n   import Vuex from 'vuex'\n   //引用Vuex,因为vuex本身是一个插件plguins，所以导入后需要通过Vue.use()使用\n   //因为只有先使用Vue.use(Vuex)，才能去创建new Vuex.Store()\n   Vue.use(Vuex)\n   \n   //actions是用来接收vc通过this.$dispatch('操作名add',参数)，这时里面操作名add需要在actions中配置\n   //并接收参数value\n   const actions = {\n       //🌈context为上下文，其中有commit(),dispatch(),state....等方法和属性\n       //context.commit()用来将接收到的数据进一步呈递给mutations处理\n       //context.dispatch()当业务逻辑很复杂时，在一个操作函数中并不能完成逻辑，那么就需要context.dispatch('demo',value)进一步分发给\n       //同在actions中的其他方法demo()，demo会对进一步完成逻辑操作，使最终满足业务逻辑要求\n       //context中具有state属性，所以它可以直接访问到里面的状态(数据)sum\n       //🌟当数据需要进行一些逻辑操作时，就需要放在actions执行\n       addWhenOdd(context, value) {\n           if (context.state.sum % 2) {\n               context.commit('ADD', value)//commit传给mutations时的方法名一般要全大写ADD\n           }\n       },\n       addWait(context, value) {\n           setTimeout(() => {\n               context.commit('ADD', value)\n           }, 500);\n       }\n   }\n   //mutations是用来处理数据的，数据通过actions中的对应操作的函数调用commit方法来传递给mutaiton\n   const mutations = {\n       ADD(state, value) {\n           console.log('mutations中的+被调用了');\n           state.sum += value\n       },\n       SUBTRACT(state, value) {\n           console.log('mutations中的-被调用了');\n           state.sum -= value\n       }\n   }\n   //所共享的数据都会放在state中\n   const state = {\n       sum: 0\n   }\n   \n   //创建并暴露store\n   export default new Vuex.Store({\n       //这因为key:value值相同，所以都使用简写形式\n       actions,\n       mutations,\n       state,\n   \n   })\n   ```\n   \n2. 组件中读取vuex中的数据：```$store.state.sum```\n\n3. 组件中修改vuex中的数据：```$store.dispatch('action中的方法名',数据)``` 或 ```$store.commit('mutations中的方法名',数据)```\n\n   >  <span style=\"color:#3cb371\">备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写```dispatch```，直接编写```commit```</span>\n\n![](C:\\Users\\24825\\Desktop\\Vue资料\\02_原理图\\vuex.png)\n\n### 5.getters的使用\n\n1. 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。<span style=\"color:#3cb371\">它其实可以理解为Vuex中的计算属性computed,对于state中的数据进一步加工，最后通过return返回加工后的值。</span>\n\n2. 在```store.js```中追加```getters```配置\n\n   ```js\n   ......\n   \n   const getters = {\n   \tbigSum(state){\n   \t\treturn state.sum * 10//需要return返回处理后的值\n   \t}\n   }\n   \n   //创建并暴露store\n   export default new Vuex.Store({\n   \t......\n   \tgetters\n   })\n   ```\n\n3. 组件中读取数据：```$store.getters.bigSum```\n\n### 6.四个map方法的使用\n\n> 备注：mapState, mapGetters这两个是帮我们生成一个计算属性的（配置在computed中）\n>\n> ​\t mapMutations, mapActions这两个是帮我们生成一个方法的（配置在methods中）\n\n首先需要在组件中导入mapState, mapGetters, mapMutations, mapActions\n\n```js\nimport {mapState, mapGetters, mapMutations, mapActions} from 'vuex'\n```\n\n1. <strong>mapState方法：</strong>用于帮助我们映射```state```中的数据为<span style=\"color:#3cb371\">计算属性</span>,mapXxx就是从Xxx取东西\n\n   ```js\n   computed: {\n       //借助mapState生成计算属性：sum、school、subject（对象写法）\n       //...{}可以将一个对象中的key:value分解出来，形成单独的key:value\n       //前面的sum表示的计算属性的函数名（本身对象的key可以简写不用加引号），后面的'sum'表示要从state中读取名为sum这个属性值\n        ...mapState({sum:'sum',school:'school',subject:'subject'}),\n            \n       //借助mapState生成计算属性：sum、school、subject（数组写法）\n       //写成数组时['sum']，这时'sum'有两种用途，也就是计算属性名和读取数据名要相同！！\n            //1. 将sum作为计算属性sum(){}\n            //2. 从state中读取名为'sum'的属性值\n       ...mapState(['sum','school','subject']),\n   },\n   ```\n\n2. <strong>mapGetters方法：</strong>用于帮助我们映射```getters```中的数据为计算属性\n\n   ```js\n   computed: {\n       //借助mapGetters生成计算属性：bigSum（对象写法）\n       ...mapGetters({bigSum:'bigSum'}),\n   \n       //借助mapGetters生成计算属性：bigSum（数组写法）\n       ...mapGetters(['bigSum'])\n   },\n   ```\n\n3. <strong>mapActions方法：</strong>用于帮助我们生成与```actions```对话的方法，即：包含```$store.dispatch(xxx)```的函数\n\n   ```js\n   methods:{\n       //靠mapActions生成：incrementOdd、incrementWait（对象形式）\n       ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})\n   \n       //靠mapActions生成：incrementOdd、incrementWait（数组形式）\n       ...mapActions(['jiaOdd','jiaWait'])\n   }\n   ```\n\n4. <strong>mapMutations方法：</strong>用于帮助我们生成与```mutations```对话的方法，即：包含```$store.commit(xxx)```的函数\n\n   ```js\n   methods:{\n       //靠mapActions生成：increment、decrement（对象形式）\n       //其中increment就会作为methods中的方法名,形成一个increment(vlaue){方法内部就会调用commit去联系mutations}的方法，'JIA'是会去mutations中找名为JIA的函数并执行它\n       //这样的话就不需要我们通过$store.commit('JIA'，value)来去和mutations进行对话了\n       //注意这里无法传入increment方法所需的参数，所以需要在模板中绑定事件触发该increment方法时就传入参数value\n       ...mapMutations({increment:'JIA',decrement:'JIAN'}),\n       \n       //靠mapMutations生成：JIA、JIAN（对象形式）\n       ...mapMutations(['JIA','JIAN']),\n   }\n   ```\n\n> 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\n\n### 7.模块化+命名空间\n\n1. 目的：让代码更好维护，让多种数据分类更加明确。\n\n2. 修改```store.js```\n\n   ```javascript\n   const countAbout = {\n     namespaced:true,//开启命名空间\n     state:{x:1},\n     mutations: { ... },\n     actions: { ... },\n     getters: {\n       bigSum(state){\n          return state.sum * 10\n       }\n     }\n   }\n   \n   const personAbout = {\n     namespaced:true,//开启命名空间\n     state:{ ... },\n     mutations: { ... },\n     actions: { ... }\n   }\n   \n   const store = new Vuex.Store({\n     modules: {\n       countAbout,\n       personAbout\n     }\n   })\n   ```\n\n3. 开启命名空间后，组件中读取state数据：\n\n   ```js\n   //方式一：自己直接读取\n   this.$store.state.personAbout.list\n   //方式二：借助mapState读取：\n   ...mapState('countAbout',['sum','school','subject']),\n   ```\n\n4. 开启命名空间后，组件中读取getters数据：\n\n   ```js\n   //方式一：自己直接读取\n   this.$store.getters['personAbout/firstPersonName']\n   //方式二：借助mapGetters读取：\n   ...mapGetters('countAbout',['bigSum'])\n   ```\n\n5. 开启命名空间后，组件中调用dispatch\n\n   ```js\n   //方式一：自己直接dispatch\n   this.$store.dispatch('personAbout/addPersonWang',person)\n   //方式二：借助mapActions：\n   ...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})\n   ```\n\n6. 开启命名空间后，组件中调用commit\n\n   ```js\n   //方式一：自己直接commit\n   this.$store.commit('personAbout/ADD_PERSON',person)\n   //方式二：借助mapMutations：\n   ...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),\n   ```\n\n ## 路由\n\n1. 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n2. 前端路由：key是路径，value是组件。\n\n### 1.基本使用\n\n1. 安装vue-router，命令：```npm i vue-router```\n\n2. 应用插件：```Vue.use(VueRouter)``` 在main.js中应用路由插件VueRouter，并在vm中配置路由器属性router\n\n3. 编写router路由器配置项: 路由器会独立写在一个目录为router下的index.js文件中\n\n   ```js\n   //引入VueRouter\n   import VueRouter from 'vue-router'\n   //引入Luyou 组件\n   import About from '../components/About'\n   import Home from '../components/Home'\n   \n   //创建router实例对象，去管理一组一组的路由规则\n   const router = new VueRouter({\n   \troutes:[\n   \t\t{\n   \t\t\tpath:'/about',\n   \t\t\tcomponent:About\n   \t\t},\n   \t\t{\n   \t\t\tpath:'/home',\n   \t\t\tcomponent:Home\n   \t\t}\n   \t]\n   })\n   \n   //暴露router\n   export default router\n   ```\n\n4. 实现切换（active-class可配置高亮样式）\n\n   ```vue\n   <router-link active-class=\"active\" to=\"/about\">About</router-link>\n   ```\n\n5. 指定展示位置\n\n   ```vue\n   <router-view></router-view>\n   ```\n\n### 2.几个注意点\n\n1. 路由组件通常存放在```pages```文件夹，一般组件通常存放在```components```文件夹。\n2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。\n3. 每个组件都有自己的```$route```属性，里面存储着自己的路由信息。\n4. 整个应用只有一个router，可以通过组件的```$router```属性获取到。\n\n### 3.多级路由（多级路由）\n\n1. 配置路由规则，使用children配置项：\n\n   ```js\n   routes:[\n       //一级路由\n   \t{\n   \t\tpath:'/about',\n   \t\tcomponent:About,\n   \t},\n   \t{\n   \t\tpath:'/home',\n   \t\tcomponent:Home,\n        \t//二级路由 \n   \t\tchildren:[ //通过children[]配置子级路由\n   \t\t\t{\n   \t\t\t\tpath:'news', //🌈此处一定不要写：/news\n   \t\t\t\tcomponent:News\n   \t\t\t},\n   \t\t\t{\n   \t\t\t\tpath:'message',//此处一定不要写：/message\n   \t\t\t\tcomponent:Message\n   \t\t\t}\n   \t\t]\n   \t}\n   ]\n   ```\n\n2. <span style=\"color:#3cb371\">跳转（要写完整路径）：</span>\n\n   ```vue\n   <router-link to=\"/home/news\">News</router-link>\n   ```\n\n### 4.路由的query参数\n\n因为组件的this.$route.query上包含着传过来的query参数信息\n\n1. 传递参数\n\n   ```vue\n   <!-- 跳转并携带query参数，to的字符串写法 -->\n   当使用to的字符串写法时，如果传递的参数时动态获取的，这时需要通过模板字符串``和${}进行操作，但注意to要加冒号绑定，且要有\"`${}`\"包裹\n   <router-link :to=\"`/home/message/detail?id=${js语句}&title=${js语句}`\">跳转</router-link>\n   \t\t\t\t\n   <!-- 跳转并携带query参数，to的对象写法 -->\n   <router-link \n   \t:to=\"{\n   \t\tpath:'/home/message/detail',\n   \t\tquery:{\n   \t\t   id:666,\n               title:'你好'\n   \t\t}\n   \t}\"\n   >跳转</router-link>\n   ```\n\n2. 接收参数：\n\n   ```js\n   $route.query.id\n   $route.query.title\n   ```\n\n### 5.命名路由\n\n1. 作用：可以简化路由的跳转。<span style=\"color:#3cb371\">但注意一定是当路径复杂，也就是到了三级四级之后的子路由，可以通过name来直接跳转</span>\n\n2. 如何使用\n\n   1. 给路由命名：\n\n      ```js\n      {\n      \tpath:'/demo',\n      \tcomponent:Demo,\n      \tchildren:[\n      \t\t{\n      \t\t\tpath:'test',\n      \t\t\tcomponent:Test,\n      \t\t\tchildren:[\n      \t\t\t\t{\n                            name:'hello' //给路由命名\n      \t\t\t\t\tpath:'welcome',\n      \t\t\t\t\tcomponent:Hello,\n      \t\t\t\t}\n      \t\t\t]\n      \t\t}\n      \t]\n      }\n      ```\n\n   2. 简化跳转：<span style=\"color:#3cb371\">通过name跳转时，:to=\"{name:xxx}\"一定要加:绑定，且name写在对象中</span>\n\n      ```vue\n      <!--简化前，需要写完整的路径 -->\n      <router-link to=\"/demo/test/welcome\">跳转</router-link>\n      \n      <!--简化后，直接通过名字跳转 -->\n      <router-link :to=\"{name:'hello'}\">跳转</router-link>\n      \n      <!--简化写法配合传递参数 -->\n      <router-link \n      \t:to=\"{\n      \t\tname:'hello',\n      \t\tquery:{\n      \t\t   id:666,\n                  title:'你好'\n      \t\t}\n      \t}\"\n      >跳转</router-link>\n      ```\n\n### 6.路由的params参数（需要占位）\n\n1. 配置路由，声明接收params参数\n\n   ```js\n   {\n   \tpath:'/home',\n   \tcomponent:Home,\n   \tchildren:[\n   \t\t{\n   \t\t\tpath:'news',\n   \t\t\tcomponent:News\n   \t\t},\n   \t\t{\n   \t\t\tcomponent:Message,\n   \t\t\tchildren:[\n   \t\t\t\t{\n   \t\t\t\t\tname:'xiangqing',\n   \t\t\t\t\tpath:'detail/:id/:title', //🌈使用占位符声明接收params参数\n   \t\t\t\t\tcomponent:Detail\n   \t\t\t\t}\n   \t\t\t]\n   \t\t}\n   \t]\n   }\n   ```\n\n2. 传递参数\n\n   ```vue\n   <!-- 跳转并携带params参数，to的字符串写法 -->\n   <router-link :to=\"`/home/message/detail/${m.id}/${m.title}`\">{{m.title}}</router-link>\n   \t\t\t\t\n   <!-- 跳转并携带params参数，to的对象写法 -->\n    <router-link :to=\"{\n             name:'xiangqing',\n             params:{\n               id:m.id,\n               title:m.title\n             }\n             }\">{{m.title}}</router-link>\n   ```\n   \n   > 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项 path:'/home/message/detail'，必须使用name配置 name:'xiangqing'！\n\n3. 接收参数：\n\n   ```js\n   $route.params.id\n   $route.params.title\n   ```\n\n### 7.路由的props配置\n\n​\t作用：让路由组件更方便的收到参数\n\n> <span style=\"color:#3cb371\">注意以下的三种写法，他们都是通过pros给Detail组件传递参数，所以一定要在Detail组件中用props['xx']接收</span>\n\n```js\n{\n\tname:'xiangqing',\n\tpath:'detail/:id',\n\tcomponent:Detail,\n\n\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\n\t// props:{a:900}\n\n\t//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\n    //第二种仅仅只能将params参数通过prpos传递\n\t// props:true\n\t\n\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\n\tprops($route){\n\t\treturn {\n\t\t\tid:$route.query.id,\n\t\t\ttitle:$route.query.title\n            //第三种写法也可以传递其他类型的数据，同样需要在Detail组件中props接收\n            a: 123,\n            b: '我是b'\n\t\t}\n\t}\n    //第三种中利用解构赋值简化写法，解构出$route对象中的{query}\n    props({query}){\n\t\treturn {\n\t\t\tid:query.id,\n\t\t\ttitle:query.title\n\t\t}\n\t}\n    //第三种中利用解构赋值的嵌套写法，再次简化写法，继续解构处query对象中的id和title {query:{id,title}}\n    props({query:{id,title}}){\n\t\treturn {\n\t\t\tid,//简写形式\n\t\t\ttitle\n\t\t}\n\t}\n}\n```\n\n### 8.```<router-link>```的replace属性\n\n1. 作用：控制路由跳转时操作浏览器历史记录的模式，可以通过浏览的前进和后退指针进行跳转\n2. 浏览器的历史记录有两种写入方式：分别为```push```（它就相当于入栈，点击一次router-link，就会把当前的跳转的路径压入栈中）和```replace```（它相当于入栈的时候把栈顶元素替换掉，就是把当前栈顶的路径替换为本次跳转的路径），```push```是追加历史记录，```replace```是替换当前记录。路由跳转时候默认为```push```\n3. 如何开启```replace```模式：```<router-link replace .......>News</router-link>```\n\n### 9.编程式路由导航\n\n1. 作用：不借助```<router-link> ```实现路由跳转，让路由跳转更加灵活\n\n2. 具体编码：\n\n   ```js\n   //$router的两个API\n   this.$router.push({\n   \tname:'xiangqing',\n   \t\tparams:{\n   \t\t\tid:xxx,\n   \t\t\ttitle:xxx\n   \t\t}\n   })\n   \n   this.$router.replace({\n   \tname:'xiangqing',\n   \t\tparams:{\n   \t\t\tid:xxx,\n   \t\t\ttitle:xxx\n   \t\t}\n   })\n   this.$router.forward() //前进\n   this.$router.back() //后退\n   this.$router.go() //可前进go(3)前进3步 也可后退go(-3)后退三步\n   ```\n\n### 10.缓存路由组件\n\n1. 作用：让不展示的路由组件保持挂载，不被销毁。<span style=\"color:#3cb371\">（一般想要保留数据的组件）</span>\n\n2. 具体编码：\n\n   ```vue\n   <keep-alive include=\"News\"> \n       <!-- 一定是包在<router-view>标签的外部 --> \n       <router-view></router-view>\n   </keep-alive>\n   ```\n\n> <span style=\"color:#3cb371\">1. 上述中指定include=\"xxx\" 这个名字是组件的名字，也就是vc中的name属性配置</span>\n>\n> <span style=\"color:#3cb371\">2. 也可以不指定include，这时展示在router-view中的组件都会保持挂载，不会销毁</span>\n>\n> 3. 如果需要在多个组件中挑选出其中的几个组件来使其保持挂载，那么可以用冒号绑定还有数组包裹<span style=\"color:#3cb371\"> :include=\"['组件名1','组件名2']\"</span>\n\n### 11.两个新的生命周期钩子\n\n1. 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n2. 具体名字：\n   1. ```activated```路由组件被激活时触发。\n   2. ```deactivated```路由组件失活时触发。\n3. 小结生命钩子：beforeCreate(),creared(),beforeMount(),mounted(),beforeUpdate(),updated(),beforeDestory(),destoryed(),<span style=\"color:#3cb371\">activated(),deactivated(),$nextTick()</span>\n\n### 12.路由守卫\n\n1. 作用：对路由进行权限控制\n\n2. 分类：全局守卫、独享守卫、组件内守卫\n\n3. 全局守卫:\n\n   1. 全局前置守卫和后置守卫，两个函数都有to,from参数，to{name:\"xxx\",path:\"/xxx\",meta:{}}表示的目的路径信息 <span style=\"color:#3cb371\">(这个组件的路由信息其实和目的组件中的$route信息相同)，</span>from{}表示的是起点路径信息\n   2. 前置守卫的next参数表明 是否放行该路径,只有next()放行了才会真正到达目的组件<span style=\"color:#3cb371\">（注意如果没有放行该路由，也就是没有到达目的to组件，这时全局后置路由是不会执行的！只有全局前置路由执行！）</span>\n   3. to.meta{}，meta对象中是包含的是路由的元信息，也就是coder自己定义的一些数据 \n   4. 对于全局守卫而言，他是router身上的函数，所以需要在index.js接收这个路由器router,而不是直接将路由器暴露\n\n   ```js\n   //全局前置守卫：初始化时执行、每次路由切换前执行\n   router.beforeEach((to,from,next)=>{\n   \tconsole.log('beforeEach',to,from)\n       //这里需要在路由器的routes的配置中，对需要判断是否要有权限的路由，给他的meta自定义一组key:value \n       //meta:{isAuth:true}\n   \tif(to.meta.isAuth){ //判断当前路由是否需要进行权限控制\n   \t\tif(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则\n   \t\t\tnext() //放行\n   \t\t}else{\n   \t\t\talert('暂无权限查看')\n   \t\t\t// next({name:'guanyu'})\n   \t\t}\n   \t}else{\n   \t\tnext() //放行\n   \t}\n   })\n   \n   //全局后置守卫：初始化时执行、每次路由切换后执行\n   //⭐注意如果前置路由中没有放行，那么这里的后置路由也不会执行\n   router.afterEach((to,from)=>{\n   \tconsole.log('afterEach',to,from)\n   \tif(to.meta.title){ \n   \t\tdocument.title = to.meta.title //修改网页的title\n   \t}else{\n   \t\tdocument.title = 'vue_test'\n   \t}\n   })\n   ```\n\n4. 独享守卫: 他写在该组件的路由配置中 <span style=\"color:#3cb371\">独享只有前置守卫！他可以和全局后置守卫搭配使用</span>\n\n   beforeEnter(){}他是一个函数，不像全局守卫类似定时器回调\n\n   ```js\n   beforeEnter(to,from,next){\n   \tconsole.log('beforeEnter',to,from)\n   \tif(to.meta.isAuth){ //判断当前路由是否需要进行权限控制\n   \t\tif(localStorage.getItem('school') === 'atguigu'){\n   \t\t\tnext()\n   \t\t}else{\n   \t\t\talert('暂无权限查看')\n   \t\t\t// next({name:'guanyu'})\n   \t\t}\n   \t}else{\n   \t\tnext()\n   \t}\n   }\n   ```\n\n5.  组件内守卫：\n\n   1. 组件内守卫首先是组件独有的，进入守卫和离开守卫都是定义在组件的vc中\n   2. 两个守卫都是需要通过路由规则，也就是需要经过路由器指定匹配的路径的组件\n   3. 两个守卫都有next参数，进入和离开都需要设置是否放行next()\n   4. 进入守卫的to和离开守卫的from对应的路由信息都是本次组件的路由信息\n   4. 当进入守卫中没有放行next()该路由时，那么页面是进入不到该路径里的！\n   4. 同样的，它也可以和全局后置守卫搭配使用\n   \n   ```js\n   //进入守卫：通过路由规则，进入该组件之前被调用\n   beforeRouteEnter (to, from, next) {\n   },\n   //离开守卫：通过路由规则，离开该组件时被调用，注意他和全局后置守卫的区别，离开守卫是当离开了该组件时(路由已经切换完了)，他才会调用\n   //而全局后置守卫是只要我本次路由切换完毕我就会调用\n   beforeRouteLeave (to, from, next) {\n   }\n   ```\n\n### 13.路由器的两种工作模式\n\n\n\n1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\n2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。\n3. hash模式：\n   1. 地址中永远带着#号，不美观 。\n   2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。\n   3. 兼容性较好。\n4. history模式：\n   1. 地址干净，美观 。\n   2. 兼容性和hash模式相比略差。\n   3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。\n5. 在路由器router配置中加上 mode:'history' 就可以把路由器的工作模式转换为history模式，默认是hash模式\n5. 项目的最终打包：npm run build 该命令会把vue文件都转换成为静态的前端代码html+css+js","source":"_posts/Vue笔记.md","raw":"---\ntitle: Vue笔记\ndata: '2022-6-15'\ndescription: '这里是description'\ncopyright_author: wxb\ncopyright_author_href: https://xxxxxx.com\ncopyright_url: https://xxxxxx.com\ncopyright_info: 此文章版权归wxb所有，如有转载，请註明来自原作者\n---\n\n#  笔记\n\n开启服务器：npm run serve\n\n关闭服务器:两次ctrl+c \n\n## 脚手架文件结构\n\n\t├── node_modules \n\t├── public\n\t│   ├── favicon.ico: 页签图标\n\t│   └── index.html: 主页面\n\t├── src\n\t│   ├── assets: 存放静态资源\n\t│   │   └── logo.png\n\t│   │── component: 存放组件\n\t│   │   └── HelloWorld.vue\n\t│   │── App.vue: 汇总所有组件\n\t│   │── main.js: 入口文件\n\t├── .gitignore: git版本管制忽略的配置\n\t├── babel.config.js: babel的配置文件\n\t├── package.json: 应用包配置文件 \n\t├── README.md: 应用描述文件\n\t├── package-lock.json：包版本控制文件\n\n## 关于不同版本的Vue\n\n1. vue.js与vue.runtime.xxx.js的区别：\n    1. vue.js是完整版的Vue，包含：核心功能 + 模板解析器。\n    2. vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。\n2. 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。\n\n## vue.config.js配置文件\n\n1. 使用vue inspect > output.js可以查看到Vue脚手架的默认配置。\n2. 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh\n\n## ref属性\n\n1. 被用来给元素或子组件注册引用信息（id的替代者）\n2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）\n3. 使用方式：\n    1. 打标识：```<h1 ref=\"xxx\">.....</h1>``` 或 ```<School ref=\"xxx\"></School>```\n    2. 获取：```this.$refs.xxx```\n\n## props配置项\n\n1. 功能：让组件接收外部传过来的数据，传过来的数据都会存储在vc(组件实例对象)身上，可以直接通过this.name获取\n\n2. 传递数据：```<Demo name=\"xxx\"/>```  直接在标签里面传递数据即可\n\n3. 接收数据：\n\n    1. 第一种方式（只接收）：```props:['name'] ```\n\n    2. 第二种方式（限制类型）：```props:{name:String}```\n\n    3. 第三种方式（限制类型、限制必要性、指定默认值）：\n\n    3. 且required和default不会同时限定的\n    \n        ```js\n        props:{\n        \tname:{\n        \ttype:String, //类型\n        \trequired:true, //必要性\n        \tdefault:'老王' //默认值\n        \t} \n        }\n        ```\n    \n    > 1. 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。\n    > 2. props的优先级要高于data，Vue会先读取props中的数据\n    >\n    > \n\n## mixin(混入)\n\n1. 功能：可以把多个组件共用的配置提取成一个混入对象，就是有多个子组件中具有相同的功能或者属性时，我们可以将这些共用的配置封装成一个mixin.js，并将其暴露，最后可以被各个组件导入并使用\n\n2. 使用方式：\n\n    第一步定义混合：\n\n    ```js\n    {\n        data(){....},\n        methods:{....}\n        ....\n    }\n    ```\n\n    第二步导入 \n\n    ```js\n    import {xxx,xxx} from '../mixin'\n    ```\n    \n    第三步使用混入：\n    \n    ​\t全局混入：```Vue.mixin(xxx)``` ，全局混入是在main.js中导入并使用的\n    ​\t局部混入：```mixins:['xxx']\t``` ，局部混入是在应用到这个共用配置的子组件中导入并使用的\n\n## 插件\n\n1. 功能：用于增强Vue\n\n2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n\n3. 步骤：a. 首先定义一个插件plugins.js\n\n    ​\t\t   b. 在main.js中导入import\n\n    ​\t\t   c. 在main.js中应用导入后的组件 Vue.use(plugins,参数1，参数2···)\n\n3. 定义插件：\n\n    ```js\n    对象.install = function (Vue, options) {\n        // 1. 添加全局过滤器\n        Vue.filter(....)\n    \n        // 2. 添加全局指令\n        Vue.directive(....)\n    \n        // 3. 配置全局混入(合)\n        Vue.mixin(....)\n    \n        // 4. 添加实例方法\n        Vue.prototype.$myMethod = function () {...}\n        Vue.prototype.$myProperty = xxxx\n    }\n    ```\n\n4. 使用插件：```Vue.use(插件名,使用者传入的参数)```\n\n## scoped样式\n\n1. 作用：让样式在局部生效，防止冲突。因为多个子组件中的样式类名可能会有相同的，那么这时加上了scoped后，该样式只在该子组件内生效\n2. 写法：```<style scoped>```\n\n## 总结TodoList案例(组件间的通信)\n\n1. 组件化编码流程：\n\n    ​\t(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n\n    ​\t(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n\n    ​\t\t\t1).一个组件在用：放在组件自身即可。\n\n    ​\t\t\t2). 一些组件在用：放在他们共同的父组件上（<span style=\"color:red\">状态提升</span>）例子中表现为将todoList数据放在总组件App中，供下面的子组件来使用。\n\n    ​\t(3).实现交互：从绑定事件开始。\n\n2. props适用于：\n\n    ​\t(1).父组件 ==> 子组件 通信 (爷爷组件==>子组件时，需要爷爷组件先传给父组件，再通过父组件传给子组件)\n\n    ​\t(2).子组件 ==> 父组件 通信（要求父先给子一个函数），这个函数定义在父组件中，并通过子组件标签来将这个函数传给子组件，\n\n    ​\t\t\t\t\t\t\t子组件再通过props将该函数接收，接收之后子组件的vc身上就会多出来这一个函数，直接可以利用this.func(para)调用。\n\n3. 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！\n\n4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\n\n## webStorage\n\n1. 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n\n2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n\n3. 相关API：\n\n    1. ```xxxxxStorage.setItem('key', 'value');```\n        \t\t\t\t该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。不论是sessionStorage还是localStroage都是以key：value键值对的形式来进行数据存储的\n\n    2. ```xxxxxStorage.getItem('person');```\n\n        ​\t\t该方法接受一个键名作为参数，返回键名对应的值。\n\n    3. ```xxxxxStorage.removeItem('key');```\n\n        ​\t\t该方法接受一个键名作为参数，并把该键名从存储中删除。\n\n    4. ``` xxxxxStorage.clear()```\n\n        ​\t\t该方法会清空存储中的所有数据。\n\n4. 备注：\n\n    1. SessionStorage存储的内容会随着浏览器窗口关闭而消失。\n    \n    2. LocalStorage存储的内容，需要手动清除才会消失(1.用户自主地清空浏览器地缓存 2.用户点击了实现清空clear()的操作)。\n    \n    3. ```xxxxxStorage.getItem(xxx)```如果xxx对应的value获取不到，那么getItem的返回值是null。\n    \n    4. ```JSON.parse(null)```的结果依然是null。\n    \n    5. 本地存储和会话存储都不能存储对象，不过可以通过JSON.stringify()将对象先转化为字符串存储到xxxStroage中\n    \n       获取的时候再通过 JSON.parse()将存储的字符串再转化为对象\n\n## 组件的自定义事件\n\n1. 一种组件间通信的方式，适用于：<strong style=\"color:#3cb371\">子组件 ===> 父组件</strong>\n\n2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style=\"color:#3cb371\">事件的回调函数在A中，因为这个回调函数就是用来接收子组件传过来的数据</span>）。\n\n3. 绑定自定义事件：\n\n    1. 第一种方式，在父组件中：```<Demo @atguigu=\"test\"/>```  或 ```<Demo v-on:atguigu=\"test\"/>``` 第一种直接在标签里面绑定自定义事件 注意这里的回调函数test是不需要写参数的，他需要在methods中实现的时候才加上参数实现test(data)\n\n    2. 第二种方式，在父组件中：第二种首先需要在目标的子组件上定义ref属性，再在本组件的mounted钩子中完成事件绑定\n\n        ```js\n        <Demo ref=\"demo\"/>\n        ......\n        mounted(){\n           this.$refs.xxx.$on('atguigu',this.test)\n        }\n        ```\n\n    3. 若想让自定义事件只能触发一次，可以使用```.once```修饰符，或```$once```方法。\n\n4. 触发自定义事件：```this.$emit('atguigu',要传递的数据)```\t\t要传递的数据就是在触发自定义事件的时候，以参数的形式传给对应的回调函数\n\n5. 解绑自定义事件```this.$off('atguigu')```\n\n6. 组件上也可以绑定原生DOM事件（例如@click），需要使用```.native```修饰符（@click.native）。否则，会默认他是一个自定义事件！\n\n7. 注意：通过```this.$refs.xxx.$on('atguigu',回调)```绑定自定义事件时，回调<span style=\"color:#3cb371\">要么配置在methods中</span>，<span style=\"color:#3cb371\">要么用箭头函数</span>，否则this指向会出问题！\n\n## 全局事件总线（GlobalEventBus）\n\n1. 一种组件间通信的方式，适用于<span style=\"color:#3cb371\">任意组件间通信</span>。\n\n2. 安装全局事件总线：<span style=\"color:#3cb371\">事件总线有两个要求：1. 需要让所有的组件都能够访问的到    2. 且身上具有$on,$emit等api</span>\n\n   ```js\n   new Vue({\n   \t......//beforeCreate()注意在这个创建之前钩子中进行设置\n   \tbeforeCreate() {\n   \t\tVue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm\n       //1.因为将这个总线(傀儡)$bus放在Vue的原型对象上，那么所有的vc组件实例对象都能够通过原型链向上找到这个总线$bus\n       //2.且这个$bus就是vm，因为这样他身上才会有$on,$off,$emit等api\n   \t},\n       ......\n   }) \n   ```\n\n3. 使用事件总线：\n\n   1. 接收数据组件<span style=\"color:#3cb371\">(绑定事件)</span>：A组件想接收数据，则在A组件中给$bus绑定自定义事件<span style=\"color:#3cb371\">(在mounted钩子中进行绑定，一挂载就绑定)</span>，事件的<span style=\"color:#3cb371\">回调留在A组件自身。</span>\n\n      ```js\n      methods(){\n        demo(data){......}\n      }\n      ......\n      mounted() {\n        this.$bus.$on('xxxx',this.demo)\n      }\n      ```\n\n   2. 提供数据组件<span style=\"color:#3cb371\">(触发事件)</span>：```this.$bus.$emit('xxxx',数据)``` <span style=\"color:#3cb371\">提供数据的组件，需要在本组件方法内$emit触发事件总线中绑定的事件，并通过参数来传送数据</span>\n\n4. 接收数据的组件最好在beforeDestroy钩子中，用this.$bus.$off去解绑<span style=\"color:#3cb371\">当前组件所用到的</span>事件。\n\n## 消息订阅与发布（pubsub）\n\n1.   一种组件间通信的方式，适用于<span style=\"color:#3cb371\">任意组件间通信</span>。\n\n2. 使用步骤：\n\n   1. 安装pubsub：```npm i pubsub-js```\n\n   2. 引入: ```import pubsub from 'pubsub-js'``` 用到pubsub的vue组件都需要引入\n\n   3. 接收数据<span style=\"color:#3cb371\">(订阅消息)</span>：A组件想接收数据，则在A组件中订阅消息，订阅的<span style=\"color:#3cb371\">回调留在A组件自身。</span>\n\n      ```js\n      methods(){\n          //一定要注意订阅消息时，后面的回调函数中第一个参数是固定的msgName为本次消息名，这里用_来占位，后面的data才是真正的获取的数据\n        demo(_,data){......}\n      }\n      ......\n      //消息的订阅也是在组件挂载完毕的钩子中完成的\n      mounted() {\n        this.pid = pubsub.subscribe('消息名',this.demo) //订阅消息\n\t     //注意订阅消息后，会返回一个订阅id，这个id是用来找到这个消息，并取消订阅\n      }\n\t   ```\n   \n\t4. 提供数据<span style=\"color:#3cb371\">(发布消息)</span>：```pubsub.publish('消息名',数据)```\n\t\n\t5. 最好在beforeDestroy钩子中，用```pubsub.unsubscribe(this.pid)```去<span style=\"color:#3cb371\">取消订阅。</span>\n\t\n## nextTick\n\n1. 语法：```this.$nextTick(回调函数)```\n2. 作用：在下一次 DOM 更新结束后执行其指定的回调。在对原dom做出修改后，Vue重新解析模板后生成的新dom，这时我们对这个新dom进行一些操作时，需要通过$nextTick(function{})中的回调来实现\n3. 什么时候用：当改变数据后<span style=\"color:#3cb371\">(例如修改了data中的值)</span>>，要基于更新后的新DOM进行某些操作时<span style=\"color:#3cb371\">(例如修改后，会有一个input框的生成，我们想要在input框生成后就立即获取焦点focus())</span>>，这时要在nextTick所指定的回调函数中执行(完成获取焦点的操作)。\n\n## Vue封装的过渡与动画\n\n1. 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。\n\n2. 动画可以引入第三方的动画库(animate.css) 添加指定的name，appear-active-class，leave-active-class即可完成动画效果\n\n3. 写法：\n\n   1. 准备好样式：\n\n      - 元素进入的样式：\n        1. v-enter：进入的起点\n        2. v-enter-active：进入过程中\n        3. v-enter-to：进入的终点\n      - 元素离开的样式：\n        1. v-leave：离开的起点\n        2. v-leave-active：离开过程中\n        3. v-leave-to：离开的终点\n\n   2. 使用```<transition>```包裹要过渡的元素，并配置name属性：\n\n      ```vue\n      <transition name=\"hello\">\n      \t<h1 v-show=\"isShow\">你好啊！</h1>\n      </transition>\n      ```\n\n   3. 备注：若有多个元素需要过渡，则需要使用：```<transition-group>```，且每个元素都要指定```key```值。\n\n## vue脚手架配置代理\n\n以下都通过axios来发送ajax请求：1.首先先安装axios包： npm i axios\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t   2.导入axios：import axios from 'axios'\n\n实现跨域：1.cors <span style=\"color:#3cb371\">真正解决了跨域问题</span>\n\n​\t\t\t\t 2.jsonp <span style=\"color:#3cb371\">jsonp实现跨域的本质是通过script标签的src属性在引入外部资源时，不受到同源限制的特点来实现的，但是只能解决get请求，要求前后端配合写法</span>\n\n​\t\t\t\t 3.利用代理服务器<span style=\"color:#3cb371\">（开启代理服务器的两种方式：1.通过Nginx     2.通过vue-cli脚手架）</span>\n\n文件中的两个服务器开启方式：文件中打开cmd，命令node server1/server2   \n\n关闭服务器：ctrl+c\n\n\n\n### 方法一\n\n​\t在vue.config.js中添加如下配置：\n\n```js\ndevServer:{\n  proxy:\"http://localhost:5000\"\n}\n```\n\n说明：\n\n1. 优点：配置简单，请求资源时直接发给前端（8080）即可。\n2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。\n3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （如果前端有这个资源，也就是根目录public下有的资源，那么就优先匹配前端资源，不会再去转发给目标服务器了）\n\n### 方法二\n\n​\t编写vue.config.js配置具体代理规则：\n\n```js\nmodule.exports = {\n\tdevServer: {\n      proxy: {\n      '/api1': {// 匹配所有以 '/api1'开头的请求路径\n        target: 'http://localhost:5000',// 代理目标的基础路径，也就是只写到端口号即可，不用写到具体的资源路径\n        changeOrigin: true,\n        pathRewrite: {'^/api1': ''}// pathRewrite路径重写，里面是一个key:value键值对形式\n          //   ^/api1表示把所有的以api1开头的路径，把这段路径修改为空，即没有了/api1\n      },\n      '/api2': {// 匹配所有以 '/api2'开头的请求路径\n        target: 'http://localhost:5001',// 代理目标的基础路径\n        changeOrigin: true,\n        pathRewrite: {'^/api2': ''}\n      }\n    }\n  }\n}\n/*\n   changeOrigin设置为true时(代理服务器撒谎了，说自己的host与代理服务器的目标服务器相同都为localhost:5000)，服务器收到的请求头中的host为：localhost:5000\n   changeOrigin设置为false时(代理服务器如实回答)，服务器收到的请求头中的host为：localhost:8080\n   changeOrigin默认值为true\n*/\n```\n\n说明：\n\n1. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。\n2. 缺点：配置略微繁琐，请求资源时必须加前缀。\n\n## 插槽\n\n1. 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style=\"color:#3cb371\">父组件 ===> 子组件</strong> 。\n\n2. 分类：默认插槽、具名插槽、作用域插槽\n\n3. 使用方式：\n\n   1. 默认插槽：\n\n      ```vue\n      父组件中：\n              <Category>\n                 <div>html结构1</div>\n              </Category>\n      子组件中：\n              <template>\n                  <div>\n                     <!-- 定义插槽 -->\n                     <slot>插槽默认内容...</slot>\n                  </div>\n              </template>\n      ```\n\n   2. 具名插槽：\n\n      ```vue\n      父组件中：\n              <Category>\n                  <template slot=\"center\">\n                    <div>html结构1</div>\n                  </template>\n      \t\t<!--- 当我使用了template时，指定插槽也可以用下面的方式v-slot:footer-->\n                  <template v-slot:footer>\n                     <div>html结构2</div>\n                  </template>\n              </Category>\n      子组件中：\n              <template>\n                  <div>\n                     <!-- 定义插槽 -->\n                     <slot name=\"center\">插槽默认内容...</slot>\n                     <slot name=\"footer\">插槽默认内容...</slot>\n                  </div>\n              </template>\n      ```\n\n   3. 作用域插槽：\n\n      1. 理解：<span style=\"color:#3cb371\">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在子组件Category中，但使用数据所遍历出来的结构由父组件App决定）\n\n      1. 作用域插槽必须通过template标签进行包裹\n\n      2. 具体编码：\n      \n         ```vue\n         父组件中：\n         \t\t<Category>\n                     <!--- 这里可以利用对象的解构赋值，这样就直接可以使用games获取到scopeData.games的属性值-->\n                     <!--- scope=\"{games}\"-->\n         \t\t\t<template scope=\"scopeData\">\n         \t\t\t\t<!-- 生成的是ul列表 -->\n         \t\t\t\t<ul>\n         \t\t\t\t\t<li v-for=\"g in scopeData.games\" :key=\"g\">{{g}}</li>\n         \t\t\t\t</ul>\n         \t\t\t</template>\n         \t\t</Category>\n         \n         \t\t<Category>\n         \t\t\t<template slot-scope=\"scopeData\">\n         \t\t\t\t<!-- 生成的是h4标题 -->\n         \t\t\t\t<h4 v-for=\"g in scopeData.games\" :key=\"g\">{{g}}</h4>\n         \t\t\t</template>\n         \t\t</Category>\n         子组件中：\n                 <template>\n                     <div>\n                         <slot :games=\"games\"></slot>\n                     </div>\n                 </template>\n         \t\t\n                 <script>\n                     export default {\n                         name:'Category',\n                         props:['title'],\n                         //数据在子组件自身\n                         data() {\n                             return {\n                                 games:['红色警戒','穿越火线','劲舞团','超级玛丽']\n                             }\n                         },\n                     }\n                 </script>\n         ```\n\n## Vuex\n\n### 1.概念\n\n​\t\t在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。\n\n### 2.何时使用？\n\n​\t\t多个组件需要共享数据时\n\n### 3.搭建vuex环境\n\n1. 创建文件：```src/store/index.js```\n\n   ```js\n   //引入Vue核心库\n   import Vue from 'vue'\n   //引入Vuex\n   import Vuex from 'vuex'\n   //应用Vuex插件\n   Vue.use(Vuex)\n   \n   //准备actions对象——响应组件中用户的动作，相当于服务员\n   const actions = {}\n   //准备mutations对象——修改state中的数据，相当于厨师\n   const mutations = {}\n   //准备state对象——保存具体的数据，相当于最后的菜品\n   const state = {}\n   \n   //创建并暴露store\n   export default new Vuex.Store({\n   \tactions,\n   \tmutations,\n   \tstate\n   })\n   ```\n\n2. 在```main.js```中创建vm时传入```store```配置项\n\n   ```js\n   //引入Vue\n   import Vue from 'vue'\n   //引入App\n   import App from './App.vue'\n   //引入插件\n   import vueResource from 'vue-resource'\n   //关闭Vue的生产提示\n   Vue.config.productionTip = false\n   //使用插件\n   Vue.use(vueResource)\n   //1.引入store\n   import store from './store'\n   \n   //创建vm\n   new Vue({\n   \tel: '#app',\n   \t//注意一定要在vm里面定义使用\n   \tstore,//2.定义store，这样vm以及所有的vc身上都会有$store了，都可以通过this.$store来调用\n   \trender: h => h(App),\n   \tbeforeCreate() {\n   \t\tVue.prototype.$bus = this\n   \t}\n   })\n   ```\n\n###    4.基本使用\n\n1. 初始化数据、配置```actions```、配置```mutations```，操作文件```store.js```\n\n   ```js\n   //引入Vue核心库\n   import Vue from 'vue'\n   //引入Vuex\n   import Vuex from 'vuex'\n   //引用Vuex,因为vuex本身是一个插件plguins，所以导入后需要通过Vue.use()使用\n   //因为只有先使用Vue.use(Vuex)，才能去创建new Vuex.Store()\n   Vue.use(Vuex)\n   \n   //actions是用来接收vc通过this.$dispatch('操作名add',参数)，这时里面操作名add需要在actions中配置\n   //并接收参数value\n   const actions = {\n       //🌈context为上下文，其中有commit(),dispatch(),state....等方法和属性\n       //context.commit()用来将接收到的数据进一步呈递给mutations处理\n       //context.dispatch()当业务逻辑很复杂时，在一个操作函数中并不能完成逻辑，那么就需要context.dispatch('demo',value)进一步分发给\n       //同在actions中的其他方法demo()，demo会对进一步完成逻辑操作，使最终满足业务逻辑要求\n       //context中具有state属性，所以它可以直接访问到里面的状态(数据)sum\n       //🌟当数据需要进行一些逻辑操作时，就需要放在actions执行\n       addWhenOdd(context, value) {\n           if (context.state.sum % 2) {\n               context.commit('ADD', value)//commit传给mutations时的方法名一般要全大写ADD\n           }\n       },\n       addWait(context, value) {\n           setTimeout(() => {\n               context.commit('ADD', value)\n           }, 500);\n       }\n   }\n   //mutations是用来处理数据的，数据通过actions中的对应操作的函数调用commit方法来传递给mutaiton\n   const mutations = {\n       ADD(state, value) {\n           console.log('mutations中的+被调用了');\n           state.sum += value\n       },\n       SUBTRACT(state, value) {\n           console.log('mutations中的-被调用了');\n           state.sum -= value\n       }\n   }\n   //所共享的数据都会放在state中\n   const state = {\n       sum: 0\n   }\n   \n   //创建并暴露store\n   export default new Vuex.Store({\n       //这因为key:value值相同，所以都使用简写形式\n       actions,\n       mutations,\n       state,\n   \n   })\n   ```\n   \n2. 组件中读取vuex中的数据：```$store.state.sum```\n\n3. 组件中修改vuex中的数据：```$store.dispatch('action中的方法名',数据)``` 或 ```$store.commit('mutations中的方法名',数据)```\n\n   >  <span style=\"color:#3cb371\">备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写```dispatch```，直接编写```commit```</span>\n\n![](C:\\Users\\24825\\Desktop\\Vue资料\\02_原理图\\vuex.png)\n\n### 5.getters的使用\n\n1. 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。<span style=\"color:#3cb371\">它其实可以理解为Vuex中的计算属性computed,对于state中的数据进一步加工，最后通过return返回加工后的值。</span>\n\n2. 在```store.js```中追加```getters```配置\n\n   ```js\n   ......\n   \n   const getters = {\n   \tbigSum(state){\n   \t\treturn state.sum * 10//需要return返回处理后的值\n   \t}\n   }\n   \n   //创建并暴露store\n   export default new Vuex.Store({\n   \t......\n   \tgetters\n   })\n   ```\n\n3. 组件中读取数据：```$store.getters.bigSum```\n\n### 6.四个map方法的使用\n\n> 备注：mapState, mapGetters这两个是帮我们生成一个计算属性的（配置在computed中）\n>\n> ​\t mapMutations, mapActions这两个是帮我们生成一个方法的（配置在methods中）\n\n首先需要在组件中导入mapState, mapGetters, mapMutations, mapActions\n\n```js\nimport {mapState, mapGetters, mapMutations, mapActions} from 'vuex'\n```\n\n1. <strong>mapState方法：</strong>用于帮助我们映射```state```中的数据为<span style=\"color:#3cb371\">计算属性</span>,mapXxx就是从Xxx取东西\n\n   ```js\n   computed: {\n       //借助mapState生成计算属性：sum、school、subject（对象写法）\n       //...{}可以将一个对象中的key:value分解出来，形成单独的key:value\n       //前面的sum表示的计算属性的函数名（本身对象的key可以简写不用加引号），后面的'sum'表示要从state中读取名为sum这个属性值\n        ...mapState({sum:'sum',school:'school',subject:'subject'}),\n            \n       //借助mapState生成计算属性：sum、school、subject（数组写法）\n       //写成数组时['sum']，这时'sum'有两种用途，也就是计算属性名和读取数据名要相同！！\n            //1. 将sum作为计算属性sum(){}\n            //2. 从state中读取名为'sum'的属性值\n       ...mapState(['sum','school','subject']),\n   },\n   ```\n\n2. <strong>mapGetters方法：</strong>用于帮助我们映射```getters```中的数据为计算属性\n\n   ```js\n   computed: {\n       //借助mapGetters生成计算属性：bigSum（对象写法）\n       ...mapGetters({bigSum:'bigSum'}),\n   \n       //借助mapGetters生成计算属性：bigSum（数组写法）\n       ...mapGetters(['bigSum'])\n   },\n   ```\n\n3. <strong>mapActions方法：</strong>用于帮助我们生成与```actions```对话的方法，即：包含```$store.dispatch(xxx)```的函数\n\n   ```js\n   methods:{\n       //靠mapActions生成：incrementOdd、incrementWait（对象形式）\n       ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})\n   \n       //靠mapActions生成：incrementOdd、incrementWait（数组形式）\n       ...mapActions(['jiaOdd','jiaWait'])\n   }\n   ```\n\n4. <strong>mapMutations方法：</strong>用于帮助我们生成与```mutations```对话的方法，即：包含```$store.commit(xxx)```的函数\n\n   ```js\n   methods:{\n       //靠mapActions生成：increment、decrement（对象形式）\n       //其中increment就会作为methods中的方法名,形成一个increment(vlaue){方法内部就会调用commit去联系mutations}的方法，'JIA'是会去mutations中找名为JIA的函数并执行它\n       //这样的话就不需要我们通过$store.commit('JIA'，value)来去和mutations进行对话了\n       //注意这里无法传入increment方法所需的参数，所以需要在模板中绑定事件触发该increment方法时就传入参数value\n       ...mapMutations({increment:'JIA',decrement:'JIAN'}),\n       \n       //靠mapMutations生成：JIA、JIAN（对象形式）\n       ...mapMutations(['JIA','JIAN']),\n   }\n   ```\n\n> 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\n\n### 7.模块化+命名空间\n\n1. 目的：让代码更好维护，让多种数据分类更加明确。\n\n2. 修改```store.js```\n\n   ```javascript\n   const countAbout = {\n     namespaced:true,//开启命名空间\n     state:{x:1},\n     mutations: { ... },\n     actions: { ... },\n     getters: {\n       bigSum(state){\n          return state.sum * 10\n       }\n     }\n   }\n   \n   const personAbout = {\n     namespaced:true,//开启命名空间\n     state:{ ... },\n     mutations: { ... },\n     actions: { ... }\n   }\n   \n   const store = new Vuex.Store({\n     modules: {\n       countAbout,\n       personAbout\n     }\n   })\n   ```\n\n3. 开启命名空间后，组件中读取state数据：\n\n   ```js\n   //方式一：自己直接读取\n   this.$store.state.personAbout.list\n   //方式二：借助mapState读取：\n   ...mapState('countAbout',['sum','school','subject']),\n   ```\n\n4. 开启命名空间后，组件中读取getters数据：\n\n   ```js\n   //方式一：自己直接读取\n   this.$store.getters['personAbout/firstPersonName']\n   //方式二：借助mapGetters读取：\n   ...mapGetters('countAbout',['bigSum'])\n   ```\n\n5. 开启命名空间后，组件中调用dispatch\n\n   ```js\n   //方式一：自己直接dispatch\n   this.$store.dispatch('personAbout/addPersonWang',person)\n   //方式二：借助mapActions：\n   ...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})\n   ```\n\n6. 开启命名空间后，组件中调用commit\n\n   ```js\n   //方式一：自己直接commit\n   this.$store.commit('personAbout/ADD_PERSON',person)\n   //方式二：借助mapMutations：\n   ...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),\n   ```\n\n ## 路由\n\n1. 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n2. 前端路由：key是路径，value是组件。\n\n### 1.基本使用\n\n1. 安装vue-router，命令：```npm i vue-router```\n\n2. 应用插件：```Vue.use(VueRouter)``` 在main.js中应用路由插件VueRouter，并在vm中配置路由器属性router\n\n3. 编写router路由器配置项: 路由器会独立写在一个目录为router下的index.js文件中\n\n   ```js\n   //引入VueRouter\n   import VueRouter from 'vue-router'\n   //引入Luyou 组件\n   import About from '../components/About'\n   import Home from '../components/Home'\n   \n   //创建router实例对象，去管理一组一组的路由规则\n   const router = new VueRouter({\n   \troutes:[\n   \t\t{\n   \t\t\tpath:'/about',\n   \t\t\tcomponent:About\n   \t\t},\n   \t\t{\n   \t\t\tpath:'/home',\n   \t\t\tcomponent:Home\n   \t\t}\n   \t]\n   })\n   \n   //暴露router\n   export default router\n   ```\n\n4. 实现切换（active-class可配置高亮样式）\n\n   ```vue\n   <router-link active-class=\"active\" to=\"/about\">About</router-link>\n   ```\n\n5. 指定展示位置\n\n   ```vue\n   <router-view></router-view>\n   ```\n\n### 2.几个注意点\n\n1. 路由组件通常存放在```pages```文件夹，一般组件通常存放在```components```文件夹。\n2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。\n3. 每个组件都有自己的```$route```属性，里面存储着自己的路由信息。\n4. 整个应用只有一个router，可以通过组件的```$router```属性获取到。\n\n### 3.多级路由（多级路由）\n\n1. 配置路由规则，使用children配置项：\n\n   ```js\n   routes:[\n       //一级路由\n   \t{\n   \t\tpath:'/about',\n   \t\tcomponent:About,\n   \t},\n   \t{\n   \t\tpath:'/home',\n   \t\tcomponent:Home,\n        \t//二级路由 \n   \t\tchildren:[ //通过children[]配置子级路由\n   \t\t\t{\n   \t\t\t\tpath:'news', //🌈此处一定不要写：/news\n   \t\t\t\tcomponent:News\n   \t\t\t},\n   \t\t\t{\n   \t\t\t\tpath:'message',//此处一定不要写：/message\n   \t\t\t\tcomponent:Message\n   \t\t\t}\n   \t\t]\n   \t}\n   ]\n   ```\n\n2. <span style=\"color:#3cb371\">跳转（要写完整路径）：</span>\n\n   ```vue\n   <router-link to=\"/home/news\">News</router-link>\n   ```\n\n### 4.路由的query参数\n\n因为组件的this.$route.query上包含着传过来的query参数信息\n\n1. 传递参数\n\n   ```vue\n   <!-- 跳转并携带query参数，to的字符串写法 -->\n   当使用to的字符串写法时，如果传递的参数时动态获取的，这时需要通过模板字符串``和${}进行操作，但注意to要加冒号绑定，且要有\"`${}`\"包裹\n   <router-link :to=\"`/home/message/detail?id=${js语句}&title=${js语句}`\">跳转</router-link>\n   \t\t\t\t\n   <!-- 跳转并携带query参数，to的对象写法 -->\n   <router-link \n   \t:to=\"{\n   \t\tpath:'/home/message/detail',\n   \t\tquery:{\n   \t\t   id:666,\n               title:'你好'\n   \t\t}\n   \t}\"\n   >跳转</router-link>\n   ```\n\n2. 接收参数：\n\n   ```js\n   $route.query.id\n   $route.query.title\n   ```\n\n### 5.命名路由\n\n1. 作用：可以简化路由的跳转。<span style=\"color:#3cb371\">但注意一定是当路径复杂，也就是到了三级四级之后的子路由，可以通过name来直接跳转</span>\n\n2. 如何使用\n\n   1. 给路由命名：\n\n      ```js\n      {\n      \tpath:'/demo',\n      \tcomponent:Demo,\n      \tchildren:[\n      \t\t{\n      \t\t\tpath:'test',\n      \t\t\tcomponent:Test,\n      \t\t\tchildren:[\n      \t\t\t\t{\n                            name:'hello' //给路由命名\n      \t\t\t\t\tpath:'welcome',\n      \t\t\t\t\tcomponent:Hello,\n      \t\t\t\t}\n      \t\t\t]\n      \t\t}\n      \t]\n      }\n      ```\n\n   2. 简化跳转：<span style=\"color:#3cb371\">通过name跳转时，:to=\"{name:xxx}\"一定要加:绑定，且name写在对象中</span>\n\n      ```vue\n      <!--简化前，需要写完整的路径 -->\n      <router-link to=\"/demo/test/welcome\">跳转</router-link>\n      \n      <!--简化后，直接通过名字跳转 -->\n      <router-link :to=\"{name:'hello'}\">跳转</router-link>\n      \n      <!--简化写法配合传递参数 -->\n      <router-link \n      \t:to=\"{\n      \t\tname:'hello',\n      \t\tquery:{\n      \t\t   id:666,\n                  title:'你好'\n      \t\t}\n      \t}\"\n      >跳转</router-link>\n      ```\n\n### 6.路由的params参数（需要占位）\n\n1. 配置路由，声明接收params参数\n\n   ```js\n   {\n   \tpath:'/home',\n   \tcomponent:Home,\n   \tchildren:[\n   \t\t{\n   \t\t\tpath:'news',\n   \t\t\tcomponent:News\n   \t\t},\n   \t\t{\n   \t\t\tcomponent:Message,\n   \t\t\tchildren:[\n   \t\t\t\t{\n   \t\t\t\t\tname:'xiangqing',\n   \t\t\t\t\tpath:'detail/:id/:title', //🌈使用占位符声明接收params参数\n   \t\t\t\t\tcomponent:Detail\n   \t\t\t\t}\n   \t\t\t]\n   \t\t}\n   \t]\n   }\n   ```\n\n2. 传递参数\n\n   ```vue\n   <!-- 跳转并携带params参数，to的字符串写法 -->\n   <router-link :to=\"`/home/message/detail/${m.id}/${m.title}`\">{{m.title}}</router-link>\n   \t\t\t\t\n   <!-- 跳转并携带params参数，to的对象写法 -->\n    <router-link :to=\"{\n             name:'xiangqing',\n             params:{\n               id:m.id,\n               title:m.title\n             }\n             }\">{{m.title}}</router-link>\n   ```\n   \n   > 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项 path:'/home/message/detail'，必须使用name配置 name:'xiangqing'！\n\n3. 接收参数：\n\n   ```js\n   $route.params.id\n   $route.params.title\n   ```\n\n### 7.路由的props配置\n\n​\t作用：让路由组件更方便的收到参数\n\n> <span style=\"color:#3cb371\">注意以下的三种写法，他们都是通过pros给Detail组件传递参数，所以一定要在Detail组件中用props['xx']接收</span>\n\n```js\n{\n\tname:'xiangqing',\n\tpath:'detail/:id',\n\tcomponent:Detail,\n\n\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\n\t// props:{a:900}\n\n\t//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\n    //第二种仅仅只能将params参数通过prpos传递\n\t// props:true\n\t\n\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\n\tprops($route){\n\t\treturn {\n\t\t\tid:$route.query.id,\n\t\t\ttitle:$route.query.title\n            //第三种写法也可以传递其他类型的数据，同样需要在Detail组件中props接收\n            a: 123,\n            b: '我是b'\n\t\t}\n\t}\n    //第三种中利用解构赋值简化写法，解构出$route对象中的{query}\n    props({query}){\n\t\treturn {\n\t\t\tid:query.id,\n\t\t\ttitle:query.title\n\t\t}\n\t}\n    //第三种中利用解构赋值的嵌套写法，再次简化写法，继续解构处query对象中的id和title {query:{id,title}}\n    props({query:{id,title}}){\n\t\treturn {\n\t\t\tid,//简写形式\n\t\t\ttitle\n\t\t}\n\t}\n}\n```\n\n### 8.```<router-link>```的replace属性\n\n1. 作用：控制路由跳转时操作浏览器历史记录的模式，可以通过浏览的前进和后退指针进行跳转\n2. 浏览器的历史记录有两种写入方式：分别为```push```（它就相当于入栈，点击一次router-link，就会把当前的跳转的路径压入栈中）和```replace```（它相当于入栈的时候把栈顶元素替换掉，就是把当前栈顶的路径替换为本次跳转的路径），```push```是追加历史记录，```replace```是替换当前记录。路由跳转时候默认为```push```\n3. 如何开启```replace```模式：```<router-link replace .......>News</router-link>```\n\n### 9.编程式路由导航\n\n1. 作用：不借助```<router-link> ```实现路由跳转，让路由跳转更加灵活\n\n2. 具体编码：\n\n   ```js\n   //$router的两个API\n   this.$router.push({\n   \tname:'xiangqing',\n   \t\tparams:{\n   \t\t\tid:xxx,\n   \t\t\ttitle:xxx\n   \t\t}\n   })\n   \n   this.$router.replace({\n   \tname:'xiangqing',\n   \t\tparams:{\n   \t\t\tid:xxx,\n   \t\t\ttitle:xxx\n   \t\t}\n   })\n   this.$router.forward() //前进\n   this.$router.back() //后退\n   this.$router.go() //可前进go(3)前进3步 也可后退go(-3)后退三步\n   ```\n\n### 10.缓存路由组件\n\n1. 作用：让不展示的路由组件保持挂载，不被销毁。<span style=\"color:#3cb371\">（一般想要保留数据的组件）</span>\n\n2. 具体编码：\n\n   ```vue\n   <keep-alive include=\"News\"> \n       <!-- 一定是包在<router-view>标签的外部 --> \n       <router-view></router-view>\n   </keep-alive>\n   ```\n\n> <span style=\"color:#3cb371\">1. 上述中指定include=\"xxx\" 这个名字是组件的名字，也就是vc中的name属性配置</span>\n>\n> <span style=\"color:#3cb371\">2. 也可以不指定include，这时展示在router-view中的组件都会保持挂载，不会销毁</span>\n>\n> 3. 如果需要在多个组件中挑选出其中的几个组件来使其保持挂载，那么可以用冒号绑定还有数组包裹<span style=\"color:#3cb371\"> :include=\"['组件名1','组件名2']\"</span>\n\n### 11.两个新的生命周期钩子\n\n1. 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n2. 具体名字：\n   1. ```activated```路由组件被激活时触发。\n   2. ```deactivated```路由组件失活时触发。\n3. 小结生命钩子：beforeCreate(),creared(),beforeMount(),mounted(),beforeUpdate(),updated(),beforeDestory(),destoryed(),<span style=\"color:#3cb371\">activated(),deactivated(),$nextTick()</span>\n\n### 12.路由守卫\n\n1. 作用：对路由进行权限控制\n\n2. 分类：全局守卫、独享守卫、组件内守卫\n\n3. 全局守卫:\n\n   1. 全局前置守卫和后置守卫，两个函数都有to,from参数，to{name:\"xxx\",path:\"/xxx\",meta:{}}表示的目的路径信息 <span style=\"color:#3cb371\">(这个组件的路由信息其实和目的组件中的$route信息相同)，</span>from{}表示的是起点路径信息\n   2. 前置守卫的next参数表明 是否放行该路径,只有next()放行了才会真正到达目的组件<span style=\"color:#3cb371\">（注意如果没有放行该路由，也就是没有到达目的to组件，这时全局后置路由是不会执行的！只有全局前置路由执行！）</span>\n   3. to.meta{}，meta对象中是包含的是路由的元信息，也就是coder自己定义的一些数据 \n   4. 对于全局守卫而言，他是router身上的函数，所以需要在index.js接收这个路由器router,而不是直接将路由器暴露\n\n   ```js\n   //全局前置守卫：初始化时执行、每次路由切换前执行\n   router.beforeEach((to,from,next)=>{\n   \tconsole.log('beforeEach',to,from)\n       //这里需要在路由器的routes的配置中，对需要判断是否要有权限的路由，给他的meta自定义一组key:value \n       //meta:{isAuth:true}\n   \tif(to.meta.isAuth){ //判断当前路由是否需要进行权限控制\n   \t\tif(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则\n   \t\t\tnext() //放行\n   \t\t}else{\n   \t\t\talert('暂无权限查看')\n   \t\t\t// next({name:'guanyu'})\n   \t\t}\n   \t}else{\n   \t\tnext() //放行\n   \t}\n   })\n   \n   //全局后置守卫：初始化时执行、每次路由切换后执行\n   //⭐注意如果前置路由中没有放行，那么这里的后置路由也不会执行\n   router.afterEach((to,from)=>{\n   \tconsole.log('afterEach',to,from)\n   \tif(to.meta.title){ \n   \t\tdocument.title = to.meta.title //修改网页的title\n   \t}else{\n   \t\tdocument.title = 'vue_test'\n   \t}\n   })\n   ```\n\n4. 独享守卫: 他写在该组件的路由配置中 <span style=\"color:#3cb371\">独享只有前置守卫！他可以和全局后置守卫搭配使用</span>\n\n   beforeEnter(){}他是一个函数，不像全局守卫类似定时器回调\n\n   ```js\n   beforeEnter(to,from,next){\n   \tconsole.log('beforeEnter',to,from)\n   \tif(to.meta.isAuth){ //判断当前路由是否需要进行权限控制\n   \t\tif(localStorage.getItem('school') === 'atguigu'){\n   \t\t\tnext()\n   \t\t}else{\n   \t\t\talert('暂无权限查看')\n   \t\t\t// next({name:'guanyu'})\n   \t\t}\n   \t}else{\n   \t\tnext()\n   \t}\n   }\n   ```\n\n5.  组件内守卫：\n\n   1. 组件内守卫首先是组件独有的，进入守卫和离开守卫都是定义在组件的vc中\n   2. 两个守卫都是需要通过路由规则，也就是需要经过路由器指定匹配的路径的组件\n   3. 两个守卫都有next参数，进入和离开都需要设置是否放行next()\n   4. 进入守卫的to和离开守卫的from对应的路由信息都是本次组件的路由信息\n   4. 当进入守卫中没有放行next()该路由时，那么页面是进入不到该路径里的！\n   4. 同样的，它也可以和全局后置守卫搭配使用\n   \n   ```js\n   //进入守卫：通过路由规则，进入该组件之前被调用\n   beforeRouteEnter (to, from, next) {\n   },\n   //离开守卫：通过路由规则，离开该组件时被调用，注意他和全局后置守卫的区别，离开守卫是当离开了该组件时(路由已经切换完了)，他才会调用\n   //而全局后置守卫是只要我本次路由切换完毕我就会调用\n   beforeRouteLeave (to, from, next) {\n   }\n   ```\n\n### 13.路由器的两种工作模式\n\n\n\n1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\n2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。\n3. hash模式：\n   1. 地址中永远带着#号，不美观 。\n   2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。\n   3. 兼容性较好。\n4. history模式：\n   1. 地址干净，美观 。\n   2. 兼容性和hash模式相比略差。\n   3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。\n5. 在路由器router配置中加上 mode:'history' 就可以把路由器的工作模式转换为history模式，默认是hash模式\n5. 项目的最终打包：npm run build 该命令会把vue文件都转换成为静态的前端代码html+css+js","slug":"Vue笔记","published":1,"date":"2022-06-15T05:26:32.145Z","updated":"2022-06-15T05:28:54.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4glk6rm00012wtm5sgiekv8","content":"<h1 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h1><p>开启服务器：npm run serve</p>\n<p>关闭服务器:两次ctrl+c </p>\n<h2 id=\"脚手架文件结构\"><a href=\"#脚手架文件结构\" class=\"headerlink\" title=\"脚手架文件结构\"></a>脚手架文件结构</h2><pre><code>├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n</code></pre>\n<h2 id=\"关于不同版本的Vue\"><a href=\"#关于不同版本的Vue\" class=\"headerlink\" title=\"关于不同版本的Vue\"></a>关于不同版本的Vue</h2><ol>\n<li>vue.js与vue.runtime.xxx.js的区别：<ol>\n<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>\n<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>\n</ol>\n</li>\n<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>\n</ol>\n<h2 id=\"vue-config-js配置文件\"><a href=\"#vue-config-js配置文件\" class=\"headerlink\" title=\"vue.config.js配置文件\"></a>vue.config.js配置文件</h2><ol>\n<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>\n<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href=\"https://cli.vuejs.org/zh\">https://cli.vuejs.org/zh</a></li>\n</ol>\n<h2 id=\"ref属性\"><a href=\"#ref属性\" class=\"headerlink\" title=\"ref属性\"></a>ref属性</h2><ol>\n<li>被用来给元素或子组件注册引用信息（id的替代者）</li>\n<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>\n<li>使用方式：<ol>\n<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>\n<li>获取：<code>this.$refs.xxx</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"props配置项\"><a href=\"#props配置项\" class=\"headerlink\" title=\"props配置项\"></a>props配置项</h2><ol>\n<li><p>功能：让组件接收外部传过来的数据，传过来的数据都会存储在vc(组件实例对象)身上，可以直接通过this.name获取</p>\n</li>\n<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code>  直接在标签里面传递数据即可</p>\n</li>\n<li><p>接收数据：</p>\n<ol>\n<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>\n</li>\n<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>\n</li>\n<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>\n</li>\n<li><p>且required和default不会同时限定的</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">props</span>:&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:&#123;</span><br><span class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"title class_\">String</span>, <span class=\"comment\">//类型</span></span><br><span class=\"line\">\t<span class=\"attr\">required</span>:<span class=\"literal\">true</span>, <span class=\"comment\">//必要性</span></span><br><span class=\"line\">\t<span class=\"attr\">default</span>:<span class=\"string\">&#x27;老王&#x27;</span> <span class=\"comment\">//默认值</span></span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<ol>\n<li>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</li>\n<li>props的优先级要高于data，Vue会先读取props中的数据</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"mixin-混入\"><a href=\"#mixin-混入\" class=\"headerlink\" title=\"mixin(混入)\"></a>mixin(混入)</h2><ol>\n<li><p>功能：可以把多个组件共用的配置提取成一个混入对象，就是有多个子组件中具有相同的功能或者属性时，我们可以将这些共用的配置封装成一个mixin.js，并将其暴露，最后可以被各个组件导入并使用</p>\n</li>\n<li><p>使用方式：</p>\n<p> 第一步定义混合：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>)&#123;....&#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>:&#123;....&#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 第二步导入 </p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;xxx,xxx&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../mixin&#x27;</span></span><br></pre></td></tr></table></figure>\n<p> 第三步使用混入：</p>\n<p> ​    全局混入：<code>Vue.mixin(xxx)</code> ，全局混入是在main.js中导入并使用的<br> ​    局部混入：<code>mixins:[&#39;xxx&#39;]    </code> ，局部混入是在应用到这个共用配置的子组件中导入并使用的</p>\n</li>\n</ol>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><ol>\n<li><p>功能：用于增强Vue</p>\n</li>\n<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>\n</li>\n<li><p>步骤：a. 首先定义一个插件plugins.js</p>\n<p> ​           b. 在main.js中导入import</p>\n<p> ​           c. 在main.js中应用导入后的组件 Vue.use(plugins,参数1，参数2···)</p>\n</li>\n<li><p>定义插件：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对象.<span class=\"property\">install</span> = <span class=\"keyword\">function</span> (<span class=\"params\">Vue, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 添加全局过滤器</span></span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"title function_\">filter</span>(....)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 添加全局指令</span></span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"title function_\">directive</span>(....)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 配置全局混入(合)</span></span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"title function_\">mixin</span>(....)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 添加实例方法</span></span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$myMethod</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$myProperty</span> = xxxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用插件：<code>Vue.use(插件名,使用者传入的参数)</code></p>\n</li>\n</ol>\n<h2 id=\"scoped样式\"><a href=\"#scoped样式\" class=\"headerlink\" title=\"scoped样式\"></a>scoped样式</h2><ol>\n<li>作用：让样式在局部生效，防止冲突。因为多个子组件中的样式类名可能会有相同的，那么这时加上了scoped后，该样式只在该子组件内生效</li>\n<li>写法：<code>&lt;style scoped&gt;</code></li>\n</ol>\n<h2 id=\"总结TodoList案例-组件间的通信\"><a href=\"#总结TodoList案例-组件间的通信\" class=\"headerlink\" title=\"总结TodoList案例(组件间的通信)\"></a>总结TodoList案例(组件间的通信)</h2><ol>\n<li><p>组件化编码流程：</p>\n<p> ​    (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>\n<p> ​    (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>\n<p> ​            1).一个组件在用：放在组件自身即可。</p>\n<p> ​            2). 一些组件在用：放在他们共同的父组件上（<span style=\"color:red\">状态提升</span>）例子中表现为将todoList数据放在总组件App中，供下面的子组件来使用。</p>\n<p> ​    (3).实现交互：从绑定事件开始。</p>\n</li>\n<li><p>props适用于：</p>\n<p> ​    (1).父组件 ==&gt; 子组件 通信 (爷爷组件==&gt;子组件时，需要爷爷组件先传给父组件，再通过父组件传给子组件)</p>\n<p> ​    (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数），这个函数定义在父组件中，并通过子组件标签来将这个函数传给子组件，</p>\n<p> ​                            子组件再通过props将该函数接收，接收之后子组件的vc身上就会多出来这一个函数，直接可以利用this.func(para)调用。</p>\n</li>\n<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>\n</li>\n<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>\n</li>\n</ol>\n<h2 id=\"webStorage\"><a href=\"#webStorage\" class=\"headerlink\" title=\"webStorage\"></a>webStorage</h2><ol>\n<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>\n</li>\n<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>\n</li>\n<li><p>相关API：</p>\n<ol>\n<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code></p>\n<pre><code>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。不论是sessionStorage还是localStroage都是以key：value键值对的形式来进行数据存储的\n</code></pre>\n</li>\n<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>\n<p> ​        该方法接受一个键名作为参数，返回键名对应的值。</p>\n</li>\n<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>\n<p> ​        该方法接受一个键名作为参数，并把该键名从存储中删除。</p>\n</li>\n<li><p><code> xxxxxStorage.clear()</code></p>\n<p> ​        该方法会清空存储中的所有数据。</p>\n</li>\n</ol>\n</li>\n<li><p>备注：</p>\n<ol>\n<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>\n<li>LocalStorage存储的内容，需要手动清除才会消失(1.用户自主地清空浏览器地缓存 2.用户点击了实现清空clear()的操作)。</li>\n<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>\n<li><code>JSON.parse(null)</code>的结果依然是null。</li>\n<li>本地存储和会话存储都不能存储对象，不过可以通过JSON.stringify()将对象先转化为字符串存储到xxxStroage中获取的时候再通过 JSON.parse()将存储的字符串再转化为对象</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"组件的自定义事件\"><a href=\"#组件的自定义事件\" class=\"headerlink\" title=\"组件的自定义事件\"></a>组件的自定义事件</h2><ol>\n<li><p>一种组件间通信的方式，适用于：<strong style=\"color:#3cb371\">子组件 ===&gt; 父组件</strong></p>\n</li>\n<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style=\"color:#3cb371\">事件的回调函数在A中，因为这个回调函数就是用来接收子组件传过来的数据</span>）。</p>\n</li>\n<li><p>绑定自定义事件：</p>\n<ol>\n<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code> 第一种直接在标签里面绑定自定义事件 注意这里的回调函数test是不需要写参数的，他需要在methods中实现的时候才加上参数实现test(data)</p>\n</li>\n<li><p>第二种方式，在父组件中：第二种首先需要在目标的子组件上定义ref属性，再在本组件的mounted钩子中完成事件绑定</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Demo</span> ref=<span class=\"string\">&quot;demo&quot;</span>/&gt;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"title function_\">mounted</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">   <span class=\"variable language_\">this</span>.<span class=\"property\">$refs</span>.<span class=\"property\">xxx</span>.$on(<span class=\"string\">&#x27;atguigu&#x27;</span>,<span class=\"variable language_\">this</span>.<span class=\"property\">test</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>若想让自定义事件只能触发一次，可以使用<code>.once</code>修饰符，或<code>$once</code>方法。</p>\n</li>\n</ol>\n</li>\n<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,要传递的数据)</code>        要传递的数据就是在触发自定义事件的时候，以参数的形式传给对应的回调函数</p>\n</li>\n<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>\n</li>\n<li><p>组件上也可以绑定原生DOM事件（例如@click），需要使用<code>.native</code>修饰符（@click.native）。否则，会默认他是一个自定义事件！</p>\n</li>\n<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style=\"color:#3cb371\">要么配置在methods中</span>，<span style=\"color:#3cb371\">要么用箭头函数</span>，否则this指向会出问题！</p>\n</li>\n</ol>\n<h2 id=\"全局事件总线（GlobalEventBus）\"><a href=\"#全局事件总线（GlobalEventBus）\" class=\"headerlink\" title=\"全局事件总线（GlobalEventBus）\"></a>全局事件总线（GlobalEventBus）</h2><ol>\n<li><p>一种组件间通信的方式，适用于<span style=\"color:#3cb371\">任意组件间通信</span>。</p>\n</li>\n<li><p>安装全局事件总线：<span style=\"color:#3cb371\">事件总线有两个要求：1. 需要让所有的组件都能够访问的到    2. 且身上具有$on,$emit等api</span></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">\t......<span class=\"comment\">//beforeCreate()注意在这个创建之前钩子中进行设置</span></span><br><span class=\"line\">\t<span class=\"title function_\">beforeCreate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$bus</span> = <span class=\"variable language_\">this</span> <span class=\"comment\">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class=\"line\">    <span class=\"comment\">//1.因为将这个总线(傀儡)$bus放在Vue的原型对象上，那么所有的vc组件实例对象都能够通过原型链向上找到这个总线$bus</span></span><br><span class=\"line\">    <span class=\"comment\">//2.且这个$bus就是vm，因为这样他身上才会有$on,$off,$emit等api</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;) </span><br></pre></td></tr></table></figure></li>\n<li><p>使用事件总线：</p>\n<ol>\n<li><p>接收数据组件<span style=\"color:#3cb371\">(绑定事件)</span>：A组件想接收数据，则在A组件中给$bus绑定自定义事件<span style=\"color:#3cb371\">(在mounted钩子中进行绑定，一挂载就绑定)</span>，事件的<span style=\"color:#3cb371\">回调留在A组件自身。</span></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">methods</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"title function_\">demo</span>(<span class=\"params\">data</span>)&#123;......&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">$bus</span>.$on(<span class=\"string\">&#x27;xxxx&#x27;</span>,<span class=\"variable language_\">this</span>.<span class=\"property\">demo</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>提供数据组件<span style=\"color:#3cb371\">(触发事件)</span>：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code> <span style=\"color:#3cb371\">提供数据的组件，需要在本组件方法内$emit触发事件总线中绑定的事件，并通过参数来传送数据</span></p>\n</li>\n</ol>\n</li>\n<li><p>接收数据的组件最好在beforeDestroy钩子中，用this.$bus.$off去解绑<span style=\"color:#3cb371\">当前组件所用到的</span>事件。</p>\n</li>\n</ol>\n<h2 id=\"消息订阅与发布（pubsub）\"><a href=\"#消息订阅与发布（pubsub）\" class=\"headerlink\" title=\"消息订阅与发布（pubsub）\"></a>消息订阅与发布（pubsub）</h2><ol>\n<li><p>  一种组件间通信的方式，适用于<span style=\"color:#3cb371\">任意组件间通信</span>。</p>\n</li>\n<li><p>使用步骤：</p>\n<ol>\n<li><p>安装pubsub：<code>npm i pubsub-js</code></p>\n</li>\n<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code> 用到pubsub的vue组件都需要引入</p>\n</li>\n<li><p>接收数据<span style=\"color:#3cb371\">(订阅消息)</span>：A组件想接收数据，则在A组件中订阅消息，订阅的<span style=\"color:#3cb371\">回调留在A组件自身。</span></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">methods</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//一定要注意订阅消息时，后面的回调函数中第一个参数是固定的msgName为本次消息名，这里用_来占位，后面的data才是真正的获取的数据</span></span><br><span class=\"line\">  <span class=\"title function_\">demo</span>(<span class=\"params\">_,data</span>)&#123;......&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">//消息的订阅也是在组件挂载完毕的钩子中完成的</span></span><br><span class=\"line\"><span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">pid</span> = pubsub.<span class=\"title function_\">subscribe</span>(<span class=\"string\">&#x27;消息名&#x27;</span>,<span class=\"variable language_\">this</span>.<span class=\"property\">demo</span>) <span class=\"comment\">//订阅消息</span></span><br><span class=\"line\"><span class=\"comment\">//注意订阅消息后，会返回一个订阅id，这个id是用来找到这个消息，并取消订阅</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>提供数据<span style=\"color:#3cb371\">(发布消息)</span>：<code>pubsub.publish(&#39;消息名&#39;,数据)</code></p>\n</li>\n<li><p>最好在beforeDestroy钩子中，用<code>pubsub.unsubscribe(this.pid)</code>去<span style=\"color:#3cb371\">取消订阅。</span></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"nextTick\"><a href=\"#nextTick\" class=\"headerlink\" title=\"nextTick\"></a>nextTick</h2><ol>\n<li>语法：<code>this.$nextTick(回调函数)</code></li>\n<li>作用：在下一次 DOM 更新结束后执行其指定的回调。在对原dom做出修改后，Vue重新解析模板后生成的新dom，这时我们对这个新dom进行一些操作时，需要通过$nextTick(function{})中的回调来实现</li>\n<li>什么时候用：当改变数据后<span style=\"color:#3cb371\">(例如修改了data中的值)</span>&gt;，要基于更新后的新DOM进行某些操作时<span style=\"color:#3cb371\">(例如修改后，会有一个input框的生成，我们想要在input框生成后就立即获取焦点focus())</span>&gt;，这时要在nextTick所指定的回调函数中执行(完成获取焦点的操作)。</li>\n</ol>\n<h2 id=\"Vue封装的过渡与动画\"><a href=\"#Vue封装的过渡与动画\" class=\"headerlink\" title=\"Vue封装的过渡与动画\"></a>Vue封装的过渡与动画</h2><ol>\n<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>\n</li>\n<li><p>动画可以引入第三方的动画库(animate.css) 添加指定的name，appear-active-class，leave-active-class即可完成动画效果</p>\n</li>\n<li><p>写法：</p>\n<ol>\n<li><p>准备好样式：</p>\n<ul>\n<li>元素进入的样式：<ol>\n<li>v-enter：进入的起点</li>\n<li>v-enter-active：进入过程中</li>\n<li>v-enter-to：进入的终点</li>\n</ol>\n</li>\n<li>元素离开的样式：<ol>\n<li>v-leave：离开的起点</li>\n<li>v-leave-active：离开过程中</li>\n<li>v-leave-to：离开的终点</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>使用<code>&lt;transition&gt;</code>包裹要过渡的元素，并配置name属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class=\"line\">\t&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>备注：若有多个元素需要过渡，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"vue脚手架配置代理\"><a href=\"#vue脚手架配置代理\" class=\"headerlink\" title=\"vue脚手架配置代理\"></a>vue脚手架配置代理</h2><p>以下都通过axios来发送ajax请求：1.首先先安装axios包： npm i axios</p>\n<p>​                                                       2.导入axios：import axios from ‘axios’</p>\n<p>实现跨域：1.cors <span style=\"color:#3cb371\">真正解决了跨域问题</span></p>\n<p>​                 2.jsonp <span style=\"color:#3cb371\">jsonp实现跨域的本质是通过script标签的src属性在引入外部资源时，不受到同源限制的特点来实现的，但是只能解决get请求，要求前后端配合写法</span></p>\n<p>​                 3.利用代理服务器<span style=\"color:#3cb371\">（开启代理服务器的两种方式：1.通过Nginx     2.通过vue-cli脚手架）</span></p>\n<p>文件中的两个服务器开启方式：文件中打开cmd，命令node server1/server2   </p>\n<p>关闭服务器：ctrl+c</p>\n<h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>​    在vue.config.js中添加如下配置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">devServer</span>:&#123;</span><br><span class=\"line\">  <span class=\"attr\">proxy</span>:<span class=\"string\">&quot;http://localhost:5000&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ol>\n<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>\n<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>\n<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （如果前端有这个资源，也就是根目录public下有的资源，那么就优先匹配前端资源，不会再去转发给目标服务器了）</li>\n</ol>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>​    编写vue.config.js配置具体代理规则：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">proxy</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;/api1&#x27;</span>: &#123;<span class=\"comment\">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class=\"line\">        <span class=\"attr\">target</span>: <span class=\"string\">&#x27;http://localhost:5000&#x27;</span>,<span class=\"comment\">// 代理目标的基础路径，也就是只写到端口号即可，不用写到具体的资源路径</span></span><br><span class=\"line\">        <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">pathRewrite</span>: &#123;<span class=\"string\">&#x27;^/api1&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>&#125;<span class=\"comment\">// pathRewrite路径重写，里面是一个key:value键值对形式</span></span><br><span class=\"line\">          <span class=\"comment\">//   ^/api1表示把所有的以api1开头的路径，把这段路径修改为空，即没有了/api1</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&#x27;/api2&#x27;</span>: &#123;<span class=\"comment\">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class=\"line\">        <span class=\"attr\">target</span>: <span class=\"string\">&#x27;http://localhost:5001&#x27;</span>,<span class=\"comment\">// 代理目标的基础路径</span></span><br><span class=\"line\">        <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">pathRewrite</span>: &#123;<span class=\"string\">&#x27;^/api2&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   changeOrigin设置为true时(代理服务器撒谎了，说自己的host与代理服务器的目标服务器相同都为localhost:5000)，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class=\"line\"><span class=\"comment\">   changeOrigin设置为false时(代理服务器如实回答)，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class=\"line\"><span class=\"comment\">   changeOrigin默认值为true</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ol>\n<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>\n<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>\n</ol>\n<h2 id=\"插槽\"><a href=\"#插槽\" class=\"headerlink\" title=\"插槽\"></a>插槽</h2><ol>\n<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style=\"color:#3cb371\">父组件 ===&gt; 子组件</strong> 。</p>\n</li>\n<li><p>分类：默认插槽、具名插槽、作用域插槽</p>\n</li>\n<li><p>使用方式：</p>\n<ol>\n<li><p>默认插槽：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父组件中：</span><br><span class=\"line\">        &lt;Category&gt;</span><br><span class=\"line\">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class=\"line\">        &lt;/Category&gt;</span><br><span class=\"line\">子组件中：</span><br><span class=\"line\">        &lt;template&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">               &lt;!-- 定义插槽 --&gt;</span><br><span class=\"line\">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>具名插槽：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父组件中：</span><br><span class=\"line\">        &lt;Category&gt;</span><br><span class=\"line\">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class=\"line\">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class=\"line\">            &lt;/template&gt;</span><br><span class=\"line\">\t\t&lt;!--- 当我使用了template时，指定插槽也可以用下面的方式v-slot:footer--&gt;</span><br><span class=\"line\">            &lt;template v-slot:footer&gt;</span><br><span class=\"line\">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class=\"line\">            &lt;/template&gt;</span><br><span class=\"line\">        &lt;/Category&gt;</span><br><span class=\"line\">子组件中：</span><br><span class=\"line\">        &lt;template&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">               &lt;!-- 定义插槽 --&gt;</span><br><span class=\"line\">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class=\"line\">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>作用域插槽：</p>\n<ol>\n<li><p>理解：<span style=\"color:#3cb371\">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在子组件Category中，但使用数据所遍历出来的结构由父组件App决定）</p>\n</li>\n<li><p>作用域插槽必须通过template标签进行包裹</p>\n</li>\n<li><p>具体编码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父组件中：</span><br><span class=\"line\">\t\t&lt;Category&gt;</span><br><span class=\"line\">            &lt;!--- 这里可以利用对象的解构赋值，这样就直接可以使用games获取到scopeData.games的属性值--&gt;</span><br><span class=\"line\">            &lt;!--- scope=&quot;&#123;games&#125;&quot;--&gt;</span><br><span class=\"line\">\t\t\t&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!-- 生成的是ul列表 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;ul&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/ul&gt;</span><br><span class=\"line\">\t\t\t&lt;/template&gt;</span><br><span class=\"line\">\t\t&lt;/Category&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;Category&gt;</span><br><span class=\"line\">\t\t\t&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!-- 生成的是h4标题 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class=\"line\">\t\t\t&lt;/template&gt;</span><br><span class=\"line\">\t\t&lt;/Category&gt;</span><br><span class=\"line\">子组件中：</span><br><span class=\"line\">        &lt;template&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/template&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;script&gt;</span><br><span class=\"line\">            export default &#123;</span><br><span class=\"line\">                name:&#x27;Category&#x27;,</span><br><span class=\"line\">                props:[&#x27;title&#x27;],</span><br><span class=\"line\">                //数据在子组件自身</span><br><span class=\"line\">                data() &#123;</span><br><span class=\"line\">                    return &#123;</span><br><span class=\"line\">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h3><p>​        在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>\n<h3 id=\"2-何时使用？\"><a href=\"#2-何时使用？\" class=\"headerlink\" title=\"2.何时使用？\"></a>2.何时使用？</h3><p>​        多个组件需要共享数据时</p>\n<h3 id=\"3-搭建vuex环境\"><a href=\"#3-搭建vuex环境\" class=\"headerlink\" title=\"3.搭建vuex环境\"></a>3.搭建vuex环境</h3><ol>\n<li><p>创建文件：<code>src/store/index.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入Vue核心库</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入Vuex</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//应用Vuex插件</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//准备actions对象——响应组件中用户的动作，相当于服务员</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//准备mutations对象——修改state中的数据，相当于厨师</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//准备state对象——保存具体的数据，相当于最后的菜品</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建并暴露store</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">\tactions,</span><br><span class=\"line\">\tmutations,</span><br><span class=\"line\">\tstate</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入Vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入App</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入插件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> vueResource <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-resource&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//关闭Vue的生产提示</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\">config</span>.<span class=\"property\">productionTip</span> = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">//使用插件</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(vueResource)</span><br><span class=\"line\"><span class=\"comment\">//1.引入store</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建vm</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"comment\">//注意一定要在vm里面定义使用</span></span><br><span class=\"line\">\tstore,<span class=\"comment\">//2.定义store，这样vm以及所有的vc身上都会有$store了，都可以通过this.$store来调用</span></span><br><span class=\"line\">\t<span class=\"attr\">render</span>: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> <span class=\"title function_\">h</span>(<span class=\"title class_\">App</span>),</span><br><span class=\"line\">\t<span class=\"title function_\">beforeCreate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$bus</span> = <span class=\"variable language_\">this</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"4-基本使用\"><a href=\"#4-基本使用\" class=\"headerlink\" title=\"4.基本使用\"></a>4.基本使用</h3><ol>\n<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入Vue核心库</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入Vuex</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引用Vuex,因为vuex本身是一个插件plguins，所以导入后需要通过Vue.use()使用</span></span><br><span class=\"line\"><span class=\"comment\">//因为只有先使用Vue.use(Vuex)，才能去创建new Vuex.Store()</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//actions是用来接收vc通过this.$dispatch(&#x27;操作名add&#x27;,参数)，这时里面操作名add需要在actions中配置</span></span><br><span class=\"line\"><span class=\"comment\">//并接收参数value</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//🌈context为上下文，其中有commit(),dispatch(),state....等方法和属性</span></span><br><span class=\"line\">    <span class=\"comment\">//context.commit()用来将接收到的数据进一步呈递给mutations处理</span></span><br><span class=\"line\">    <span class=\"comment\">//context.dispatch()当业务逻辑很复杂时，在一个操作函数中并不能完成逻辑，那么就需要context.dispatch(&#x27;demo&#x27;,value)进一步分发给</span></span><br><span class=\"line\">    <span class=\"comment\">//同在actions中的其他方法demo()，demo会对进一步完成逻辑操作，使最终满足业务逻辑要求</span></span><br><span class=\"line\">    <span class=\"comment\">//context中具有state属性，所以它可以直接访问到里面的状态(数据)sum</span></span><br><span class=\"line\">    <span class=\"comment\">//🌟当数据需要进行一些逻辑操作时，就需要放在actions执行</span></span><br><span class=\"line\">    <span class=\"title function_\">addWhenOdd</span>(<span class=\"params\">context, value</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context.<span class=\"property\">state</span>.<span class=\"property\">sum</span> % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            context.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;ADD&#x27;</span>, value)<span class=\"comment\">//commit传给mutations时的方法名一般要全大写ADD</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">addWait</span>(<span class=\"params\">context, value</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            context.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;ADD&#x27;</span>, value)</span><br><span class=\"line\">        &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//mutations是用来处理数据的，数据通过actions中的对应操作的函数调用commit方法来传递给mutaiton</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;</span><br><span class=\"line\">    <span class=\"title function_\">ADD</span>(<span class=\"params\">state, value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;mutations中的+被调用了&#x27;</span>);</span><br><span class=\"line\">        state.<span class=\"property\">sum</span> += value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">SUBTRACT</span>(<span class=\"params\">state, value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;mutations中的-被调用了&#x27;</span>);</span><br><span class=\"line\">        state.<span class=\"property\">sum</span> -= value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//所共享的数据都会放在state中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">    <span class=\"attr\">sum</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建并暴露store</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这因为key:value值相同，所以都使用简写形式</span></span><br><span class=\"line\">    actions,</span><br><span class=\"line\">    mutations,</span><br><span class=\"line\">    state,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>\n</li>\n<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>\n<blockquote>\n<p> <span style=\"color:#3cb371\">备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></span></p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"C:\\Users\\24825\\Desktop\\Vue资料\\02_原理图\\vuex.png\"></p>\n<h3 id=\"5-getters的使用\"><a href=\"#5-getters的使用\" class=\"headerlink\" title=\"5.getters的使用\"></a>5.getters的使用</h3><ol>\n<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。<span style=\"color:#3cb371\">它其实可以理解为Vuex中的计算属性computed,对于state中的数据进一步加工，最后通过return返回加工后的值。</span></p>\n</li>\n<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getters = &#123;</span><br><span class=\"line\">\t<span class=\"title function_\">bigSum</span>(<span class=\"params\">state</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> state.<span class=\"property\">sum</span> * <span class=\"number\">10</span><span class=\"comment\">//需要return返回处理后的值</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建并暴露store</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tgetters</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>\n</li>\n</ol>\n<h3 id=\"6-四个map方法的使用\"><a href=\"#6-四个map方法的使用\" class=\"headerlink\" title=\"6.四个map方法的使用\"></a>6.四个map方法的使用</h3><blockquote>\n<p>备注：mapState, mapGetters这两个是帮我们生成一个计算属性的（配置在computed中）</p>\n<p>​     mapMutations, mapActions这两个是帮我们生成一个方法的（配置在methods中）</p>\n</blockquote>\n<p>首先需要在组件中导入mapState, mapGetters, mapMutations, mapActions</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;mapState, mapGetters, mapMutations, mapActions&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为<span style=\"color:#3cb371\">计算属性</span>,mapXxx就是从Xxx取东西</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class=\"line\">    <span class=\"comment\">//...&#123;&#125;可以将一个对象中的key:value分解出来，形成单独的key:value</span></span><br><span class=\"line\">    <span class=\"comment\">//前面的sum表示的计算属性的函数名（本身对象的key可以简写不用加引号），后面的&#x27;sum&#x27;表示要从state中读取名为sum这个属性值</span></span><br><span class=\"line\">     ...<span class=\"title function_\">mapState</span>(&#123;<span class=\"attr\">sum</span>:<span class=\"string\">&#x27;sum&#x27;</span>,<span class=\"attr\">school</span>:<span class=\"string\">&#x27;school&#x27;</span>,<span class=\"attr\">subject</span>:<span class=\"string\">&#x27;subject&#x27;</span>&#125;),</span><br><span class=\"line\">         </span><br><span class=\"line\">    <span class=\"comment\">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class=\"line\">    <span class=\"comment\">//写成数组时[&#x27;sum&#x27;]，这时&#x27;sum&#x27;有两种用途，也就是计算属性名和读取数据名要相同！！</span></span><br><span class=\"line\">         <span class=\"comment\">//1. 将sum作为计算属性sum()&#123;&#125;</span></span><br><span class=\"line\">         <span class=\"comment\">//2. 从state中读取名为&#x27;sum&#x27;的属性值</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapState</span>([<span class=\"string\">&#x27;sum&#x27;</span>,<span class=\"string\">&#x27;school&#x27;</span>,<span class=\"string\">&#x27;subject&#x27;</span>]),</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapGetters</span>(&#123;<span class=\"attr\">bigSum</span>:<span class=\"string\">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapGetters</span>([<span class=\"string\">&#x27;bigSum&#x27;</span>])</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">methods</span>:&#123;</span><br><span class=\"line\">    <span class=\"comment\">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapActions</span>(&#123;<span class=\"attr\">incrementOdd</span>:<span class=\"string\">&#x27;jiaOdd&#x27;</span>,<span class=\"attr\">incrementWait</span>:<span class=\"string\">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapActions</span>([<span class=\"string\">&#x27;jiaOdd&#x27;</span>,<span class=\"string\">&#x27;jiaWait&#x27;</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">methods</span>:&#123;</span><br><span class=\"line\">    <span class=\"comment\">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class=\"line\">    <span class=\"comment\">//其中increment就会作为methods中的方法名,形成一个increment(vlaue)&#123;方法内部就会调用commit去联系mutations&#125;的方法，&#x27;JIA&#x27;是会去mutations中找名为JIA的函数并执行它</span></span><br><span class=\"line\">    <span class=\"comment\">//这样的话就不需要我们通过$store.commit(&#x27;JIA&#x27;，value)来去和mutations进行对话了</span></span><br><span class=\"line\">    <span class=\"comment\">//注意这里无法传入increment方法所需的参数，所以需要在模板中绑定事件触发该increment方法时就传入参数value</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapMutations</span>(&#123;<span class=\"attr\">increment</span>:<span class=\"string\">&#x27;JIA&#x27;</span>,<span class=\"attr\">decrement</span>:<span class=\"string\">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapMutations</span>([<span class=\"string\">&#x27;JIA&#x27;</span>,<span class=\"string\">&#x27;JIAN&#x27;</span>]),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>\n</blockquote>\n<h3 id=\"7-模块化-命名空间\"><a href=\"#7-模块化-命名空间\" class=\"headerlink\" title=\"7.模块化+命名空间\"></a>7.模块化+命名空间</h3><ol>\n<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>\n</li>\n<li><p>修改<code>store.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> countAbout = &#123;</span><br><span class=\"line\">  <span class=\"attr\">namespaced</span>:<span class=\"literal\">true</span>,<span class=\"comment\">//开启命名空间</span></span><br><span class=\"line\">  <span class=\"attr\">state</span>:&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">bigSum</span>(<span class=\"params\">state</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> state.<span class=\"property\">sum</span> * <span class=\"number\">10</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> personAbout = &#123;</span><br><span class=\"line\">  <span class=\"attr\">namespaced</span>:<span class=\"literal\">true</span>,<span class=\"comment\">//开启命名空间</span></span><br><span class=\"line\">  <span class=\"attr\">state</span>:&#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">modules</span>: &#123;</span><br><span class=\"line\">    countAbout,</span><br><span class=\"line\">    personAbout</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>开启命名空间后，组件中读取state数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一：自己直接读取</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">personAbout</span>.<span class=\"property\">list</span></span><br><span class=\"line\"><span class=\"comment\">//方式二：借助mapState读取：</span></span><br><span class=\"line\">...<span class=\"title function_\">mapState</span>(<span class=\"string\">&#x27;countAbout&#x27;</span>,[<span class=\"string\">&#x27;sum&#x27;</span>,<span class=\"string\">&#x27;school&#x27;</span>,<span class=\"string\">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure></li>\n<li><p>开启命名空间后，组件中读取getters数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一：自己直接读取</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">getters</span>[<span class=\"string\">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">//方式二：借助mapGetters读取：</span></span><br><span class=\"line\">...<span class=\"title function_\">mapGetters</span>(<span class=\"string\">&#x27;countAbout&#x27;</span>,[<span class=\"string\">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure></li>\n<li><p>开启命名空间后，组件中调用dispatch</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一：自己直接dispatch</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">dispatch</span>(<span class=\"string\">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class=\"line\"><span class=\"comment\">//方式二：借助mapActions：</span></span><br><span class=\"line\">...<span class=\"title function_\">mapActions</span>(<span class=\"string\">&#x27;countAbout&#x27;</span>,&#123;<span class=\"attr\">incrementOdd</span>:<span class=\"string\">&#x27;jiaOdd&#x27;</span>,<span class=\"attr\">incrementWait</span>:<span class=\"string\">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>开启命名空间后，组件中调用commit</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一：自己直接commit</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class=\"line\"><span class=\"comment\">//方式二：借助mapMutations：</span></span><br><span class=\"line\">...<span class=\"title function_\">mapMutations</span>(<span class=\"string\">&#x27;countAbout&#x27;</span>,&#123;<span class=\"attr\">increment</span>:<span class=\"string\">&#x27;JIA&#x27;</span>,<span class=\"attr\">decrement</span>:<span class=\"string\">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><ol>\n<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>\n<li>前端路由：key是路径，value是组件。</li>\n</ol>\n<h3 id=\"1-基本使用\"><a href=\"#1-基本使用\" class=\"headerlink\" title=\"1.基本使用\"></a>1.基本使用</h3><ol>\n<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>\n</li>\n<li><p>应用插件：<code>Vue.use(VueRouter)</code> 在main.js中应用路由插件VueRouter，并在vm中配置路由器属性router</p>\n</li>\n<li><p>编写router路由器配置项: 路由器会独立写在一个目录为router下的index.js文件中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入VueRouter</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">VueRouter</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-router&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入Luyou 组件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">About</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../components/About&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../components/Home&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">VueRouter</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">routes</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/about&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">About</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/home&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Home</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//暴露router</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> router</span><br></pre></td></tr></table></figure></li>\n<li><p>实现切换（active-class可配置高亮样式）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>指定展示位置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"2-几个注意点\"><a href=\"#2-几个注意点\" class=\"headerlink\" title=\"2.几个注意点\"></a>2.几个注意点</h3><ol>\n<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>\n<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>\n<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>\n<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>\n</ol>\n<h3 id=\"3-多级路由（多级路由）\"><a href=\"#3-多级路由（多级路由）\" class=\"headerlink\" title=\"3.多级路由（多级路由）\"></a>3.多级路由（多级路由）</h3><ol>\n<li><p>配置路由规则，使用children配置项：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">routes</span>:[</span><br><span class=\"line\">    <span class=\"comment\">//一级路由</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/about&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">About</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/home&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Home</span>,</span><br><span class=\"line\">     \t<span class=\"comment\">//二级路由 </span></span><br><span class=\"line\">\t\t<span class=\"attr\">children</span>:[ <span class=\"comment\">//通过children[]配置子级路由</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;news&#x27;</span>, <span class=\"comment\">//🌈此处一定不要写：/news</span></span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">News</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"comment\">//此处一定不要写：/message</span></span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Message</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></li>\n<li><p><span style=\"color:#3cb371\">跳转（要写完整路径）：</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"4-路由的query参数\"><a href=\"#4-路由的query参数\" class=\"headerlink\" title=\"4.路由的query参数\"></a>4.路由的query参数</h3><p>因为组件的this.$route.query上包含着传过来的query参数信息</p>\n<ol>\n<li><p>传递参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class=\"line\">当使用to的字符串写法时，如果传递的参数时动态获取的，这时需要通过模板字符串``和$&#123;&#125;进行操作，但注意to要加冒号绑定，且要有&quot;`$&#123;&#125;`&quot;包裹</span><br><span class=\"line\">&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;js语句&#125;&amp;title=$&#123;js语句&#125;`&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class=\"line\">&lt;router-link </span><br><span class=\"line\">\t:to=&quot;&#123;</span><br><span class=\"line\">\t\tpath:&#x27;/home/message/detail&#x27;,</span><br><span class=\"line\">\t\tquery:&#123;</span><br><span class=\"line\">\t\t   id:666,</span><br><span class=\"line\">            title:&#x27;你好&#x27;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;&quot;</span><br><span class=\"line\">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>接收参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$route.<span class=\"property\">query</span>.<span class=\"property\">id</span></span><br><span class=\"line\">$route.<span class=\"property\">query</span>.<span class=\"property\">title</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"5-命名路由\"><a href=\"#5-命名路由\" class=\"headerlink\" title=\"5.命名路由\"></a>5.命名路由</h3><ol>\n<li><p>作用：可以简化路由的跳转。<span style=\"color:#3cb371\">但注意一定是当路径复杂，也就是到了三级四级之后的子路由，可以通过name来直接跳转</span></p>\n</li>\n<li><p>如何使用</p>\n<ol>\n<li><p>给路由命名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/demo&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">component</span>:<span class=\"title class_\">Demo</span>,</span><br><span class=\"line\">\t<span class=\"attr\">children</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;test&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Test</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">children</span>:[</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">                      <span class=\"attr\">name</span>:<span class=\"string\">&#x27;hello&#x27;</span> <span class=\"comment\">//给路由命名</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;welcome&#x27;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Hello</span>,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>简化跳转：<span style=\"color:#3cb371\">通过name跳转时，:to=”{name:xxx}”一定要加:绑定，且name写在对象中</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class=\"line\">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class=\"line\">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class=\"line\">&lt;router-link </span><br><span class=\"line\">\t:to=&quot;&#123;</span><br><span class=\"line\">\t\tname:&#x27;hello&#x27;,</span><br><span class=\"line\">\t\tquery:&#123;</span><br><span class=\"line\">\t\t   id:666,</span><br><span class=\"line\">            title:&#x27;你好&#x27;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;&quot;</span><br><span class=\"line\">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-路由的params参数（需要占位）\"><a href=\"#6-路由的params参数（需要占位）\" class=\"headerlink\" title=\"6.路由的params参数（需要占位）\"></a>6.路由的params参数（需要占位）</h3><ol>\n<li><p>配置路由，声明接收params参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/home&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">component</span>:<span class=\"title class_\">Home</span>,</span><br><span class=\"line\">\t<span class=\"attr\">children</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;news&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">News</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Message</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">children</span>:[</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">name</span>:<span class=\"string\">&#x27;xiangqing&#x27;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;detail/:id/:title&#x27;</span>, <span class=\"comment\">//🌈使用占位符声明接收params参数</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Detail</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>传递参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class=\"line\">&lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class=\"line\"> &lt;router-link :to=&quot;&#123;</span><br><span class=\"line\">          name:&#x27;xiangqing&#x27;,</span><br><span class=\"line\">          params:&#123;</span><br><span class=\"line\">            id:m.id,</span><br><span class=\"line\">            title:m.title</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项 path:’/home/message/detail’，必须使用name配置 name:’xiangqing’！</p>\n</blockquote>\n</li>\n<li><p>接收参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$route.<span class=\"property\">params</span>.<span class=\"property\">id</span></span><br><span class=\"line\">$route.<span class=\"property\">params</span>.<span class=\"property\">title</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"7-路由的props配置\"><a href=\"#7-路由的props配置\" class=\"headerlink\" title=\"7.路由的props配置\"></a>7.路由的props配置</h3><p>​    作用：让路由组件更方便的收到参数</p>\n<blockquote>\n<p><span style=\"color:#3cb371\">注意以下的三种写法，他们都是通过pros给Detail组件传递参数，所以一定要在Detail组件中用props[‘xx’]接收</span></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&#x27;xiangqing&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;detail/:id&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">component</span>:<span class=\"title class_\">Detail</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class=\"line\">\t<span class=\"comment\">// props:&#123;a:900&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class=\"line\">    <span class=\"comment\">//第二种仅仅只能将params参数通过prpos传递</span></span><br><span class=\"line\">\t<span class=\"comment\">// props:true</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class=\"line\">\t<span class=\"title function_\">props</span>(<span class=\"params\">$route</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">id</span>:$route.<span class=\"property\">query</span>.<span class=\"property\">id</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">title</span>:$route.<span class=\"property\">query</span>.<span class=\"property\">title</span></span><br><span class=\"line\">            <span class=\"comment\">//第三种写法也可以传递其他类型的数据，同样需要在Detail组件中props接收</span></span><br><span class=\"line\">            <span class=\"attr\">a</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\">            <span class=\"attr\">b</span>: <span class=\"string\">&#x27;我是b&#x27;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//第三种中利用解构赋值简化写法，解构出$route对象中的&#123;query&#125;</span></span><br><span class=\"line\">    <span class=\"title function_\">props</span>(<span class=\"params\">&#123;query&#125;</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">id</span>:query.<span class=\"property\">id</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">title</span>:query.<span class=\"property\">title</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//第三种中利用解构赋值的嵌套写法，再次简化写法，继续解构处query对象中的id和title &#123;query:&#123;id,title&#125;&#125;</span></span><br><span class=\"line\">    <span class=\"title function_\">props</span>(<span class=\"params\">&#123;query:&#123;id,title&#125;&#125;</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\tid,<span class=\"comment\">//简写形式</span></span><br><span class=\"line\">\t\t\ttitle</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-lt-router-link-gt-的replace属性\"><a href=\"#8-lt-router-link-gt-的replace属性\" class=\"headerlink\" title=\"8.&lt;router-link&gt;的replace属性\"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>\n<li>作用：控制路由跳转时操作浏览器历史记录的模式，可以通过浏览的前进和后退指针进行跳转</li>\n<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>（它就相当于入栈，点击一次router-link，就会把当前的跳转的路径压入栈中）和<code>replace</code>（它相当于入栈的时候把栈顶元素替换掉，就是把当前栈顶的路径替换为本次跳转的路径），<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>\n<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>\n</ol>\n<h3 id=\"9-编程式路由导航\"><a href=\"#9-编程式路由导航\" class=\"headerlink\" title=\"9.编程式路由导航\"></a>9.编程式路由导航</h3><ol>\n<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>\n</li>\n<li><p>具体编码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//$router的两个API</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&#x27;xiangqing&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">params</span>:&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">id</span>:xxx,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">title</span>:xxx</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">replace</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&#x27;xiangqing&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">params</span>:&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">id</span>:xxx,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">title</span>:xxx</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">forward</span>() <span class=\"comment\">//前进</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">back</span>() <span class=\"comment\">//后退</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">go</span>() <span class=\"comment\">//可前进go(3)前进3步 也可后退go(-3)后退三步</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"10-缓存路由组件\"><a href=\"#10-缓存路由组件\" class=\"headerlink\" title=\"10.缓存路由组件\"></a>10.缓存路由组件</h3><ol>\n<li><p>作用：让不展示的路由组件保持挂载，不被销毁。<span style=\"color:#3cb371\">（一般想要保留数据的组件）</span></p>\n</li>\n<li><p>具体编码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class=\"line\">    &lt;!-- 一定是包在&lt;router-view&gt;标签的外部 --&gt; </span><br><span class=\"line\">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p><span style=\"color:#3cb371\">1. 上述中指定include=”xxx” 这个名字是组件的名字，也就是vc中的name属性配置</span></p>\n<p><span style=\"color:#3cb371\">2. 也可以不指定include，这时展示在router-view中的组件都会保持挂载，不会销毁</span></p>\n<ol start=\"3\">\n<li>如果需要在多个组件中挑选出其中的几个组件来使其保持挂载，那么可以用冒号绑定还有数组包裹<span style=\"color:#3cb371\"> :include=”[‘组件名1’,’组件名2’]”</span></li>\n</ol>\n</blockquote>\n<h3 id=\"11-两个新的生命周期钩子\"><a href=\"#11-两个新的生命周期钩子\" class=\"headerlink\" title=\"11.两个新的生命周期钩子\"></a>11.两个新的生命周期钩子</h3><ol>\n<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>\n<li>具体名字：<ol>\n<li><code>activated</code>路由组件被激活时触发。</li>\n<li><code>deactivated</code>路由组件失活时触发。</li>\n</ol>\n</li>\n<li>小结生命钩子：beforeCreate(),creared(),beforeMount(),mounted(),beforeUpdate(),updated(),beforeDestory(),destoryed(),<span style=\"color:#3cb371\">activated(),deactivated(),$nextTick()</span></li>\n</ol>\n<h3 id=\"12-路由守卫\"><a href=\"#12-路由守卫\" class=\"headerlink\" title=\"12.路由守卫\"></a>12.路由守卫</h3><ol>\n<li><p>作用：对路由进行权限控制</p>\n</li>\n<li><p>分类：全局守卫、独享守卫、组件内守卫</p>\n</li>\n<li><p>全局守卫:</p>\n<ol>\n<li>全局前置守卫和后置守卫，两个函数都有to,from参数，to{name:”xxx”,path:”/xxx”,meta:{}}表示的目的路径信息 <span style=\"color:#3cb371\">(这个组件的路由信息其实和目的组件中的$route信息相同)，</span>from{}表示的是起点路径信息</li>\n<li>前置守卫的next参数表明 是否放行该路径,只有next()放行了才会真正到达目的组件<span style=\"color:#3cb371\">（注意如果没有放行该路由，也就是没有到达目的to组件，这时全局后置路由是不会执行的！只有全局前置路由执行！）</span></li>\n<li>to.meta{}，meta对象中是包含的是路由的元信息，也就是coder自己定义的一些数据 </li>\n<li>对于全局守卫而言，他是router身上的函数，所以需要在index.js接收这个路由器router,而不是直接将路由器暴露</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class=\"line\">router.<span class=\"title function_\">beforeEach</span>(<span class=\"function\">(<span class=\"params\">to,<span class=\"keyword\">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;beforeEach&#x27;</span>,to,<span class=\"keyword\">from</span>)</span><br><span class=\"line\">    <span class=\"comment\">//这里需要在路由器的routes的配置中，对需要判断是否要有权限的路由，给他的meta自定义一组key:value </span></span><br><span class=\"line\">    <span class=\"comment\">//meta:&#123;isAuth:true&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(to.<span class=\"property\">meta</span>.<span class=\"property\">isAuth</span>)&#123; <span class=\"comment\">//判断当前路由是否需要进行权限控制</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;school&#x27;</span>) === <span class=\"string\">&#x27;atguigu&#x27;</span>)&#123; <span class=\"comment\">//权限控制的具体规则</span></span><br><span class=\"line\">\t\t\t<span class=\"title function_\">next</span>() <span class=\"comment\">//放行</span></span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;暂无权限查看&#x27;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"title function_\">next</span>() <span class=\"comment\">//放行</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class=\"line\"><span class=\"comment\">//⭐注意如果前置路由中没有放行，那么这里的后置路由也不会执行</span></span><br><span class=\"line\">router.<span class=\"title function_\">afterEach</span>(<span class=\"function\">(<span class=\"params\">to,<span class=\"keyword\">from</span></span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;afterEach&#x27;</span>,to,<span class=\"keyword\">from</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(to.<span class=\"property\">meta</span>.<span class=\"property\">title</span>)&#123; </span><br><span class=\"line\">\t\t<span class=\"variable language_\">document</span>.<span class=\"property\">title</span> = to.<span class=\"property\">meta</span>.<span class=\"property\">title</span> <span class=\"comment\">//修改网页的title</span></span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">document</span>.<span class=\"property\">title</span> = <span class=\"string\">&#x27;vue_test&#x27;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>独享守卫: 他写在该组件的路由配置中 <span style=\"color:#3cb371\">独享只有前置守卫！他可以和全局后置守卫搭配使用</span></p>\n<p>beforeEnter(){}他是一个函数，不像全局守卫类似定时器回调</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">beforeEnter</span>(<span class=\"params\">to,<span class=\"keyword\">from</span>,next</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;beforeEnter&#x27;</span>,to,<span class=\"keyword\">from</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(to.<span class=\"property\">meta</span>.<span class=\"property\">isAuth</span>)&#123; <span class=\"comment\">//判断当前路由是否需要进行权限控制</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;school&#x27;</span>) === <span class=\"string\">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">next</span>()</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;暂无权限查看&#x27;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"title function_\">next</span>()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p> 组件内守卫：</p>\n</li>\n<li><p>组件内守卫首先是组件独有的，进入守卫和离开守卫都是定义在组件的vc中</p>\n</li>\n<li><p>两个守卫都是需要通过路由规则，也就是需要经过路由器指定匹配的路径的组件</p>\n</li>\n<li><p>两个守卫都有next参数，进入和离开都需要设置是否放行next()</p>\n</li>\n<li><p>进入守卫的to和离开守卫的from对应的路由信息都是本次组件的路由信息</p>\n</li>\n<li><p>当进入守卫中没有放行next()该路由时，那么页面是进入不到该路径里的！</p>\n</li>\n<li><p>同样的，它也可以和全局后置守卫搭配使用</p>\n</li>\n</ol>\n   <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//进入守卫：通过路由规则，进入该组件之前被调用</span></span><br><span class=\"line\">beforeRouteEnter (to, <span class=\"keyword\">from</span>, next) &#123;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"comment\">//离开守卫：通过路由规则，离开该组件时被调用，注意他和全局后置守卫的区别，离开守卫是当离开了该组件时(路由已经切换完了)，他才会调用</span></span><br><span class=\"line\"><span class=\"comment\">//而全局后置守卫是只要我本次路由切换完毕我就会调用</span></span><br><span class=\"line\">beforeRouteLeave (to, <span class=\"keyword\">from</span>, next) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-路由器的两种工作模式\"><a href=\"#13-路由器的两种工作模式\" class=\"headerlink\" title=\"13.路由器的两种工作模式\"></a>13.路由器的两种工作模式</h3><ol>\n<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>\n<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>\n<li>hash模式：<ol>\n<li>地址中永远带着#号，不美观 。</li>\n<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>\n<li>兼容性较好。</li>\n</ol>\n</li>\n<li>history模式：<ol>\n<li>地址干净，美观 。</li>\n<li>兼容性和hash模式相比略差。</li>\n<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>\n</ol>\n</li>\n<li>在路由器router配置中加上 mode:’history’ 就可以把路由器的工作模式转换为history模式，默认是hash模式</li>\n<li>项目的最终打包：npm run build 该命令会把vue文件都转换成为静态的前端代码html+css+js</li>\n</ol>\n","site":{"data":{"link":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}},"cover":"./images/touxiang2.jpg","excerpt":"","more":"<h1 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h1><p>开启服务器：npm run serve</p>\n<p>关闭服务器:两次ctrl+c </p>\n<h2 id=\"脚手架文件结构\"><a href=\"#脚手架文件结构\" class=\"headerlink\" title=\"脚手架文件结构\"></a>脚手架文件结构</h2><pre><code>├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n</code></pre>\n<h2 id=\"关于不同版本的Vue\"><a href=\"#关于不同版本的Vue\" class=\"headerlink\" title=\"关于不同版本的Vue\"></a>关于不同版本的Vue</h2><ol>\n<li>vue.js与vue.runtime.xxx.js的区别：<ol>\n<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>\n<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>\n</ol>\n</li>\n<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>\n</ol>\n<h2 id=\"vue-config-js配置文件\"><a href=\"#vue-config-js配置文件\" class=\"headerlink\" title=\"vue.config.js配置文件\"></a>vue.config.js配置文件</h2><ol>\n<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>\n<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href=\"https://cli.vuejs.org/zh\">https://cli.vuejs.org/zh</a></li>\n</ol>\n<h2 id=\"ref属性\"><a href=\"#ref属性\" class=\"headerlink\" title=\"ref属性\"></a>ref属性</h2><ol>\n<li>被用来给元素或子组件注册引用信息（id的替代者）</li>\n<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>\n<li>使用方式：<ol>\n<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>\n<li>获取：<code>this.$refs.xxx</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"props配置项\"><a href=\"#props配置项\" class=\"headerlink\" title=\"props配置项\"></a>props配置项</h2><ol>\n<li><p>功能：让组件接收外部传过来的数据，传过来的数据都会存储在vc(组件实例对象)身上，可以直接通过this.name获取</p>\n</li>\n<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code>  直接在标签里面传递数据即可</p>\n</li>\n<li><p>接收数据：</p>\n<ol>\n<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>\n</li>\n<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>\n</li>\n<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>\n</li>\n<li><p>且required和default不会同时限定的</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">props</span>:&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:&#123;</span><br><span class=\"line\">\t<span class=\"attr\">type</span>:<span class=\"title class_\">String</span>, <span class=\"comment\">//类型</span></span><br><span class=\"line\">\t<span class=\"attr\">required</span>:<span class=\"literal\">true</span>, <span class=\"comment\">//必要性</span></span><br><span class=\"line\">\t<span class=\"attr\">default</span>:<span class=\"string\">&#x27;老王&#x27;</span> <span class=\"comment\">//默认值</span></span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<ol>\n<li>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</li>\n<li>props的优先级要高于data，Vue会先读取props中的数据</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"mixin-混入\"><a href=\"#mixin-混入\" class=\"headerlink\" title=\"mixin(混入)\"></a>mixin(混入)</h2><ol>\n<li><p>功能：可以把多个组件共用的配置提取成一个混入对象，就是有多个子组件中具有相同的功能或者属性时，我们可以将这些共用的配置封装成一个mixin.js，并将其暴露，最后可以被各个组件导入并使用</p>\n</li>\n<li><p>使用方式：</p>\n<p> 第一步定义混合：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>)&#123;....&#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>:&#123;....&#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 第二步导入 </p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;xxx,xxx&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../mixin&#x27;</span></span><br></pre></td></tr></table></figure>\n<p> 第三步使用混入：</p>\n<p> ​    全局混入：<code>Vue.mixin(xxx)</code> ，全局混入是在main.js中导入并使用的<br> ​    局部混入：<code>mixins:[&#39;xxx&#39;]    </code> ，局部混入是在应用到这个共用配置的子组件中导入并使用的</p>\n</li>\n</ol>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><ol>\n<li><p>功能：用于增强Vue</p>\n</li>\n<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>\n</li>\n<li><p>步骤：a. 首先定义一个插件plugins.js</p>\n<p> ​           b. 在main.js中导入import</p>\n<p> ​           c. 在main.js中应用导入后的组件 Vue.use(plugins,参数1，参数2···)</p>\n</li>\n<li><p>定义插件：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对象.<span class=\"property\">install</span> = <span class=\"keyword\">function</span> (<span class=\"params\">Vue, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 添加全局过滤器</span></span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"title function_\">filter</span>(....)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 添加全局指令</span></span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"title function_\">directive</span>(....)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 配置全局混入(合)</span></span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"title function_\">mixin</span>(....)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 添加实例方法</span></span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$myMethod</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$myProperty</span> = xxxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用插件：<code>Vue.use(插件名,使用者传入的参数)</code></p>\n</li>\n</ol>\n<h2 id=\"scoped样式\"><a href=\"#scoped样式\" class=\"headerlink\" title=\"scoped样式\"></a>scoped样式</h2><ol>\n<li>作用：让样式在局部生效，防止冲突。因为多个子组件中的样式类名可能会有相同的，那么这时加上了scoped后，该样式只在该子组件内生效</li>\n<li>写法：<code>&lt;style scoped&gt;</code></li>\n</ol>\n<h2 id=\"总结TodoList案例-组件间的通信\"><a href=\"#总结TodoList案例-组件间的通信\" class=\"headerlink\" title=\"总结TodoList案例(组件间的通信)\"></a>总结TodoList案例(组件间的通信)</h2><ol>\n<li><p>组件化编码流程：</p>\n<p> ​    (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>\n<p> ​    (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>\n<p> ​            1).一个组件在用：放在组件自身即可。</p>\n<p> ​            2). 一些组件在用：放在他们共同的父组件上（<span style=\"color:red\">状态提升</span>）例子中表现为将todoList数据放在总组件App中，供下面的子组件来使用。</p>\n<p> ​    (3).实现交互：从绑定事件开始。</p>\n</li>\n<li><p>props适用于：</p>\n<p> ​    (1).父组件 ==&gt; 子组件 通信 (爷爷组件==&gt;子组件时，需要爷爷组件先传给父组件，再通过父组件传给子组件)</p>\n<p> ​    (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数），这个函数定义在父组件中，并通过子组件标签来将这个函数传给子组件，</p>\n<p> ​                            子组件再通过props将该函数接收，接收之后子组件的vc身上就会多出来这一个函数，直接可以利用this.func(para)调用。</p>\n</li>\n<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>\n</li>\n<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>\n</li>\n</ol>\n<h2 id=\"webStorage\"><a href=\"#webStorage\" class=\"headerlink\" title=\"webStorage\"></a>webStorage</h2><ol>\n<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>\n</li>\n<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>\n</li>\n<li><p>相关API：</p>\n<ol>\n<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code></p>\n<pre><code>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。不论是sessionStorage还是localStroage都是以key：value键值对的形式来进行数据存储的\n</code></pre>\n</li>\n<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>\n<p> ​        该方法接受一个键名作为参数，返回键名对应的值。</p>\n</li>\n<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>\n<p> ​        该方法接受一个键名作为参数，并把该键名从存储中删除。</p>\n</li>\n<li><p><code> xxxxxStorage.clear()</code></p>\n<p> ​        该方法会清空存储中的所有数据。</p>\n</li>\n</ol>\n</li>\n<li><p>备注：</p>\n<ol>\n<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>\n<li>LocalStorage存储的内容，需要手动清除才会消失(1.用户自主地清空浏览器地缓存 2.用户点击了实现清空clear()的操作)。</li>\n<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>\n<li><code>JSON.parse(null)</code>的结果依然是null。</li>\n<li>本地存储和会话存储都不能存储对象，不过可以通过JSON.stringify()将对象先转化为字符串存储到xxxStroage中获取的时候再通过 JSON.parse()将存储的字符串再转化为对象</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"组件的自定义事件\"><a href=\"#组件的自定义事件\" class=\"headerlink\" title=\"组件的自定义事件\"></a>组件的自定义事件</h2><ol>\n<li><p>一种组件间通信的方式，适用于：<strong style=\"color:#3cb371\">子组件 ===&gt; 父组件</strong></p>\n</li>\n<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style=\"color:#3cb371\">事件的回调函数在A中，因为这个回调函数就是用来接收子组件传过来的数据</span>）。</p>\n</li>\n<li><p>绑定自定义事件：</p>\n<ol>\n<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code> 第一种直接在标签里面绑定自定义事件 注意这里的回调函数test是不需要写参数的，他需要在methods中实现的时候才加上参数实现test(data)</p>\n</li>\n<li><p>第二种方式，在父组件中：第二种首先需要在目标的子组件上定义ref属性，再在本组件的mounted钩子中完成事件绑定</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Demo</span> ref=<span class=\"string\">&quot;demo&quot;</span>/&gt;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"title function_\">mounted</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">   <span class=\"variable language_\">this</span>.<span class=\"property\">$refs</span>.<span class=\"property\">xxx</span>.$on(<span class=\"string\">&#x27;atguigu&#x27;</span>,<span class=\"variable language_\">this</span>.<span class=\"property\">test</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>若想让自定义事件只能触发一次，可以使用<code>.once</code>修饰符，或<code>$once</code>方法。</p>\n</li>\n</ol>\n</li>\n<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,要传递的数据)</code>        要传递的数据就是在触发自定义事件的时候，以参数的形式传给对应的回调函数</p>\n</li>\n<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>\n</li>\n<li><p>组件上也可以绑定原生DOM事件（例如@click），需要使用<code>.native</code>修饰符（@click.native）。否则，会默认他是一个自定义事件！</p>\n</li>\n<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style=\"color:#3cb371\">要么配置在methods中</span>，<span style=\"color:#3cb371\">要么用箭头函数</span>，否则this指向会出问题！</p>\n</li>\n</ol>\n<h2 id=\"全局事件总线（GlobalEventBus）\"><a href=\"#全局事件总线（GlobalEventBus）\" class=\"headerlink\" title=\"全局事件总线（GlobalEventBus）\"></a>全局事件总线（GlobalEventBus）</h2><ol>\n<li><p>一种组件间通信的方式，适用于<span style=\"color:#3cb371\">任意组件间通信</span>。</p>\n</li>\n<li><p>安装全局事件总线：<span style=\"color:#3cb371\">事件总线有两个要求：1. 需要让所有的组件都能够访问的到    2. 且身上具有$on,$emit等api</span></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">\t......<span class=\"comment\">//beforeCreate()注意在这个创建之前钩子中进行设置</span></span><br><span class=\"line\">\t<span class=\"title function_\">beforeCreate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$bus</span> = <span class=\"variable language_\">this</span> <span class=\"comment\">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class=\"line\">    <span class=\"comment\">//1.因为将这个总线(傀儡)$bus放在Vue的原型对象上，那么所有的vc组件实例对象都能够通过原型链向上找到这个总线$bus</span></span><br><span class=\"line\">    <span class=\"comment\">//2.且这个$bus就是vm，因为这样他身上才会有$on,$off,$emit等api</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;) </span><br></pre></td></tr></table></figure></li>\n<li><p>使用事件总线：</p>\n<ol>\n<li><p>接收数据组件<span style=\"color:#3cb371\">(绑定事件)</span>：A组件想接收数据，则在A组件中给$bus绑定自定义事件<span style=\"color:#3cb371\">(在mounted钩子中进行绑定，一挂载就绑定)</span>，事件的<span style=\"color:#3cb371\">回调留在A组件自身。</span></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">methods</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"title function_\">demo</span>(<span class=\"params\">data</span>)&#123;......&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">$bus</span>.$on(<span class=\"string\">&#x27;xxxx&#x27;</span>,<span class=\"variable language_\">this</span>.<span class=\"property\">demo</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>提供数据组件<span style=\"color:#3cb371\">(触发事件)</span>：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code> <span style=\"color:#3cb371\">提供数据的组件，需要在本组件方法内$emit触发事件总线中绑定的事件，并通过参数来传送数据</span></p>\n</li>\n</ol>\n</li>\n<li><p>接收数据的组件最好在beforeDestroy钩子中，用this.$bus.$off去解绑<span style=\"color:#3cb371\">当前组件所用到的</span>事件。</p>\n</li>\n</ol>\n<h2 id=\"消息订阅与发布（pubsub）\"><a href=\"#消息订阅与发布（pubsub）\" class=\"headerlink\" title=\"消息订阅与发布（pubsub）\"></a>消息订阅与发布（pubsub）</h2><ol>\n<li><p>  一种组件间通信的方式，适用于<span style=\"color:#3cb371\">任意组件间通信</span>。</p>\n</li>\n<li><p>使用步骤：</p>\n<ol>\n<li><p>安装pubsub：<code>npm i pubsub-js</code></p>\n</li>\n<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code> 用到pubsub的vue组件都需要引入</p>\n</li>\n<li><p>接收数据<span style=\"color:#3cb371\">(订阅消息)</span>：A组件想接收数据，则在A组件中订阅消息，订阅的<span style=\"color:#3cb371\">回调留在A组件自身。</span></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">methods</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//一定要注意订阅消息时，后面的回调函数中第一个参数是固定的msgName为本次消息名，这里用_来占位，后面的data才是真正的获取的数据</span></span><br><span class=\"line\">  <span class=\"title function_\">demo</span>(<span class=\"params\">_,data</span>)&#123;......&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">//消息的订阅也是在组件挂载完毕的钩子中完成的</span></span><br><span class=\"line\"><span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">pid</span> = pubsub.<span class=\"title function_\">subscribe</span>(<span class=\"string\">&#x27;消息名&#x27;</span>,<span class=\"variable language_\">this</span>.<span class=\"property\">demo</span>) <span class=\"comment\">//订阅消息</span></span><br><span class=\"line\"><span class=\"comment\">//注意订阅消息后，会返回一个订阅id，这个id是用来找到这个消息，并取消订阅</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>提供数据<span style=\"color:#3cb371\">(发布消息)</span>：<code>pubsub.publish(&#39;消息名&#39;,数据)</code></p>\n</li>\n<li><p>最好在beforeDestroy钩子中，用<code>pubsub.unsubscribe(this.pid)</code>去<span style=\"color:#3cb371\">取消订阅。</span></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"nextTick\"><a href=\"#nextTick\" class=\"headerlink\" title=\"nextTick\"></a>nextTick</h2><ol>\n<li>语法：<code>this.$nextTick(回调函数)</code></li>\n<li>作用：在下一次 DOM 更新结束后执行其指定的回调。在对原dom做出修改后，Vue重新解析模板后生成的新dom，这时我们对这个新dom进行一些操作时，需要通过$nextTick(function{})中的回调来实现</li>\n<li>什么时候用：当改变数据后<span style=\"color:#3cb371\">(例如修改了data中的值)</span>&gt;，要基于更新后的新DOM进行某些操作时<span style=\"color:#3cb371\">(例如修改后，会有一个input框的生成，我们想要在input框生成后就立即获取焦点focus())</span>&gt;，这时要在nextTick所指定的回调函数中执行(完成获取焦点的操作)。</li>\n</ol>\n<h2 id=\"Vue封装的过渡与动画\"><a href=\"#Vue封装的过渡与动画\" class=\"headerlink\" title=\"Vue封装的过渡与动画\"></a>Vue封装的过渡与动画</h2><ol>\n<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>\n</li>\n<li><p>动画可以引入第三方的动画库(animate.css) 添加指定的name，appear-active-class，leave-active-class即可完成动画效果</p>\n</li>\n<li><p>写法：</p>\n<ol>\n<li><p>准备好样式：</p>\n<ul>\n<li>元素进入的样式：<ol>\n<li>v-enter：进入的起点</li>\n<li>v-enter-active：进入过程中</li>\n<li>v-enter-to：进入的终点</li>\n</ol>\n</li>\n<li>元素离开的样式：<ol>\n<li>v-leave：离开的起点</li>\n<li>v-leave-active：离开过程中</li>\n<li>v-leave-to：离开的终点</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>使用<code>&lt;transition&gt;</code>包裹要过渡的元素，并配置name属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class=\"line\">\t&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>备注：若有多个元素需要过渡，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"vue脚手架配置代理\"><a href=\"#vue脚手架配置代理\" class=\"headerlink\" title=\"vue脚手架配置代理\"></a>vue脚手架配置代理</h2><p>以下都通过axios来发送ajax请求：1.首先先安装axios包： npm i axios</p>\n<p>​                                                       2.导入axios：import axios from ‘axios’</p>\n<p>实现跨域：1.cors <span style=\"color:#3cb371\">真正解决了跨域问题</span></p>\n<p>​                 2.jsonp <span style=\"color:#3cb371\">jsonp实现跨域的本质是通过script标签的src属性在引入外部资源时，不受到同源限制的特点来实现的，但是只能解决get请求，要求前后端配合写法</span></p>\n<p>​                 3.利用代理服务器<span style=\"color:#3cb371\">（开启代理服务器的两种方式：1.通过Nginx     2.通过vue-cli脚手架）</span></p>\n<p>文件中的两个服务器开启方式：文件中打开cmd，命令node server1/server2   </p>\n<p>关闭服务器：ctrl+c</p>\n<h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>​    在vue.config.js中添加如下配置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">devServer</span>:&#123;</span><br><span class=\"line\">  <span class=\"attr\">proxy</span>:<span class=\"string\">&quot;http://localhost:5000&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ol>\n<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>\n<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>\n<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （如果前端有这个资源，也就是根目录public下有的资源，那么就优先匹配前端资源，不会再去转发给目标服务器了）</li>\n</ol>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>​    编写vue.config.js配置具体代理规则：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">proxy</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;/api1&#x27;</span>: &#123;<span class=\"comment\">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class=\"line\">        <span class=\"attr\">target</span>: <span class=\"string\">&#x27;http://localhost:5000&#x27;</span>,<span class=\"comment\">// 代理目标的基础路径，也就是只写到端口号即可，不用写到具体的资源路径</span></span><br><span class=\"line\">        <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">pathRewrite</span>: &#123;<span class=\"string\">&#x27;^/api1&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>&#125;<span class=\"comment\">// pathRewrite路径重写，里面是一个key:value键值对形式</span></span><br><span class=\"line\">          <span class=\"comment\">//   ^/api1表示把所有的以api1开头的路径，把这段路径修改为空，即没有了/api1</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">&#x27;/api2&#x27;</span>: &#123;<span class=\"comment\">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class=\"line\">        <span class=\"attr\">target</span>: <span class=\"string\">&#x27;http://localhost:5001&#x27;</span>,<span class=\"comment\">// 代理目标的基础路径</span></span><br><span class=\"line\">        <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">pathRewrite</span>: &#123;<span class=\"string\">&#x27;^/api2&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   changeOrigin设置为true时(代理服务器撒谎了，说自己的host与代理服务器的目标服务器相同都为localhost:5000)，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class=\"line\"><span class=\"comment\">   changeOrigin设置为false时(代理服务器如实回答)，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class=\"line\"><span class=\"comment\">   changeOrigin默认值为true</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ol>\n<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>\n<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>\n</ol>\n<h2 id=\"插槽\"><a href=\"#插槽\" class=\"headerlink\" title=\"插槽\"></a>插槽</h2><ol>\n<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style=\"color:#3cb371\">父组件 ===&gt; 子组件</strong> 。</p>\n</li>\n<li><p>分类：默认插槽、具名插槽、作用域插槽</p>\n</li>\n<li><p>使用方式：</p>\n<ol>\n<li><p>默认插槽：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父组件中：</span><br><span class=\"line\">        &lt;Category&gt;</span><br><span class=\"line\">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class=\"line\">        &lt;/Category&gt;</span><br><span class=\"line\">子组件中：</span><br><span class=\"line\">        &lt;template&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">               &lt;!-- 定义插槽 --&gt;</span><br><span class=\"line\">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>具名插槽：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父组件中：</span><br><span class=\"line\">        &lt;Category&gt;</span><br><span class=\"line\">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class=\"line\">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class=\"line\">            &lt;/template&gt;</span><br><span class=\"line\">\t\t&lt;!--- 当我使用了template时，指定插槽也可以用下面的方式v-slot:footer--&gt;</span><br><span class=\"line\">            &lt;template v-slot:footer&gt;</span><br><span class=\"line\">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class=\"line\">            &lt;/template&gt;</span><br><span class=\"line\">        &lt;/Category&gt;</span><br><span class=\"line\">子组件中：</span><br><span class=\"line\">        &lt;template&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">               &lt;!-- 定义插槽 --&gt;</span><br><span class=\"line\">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class=\"line\">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>作用域插槽：</p>\n<ol>\n<li><p>理解：<span style=\"color:#3cb371\">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在子组件Category中，但使用数据所遍历出来的结构由父组件App决定）</p>\n</li>\n<li><p>作用域插槽必须通过template标签进行包裹</p>\n</li>\n<li><p>具体编码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父组件中：</span><br><span class=\"line\">\t\t&lt;Category&gt;</span><br><span class=\"line\">            &lt;!--- 这里可以利用对象的解构赋值，这样就直接可以使用games获取到scopeData.games的属性值--&gt;</span><br><span class=\"line\">            &lt;!--- scope=&quot;&#123;games&#125;&quot;--&gt;</span><br><span class=\"line\">\t\t\t&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!-- 生成的是ul列表 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;ul&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/ul&gt;</span><br><span class=\"line\">\t\t\t&lt;/template&gt;</span><br><span class=\"line\">\t\t&lt;/Category&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;Category&gt;</span><br><span class=\"line\">\t\t\t&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!-- 生成的是h4标题 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class=\"line\">\t\t\t&lt;/template&gt;</span><br><span class=\"line\">\t\t&lt;/Category&gt;</span><br><span class=\"line\">子组件中：</span><br><span class=\"line\">        &lt;template&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/template&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;script&gt;</span><br><span class=\"line\">            export default &#123;</span><br><span class=\"line\">                name:&#x27;Category&#x27;,</span><br><span class=\"line\">                props:[&#x27;title&#x27;],</span><br><span class=\"line\">                //数据在子组件自身</span><br><span class=\"line\">                data() &#123;</span><br><span class=\"line\">                    return &#123;</span><br><span class=\"line\">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h3><p>​        在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>\n<h3 id=\"2-何时使用？\"><a href=\"#2-何时使用？\" class=\"headerlink\" title=\"2.何时使用？\"></a>2.何时使用？</h3><p>​        多个组件需要共享数据时</p>\n<h3 id=\"3-搭建vuex环境\"><a href=\"#3-搭建vuex环境\" class=\"headerlink\" title=\"3.搭建vuex环境\"></a>3.搭建vuex环境</h3><ol>\n<li><p>创建文件：<code>src/store/index.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入Vue核心库</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入Vuex</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//应用Vuex插件</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//准备actions对象——响应组件中用户的动作，相当于服务员</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//准备mutations对象——修改state中的数据，相当于厨师</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//准备state对象——保存具体的数据，相当于最后的菜品</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建并暴露store</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">\tactions,</span><br><span class=\"line\">\tmutations,</span><br><span class=\"line\">\tstate</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入Vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入App</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入插件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> vueResource <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-resource&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//关闭Vue的生产提示</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\">config</span>.<span class=\"property\">productionTip</span> = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">//使用插件</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(vueResource)</span><br><span class=\"line\"><span class=\"comment\">//1.引入store</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建vm</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"comment\">//注意一定要在vm里面定义使用</span></span><br><span class=\"line\">\tstore,<span class=\"comment\">//2.定义store，这样vm以及所有的vc身上都会有$store了，都可以通过this.$store来调用</span></span><br><span class=\"line\">\t<span class=\"attr\">render</span>: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> <span class=\"title function_\">h</span>(<span class=\"title class_\">App</span>),</span><br><span class=\"line\">\t<span class=\"title function_\">beforeCreate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$bus</span> = <span class=\"variable language_\">this</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"4-基本使用\"><a href=\"#4-基本使用\" class=\"headerlink\" title=\"4.基本使用\"></a>4.基本使用</h3><ol>\n<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入Vue核心库</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入Vuex</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vuex</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引用Vuex,因为vuex本身是一个插件plguins，所以导入后需要通过Vue.use()使用</span></span><br><span class=\"line\"><span class=\"comment\">//因为只有先使用Vue.use(Vuex)，才能去创建new Vuex.Store()</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"title class_\">Vuex</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//actions是用来接收vc通过this.$dispatch(&#x27;操作名add&#x27;,参数)，这时里面操作名add需要在actions中配置</span></span><br><span class=\"line\"><span class=\"comment\">//并接收参数value</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//🌈context为上下文，其中有commit(),dispatch(),state....等方法和属性</span></span><br><span class=\"line\">    <span class=\"comment\">//context.commit()用来将接收到的数据进一步呈递给mutations处理</span></span><br><span class=\"line\">    <span class=\"comment\">//context.dispatch()当业务逻辑很复杂时，在一个操作函数中并不能完成逻辑，那么就需要context.dispatch(&#x27;demo&#x27;,value)进一步分发给</span></span><br><span class=\"line\">    <span class=\"comment\">//同在actions中的其他方法demo()，demo会对进一步完成逻辑操作，使最终满足业务逻辑要求</span></span><br><span class=\"line\">    <span class=\"comment\">//context中具有state属性，所以它可以直接访问到里面的状态(数据)sum</span></span><br><span class=\"line\">    <span class=\"comment\">//🌟当数据需要进行一些逻辑操作时，就需要放在actions执行</span></span><br><span class=\"line\">    <span class=\"title function_\">addWhenOdd</span>(<span class=\"params\">context, value</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context.<span class=\"property\">state</span>.<span class=\"property\">sum</span> % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            context.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;ADD&#x27;</span>, value)<span class=\"comment\">//commit传给mutations时的方法名一般要全大写ADD</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">addWait</span>(<span class=\"params\">context, value</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            context.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;ADD&#x27;</span>, value)</span><br><span class=\"line\">        &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//mutations是用来处理数据的，数据通过actions中的对应操作的函数调用commit方法来传递给mutaiton</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;</span><br><span class=\"line\">    <span class=\"title function_\">ADD</span>(<span class=\"params\">state, value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;mutations中的+被调用了&#x27;</span>);</span><br><span class=\"line\">        state.<span class=\"property\">sum</span> += value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">SUBTRACT</span>(<span class=\"params\">state, value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;mutations中的-被调用了&#x27;</span>);</span><br><span class=\"line\">        state.<span class=\"property\">sum</span> -= value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//所共享的数据都会放在state中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">    <span class=\"attr\">sum</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建并暴露store</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这因为key:value值相同，所以都使用简写形式</span></span><br><span class=\"line\">    actions,</span><br><span class=\"line\">    mutations,</span><br><span class=\"line\">    state,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>\n</li>\n<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>\n<blockquote>\n<p> <span style=\"color:#3cb371\">备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></span></p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"C:\\Users\\24825\\Desktop\\Vue资料\\02_原理图\\vuex.png\"></p>\n<h3 id=\"5-getters的使用\"><a href=\"#5-getters的使用\" class=\"headerlink\" title=\"5.getters的使用\"></a>5.getters的使用</h3><ol>\n<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。<span style=\"color:#3cb371\">它其实可以理解为Vuex中的计算属性computed,对于state中的数据进一步加工，最后通过return返回加工后的值。</span></p>\n</li>\n<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getters = &#123;</span><br><span class=\"line\">\t<span class=\"title function_\">bigSum</span>(<span class=\"params\">state</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> state.<span class=\"property\">sum</span> * <span class=\"number\">10</span><span class=\"comment\">//需要return返回处理后的值</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建并暴露store</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tgetters</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>\n</li>\n</ol>\n<h3 id=\"6-四个map方法的使用\"><a href=\"#6-四个map方法的使用\" class=\"headerlink\" title=\"6.四个map方法的使用\"></a>6.四个map方法的使用</h3><blockquote>\n<p>备注：mapState, mapGetters这两个是帮我们生成一个计算属性的（配置在computed中）</p>\n<p>​     mapMutations, mapActions这两个是帮我们生成一个方法的（配置在methods中）</p>\n</blockquote>\n<p>首先需要在组件中导入mapState, mapGetters, mapMutations, mapActions</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;mapState, mapGetters, mapMutations, mapActions&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为<span style=\"color:#3cb371\">计算属性</span>,mapXxx就是从Xxx取东西</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class=\"line\">    <span class=\"comment\">//...&#123;&#125;可以将一个对象中的key:value分解出来，形成单独的key:value</span></span><br><span class=\"line\">    <span class=\"comment\">//前面的sum表示的计算属性的函数名（本身对象的key可以简写不用加引号），后面的&#x27;sum&#x27;表示要从state中读取名为sum这个属性值</span></span><br><span class=\"line\">     ...<span class=\"title function_\">mapState</span>(&#123;<span class=\"attr\">sum</span>:<span class=\"string\">&#x27;sum&#x27;</span>,<span class=\"attr\">school</span>:<span class=\"string\">&#x27;school&#x27;</span>,<span class=\"attr\">subject</span>:<span class=\"string\">&#x27;subject&#x27;</span>&#125;),</span><br><span class=\"line\">         </span><br><span class=\"line\">    <span class=\"comment\">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class=\"line\">    <span class=\"comment\">//写成数组时[&#x27;sum&#x27;]，这时&#x27;sum&#x27;有两种用途，也就是计算属性名和读取数据名要相同！！</span></span><br><span class=\"line\">         <span class=\"comment\">//1. 将sum作为计算属性sum()&#123;&#125;</span></span><br><span class=\"line\">         <span class=\"comment\">//2. 从state中读取名为&#x27;sum&#x27;的属性值</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapState</span>([<span class=\"string\">&#x27;sum&#x27;</span>,<span class=\"string\">&#x27;school&#x27;</span>,<span class=\"string\">&#x27;subject&#x27;</span>]),</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapGetters</span>(&#123;<span class=\"attr\">bigSum</span>:<span class=\"string\">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapGetters</span>([<span class=\"string\">&#x27;bigSum&#x27;</span>])</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">methods</span>:&#123;</span><br><span class=\"line\">    <span class=\"comment\">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapActions</span>(&#123;<span class=\"attr\">incrementOdd</span>:<span class=\"string\">&#x27;jiaOdd&#x27;</span>,<span class=\"attr\">incrementWait</span>:<span class=\"string\">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapActions</span>([<span class=\"string\">&#x27;jiaOdd&#x27;</span>,<span class=\"string\">&#x27;jiaWait&#x27;</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">methods</span>:&#123;</span><br><span class=\"line\">    <span class=\"comment\">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class=\"line\">    <span class=\"comment\">//其中increment就会作为methods中的方法名,形成一个increment(vlaue)&#123;方法内部就会调用commit去联系mutations&#125;的方法，&#x27;JIA&#x27;是会去mutations中找名为JIA的函数并执行它</span></span><br><span class=\"line\">    <span class=\"comment\">//这样的话就不需要我们通过$store.commit(&#x27;JIA&#x27;，value)来去和mutations进行对话了</span></span><br><span class=\"line\">    <span class=\"comment\">//注意这里无法传入increment方法所需的参数，所以需要在模板中绑定事件触发该increment方法时就传入参数value</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapMutations</span>(&#123;<span class=\"attr\">increment</span>:<span class=\"string\">&#x27;JIA&#x27;</span>,<span class=\"attr\">decrement</span>:<span class=\"string\">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class=\"line\">    ...<span class=\"title function_\">mapMutations</span>([<span class=\"string\">&#x27;JIA&#x27;</span>,<span class=\"string\">&#x27;JIAN&#x27;</span>]),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>\n</blockquote>\n<h3 id=\"7-模块化-命名空间\"><a href=\"#7-模块化-命名空间\" class=\"headerlink\" title=\"7.模块化+命名空间\"></a>7.模块化+命名空间</h3><ol>\n<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>\n</li>\n<li><p>修改<code>store.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> countAbout = &#123;</span><br><span class=\"line\">  <span class=\"attr\">namespaced</span>:<span class=\"literal\">true</span>,<span class=\"comment\">//开启命名空间</span></span><br><span class=\"line\">  <span class=\"attr\">state</span>:&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">bigSum</span>(<span class=\"params\">state</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> state.<span class=\"property\">sum</span> * <span class=\"number\">10</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> personAbout = &#123;</span><br><span class=\"line\">  <span class=\"attr\">namespaced</span>:<span class=\"literal\">true</span>,<span class=\"comment\">//开启命名空间</span></span><br><span class=\"line\">  <span class=\"attr\">state</span>:&#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> <span class=\"title class_\">Vuex</span>.<span class=\"title class_\">Store</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">modules</span>: &#123;</span><br><span class=\"line\">    countAbout,</span><br><span class=\"line\">    personAbout</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>开启命名空间后，组件中读取state数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一：自己直接读取</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">state</span>.<span class=\"property\">personAbout</span>.<span class=\"property\">list</span></span><br><span class=\"line\"><span class=\"comment\">//方式二：借助mapState读取：</span></span><br><span class=\"line\">...<span class=\"title function_\">mapState</span>(<span class=\"string\">&#x27;countAbout&#x27;</span>,[<span class=\"string\">&#x27;sum&#x27;</span>,<span class=\"string\">&#x27;school&#x27;</span>,<span class=\"string\">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure></li>\n<li><p>开启命名空间后，组件中读取getters数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一：自己直接读取</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"property\">getters</span>[<span class=\"string\">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">//方式二：借助mapGetters读取：</span></span><br><span class=\"line\">...<span class=\"title function_\">mapGetters</span>(<span class=\"string\">&#x27;countAbout&#x27;</span>,[<span class=\"string\">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure></li>\n<li><p>开启命名空间后，组件中调用dispatch</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一：自己直接dispatch</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">dispatch</span>(<span class=\"string\">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class=\"line\"><span class=\"comment\">//方式二：借助mapActions：</span></span><br><span class=\"line\">...<span class=\"title function_\">mapActions</span>(<span class=\"string\">&#x27;countAbout&#x27;</span>,&#123;<span class=\"attr\">incrementOdd</span>:<span class=\"string\">&#x27;jiaOdd&#x27;</span>,<span class=\"attr\">incrementWait</span>:<span class=\"string\">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>开启命名空间后，组件中调用commit</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一：自己直接commit</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class=\"line\"><span class=\"comment\">//方式二：借助mapMutations：</span></span><br><span class=\"line\">...<span class=\"title function_\">mapMutations</span>(<span class=\"string\">&#x27;countAbout&#x27;</span>,&#123;<span class=\"attr\">increment</span>:<span class=\"string\">&#x27;JIA&#x27;</span>,<span class=\"attr\">decrement</span>:<span class=\"string\">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><ol>\n<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>\n<li>前端路由：key是路径，value是组件。</li>\n</ol>\n<h3 id=\"1-基本使用\"><a href=\"#1-基本使用\" class=\"headerlink\" title=\"1.基本使用\"></a>1.基本使用</h3><ol>\n<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>\n</li>\n<li><p>应用插件：<code>Vue.use(VueRouter)</code> 在main.js中应用路由插件VueRouter，并在vm中配置路由器属性router</p>\n</li>\n<li><p>编写router路由器配置项: 路由器会独立写在一个目录为router下的index.js文件中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入VueRouter</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">VueRouter</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-router&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//引入Luyou 组件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">About</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../components/About&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../components/Home&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">VueRouter</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">routes</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/about&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">About</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/home&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Home</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//暴露router</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> router</span><br></pre></td></tr></table></figure></li>\n<li><p>实现切换（active-class可配置高亮样式）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>指定展示位置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"2-几个注意点\"><a href=\"#2-几个注意点\" class=\"headerlink\" title=\"2.几个注意点\"></a>2.几个注意点</h3><ol>\n<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>\n<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>\n<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>\n<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>\n</ol>\n<h3 id=\"3-多级路由（多级路由）\"><a href=\"#3-多级路由（多级路由）\" class=\"headerlink\" title=\"3.多级路由（多级路由）\"></a>3.多级路由（多级路由）</h3><ol>\n<li><p>配置路由规则，使用children配置项：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">routes</span>:[</span><br><span class=\"line\">    <span class=\"comment\">//一级路由</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/about&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">About</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/home&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Home</span>,</span><br><span class=\"line\">     \t<span class=\"comment\">//二级路由 </span></span><br><span class=\"line\">\t\t<span class=\"attr\">children</span>:[ <span class=\"comment\">//通过children[]配置子级路由</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;news&#x27;</span>, <span class=\"comment\">//🌈此处一定不要写：/news</span></span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">News</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"comment\">//此处一定不要写：/message</span></span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Message</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></li>\n<li><p><span style=\"color:#3cb371\">跳转（要写完整路径）：</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"4-路由的query参数\"><a href=\"#4-路由的query参数\" class=\"headerlink\" title=\"4.路由的query参数\"></a>4.路由的query参数</h3><p>因为组件的this.$route.query上包含着传过来的query参数信息</p>\n<ol>\n<li><p>传递参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class=\"line\">当使用to的字符串写法时，如果传递的参数时动态获取的，这时需要通过模板字符串``和$&#123;&#125;进行操作，但注意to要加冒号绑定，且要有&quot;`$&#123;&#125;`&quot;包裹</span><br><span class=\"line\">&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;js语句&#125;&amp;title=$&#123;js语句&#125;`&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class=\"line\">&lt;router-link </span><br><span class=\"line\">\t:to=&quot;&#123;</span><br><span class=\"line\">\t\tpath:&#x27;/home/message/detail&#x27;,</span><br><span class=\"line\">\t\tquery:&#123;</span><br><span class=\"line\">\t\t   id:666,</span><br><span class=\"line\">            title:&#x27;你好&#x27;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;&quot;</span><br><span class=\"line\">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>接收参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$route.<span class=\"property\">query</span>.<span class=\"property\">id</span></span><br><span class=\"line\">$route.<span class=\"property\">query</span>.<span class=\"property\">title</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"5-命名路由\"><a href=\"#5-命名路由\" class=\"headerlink\" title=\"5.命名路由\"></a>5.命名路由</h3><ol>\n<li><p>作用：可以简化路由的跳转。<span style=\"color:#3cb371\">但注意一定是当路径复杂，也就是到了三级四级之后的子路由，可以通过name来直接跳转</span></p>\n</li>\n<li><p>如何使用</p>\n<ol>\n<li><p>给路由命名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/demo&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">component</span>:<span class=\"title class_\">Demo</span>,</span><br><span class=\"line\">\t<span class=\"attr\">children</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;test&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Test</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">children</span>:[</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">                      <span class=\"attr\">name</span>:<span class=\"string\">&#x27;hello&#x27;</span> <span class=\"comment\">//给路由命名</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;welcome&#x27;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Hello</span>,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>简化跳转：<span style=\"color:#3cb371\">通过name跳转时，:to=”{name:xxx}”一定要加:绑定，且name写在对象中</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class=\"line\">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class=\"line\">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class=\"line\">&lt;router-link </span><br><span class=\"line\">\t:to=&quot;&#123;</span><br><span class=\"line\">\t\tname:&#x27;hello&#x27;,</span><br><span class=\"line\">\t\tquery:&#123;</span><br><span class=\"line\">\t\t   id:666,</span><br><span class=\"line\">            title:&#x27;你好&#x27;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;&quot;</span><br><span class=\"line\">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-路由的params参数（需要占位）\"><a href=\"#6-路由的params参数（需要占位）\" class=\"headerlink\" title=\"6.路由的params参数（需要占位）\"></a>6.路由的params参数（需要占位）</h3><ol>\n<li><p>配置路由，声明接收params参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/home&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">component</span>:<span class=\"title class_\">Home</span>,</span><br><span class=\"line\">\t<span class=\"attr\">children</span>:[</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;news&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">News</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Message</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">children</span>:[</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">name</span>:<span class=\"string\">&#x27;xiangqing&#x27;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;detail/:id/:title&#x27;</span>, <span class=\"comment\">//🌈使用占位符声明接收params参数</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">component</span>:<span class=\"title class_\">Detail</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>传递参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class=\"line\">&lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class=\"line\"> &lt;router-link :to=&quot;&#123;</span><br><span class=\"line\">          name:&#x27;xiangqing&#x27;,</span><br><span class=\"line\">          params:&#123;</span><br><span class=\"line\">            id:m.id,</span><br><span class=\"line\">            title:m.title</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项 path:’/home/message/detail’，必须使用name配置 name:’xiangqing’！</p>\n</blockquote>\n</li>\n<li><p>接收参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$route.<span class=\"property\">params</span>.<span class=\"property\">id</span></span><br><span class=\"line\">$route.<span class=\"property\">params</span>.<span class=\"property\">title</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"7-路由的props配置\"><a href=\"#7-路由的props配置\" class=\"headerlink\" title=\"7.路由的props配置\"></a>7.路由的props配置</h3><p>​    作用：让路由组件更方便的收到参数</p>\n<blockquote>\n<p><span style=\"color:#3cb371\">注意以下的三种写法，他们都是通过pros给Detail组件传递参数，所以一定要在Detail组件中用props[‘xx’]接收</span></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&#x27;xiangqing&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;detail/:id&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">component</span>:<span class=\"title class_\">Detail</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class=\"line\">\t<span class=\"comment\">// props:&#123;a:900&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class=\"line\">    <span class=\"comment\">//第二种仅仅只能将params参数通过prpos传递</span></span><br><span class=\"line\">\t<span class=\"comment\">// props:true</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class=\"line\">\t<span class=\"title function_\">props</span>(<span class=\"params\">$route</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">id</span>:$route.<span class=\"property\">query</span>.<span class=\"property\">id</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">title</span>:$route.<span class=\"property\">query</span>.<span class=\"property\">title</span></span><br><span class=\"line\">            <span class=\"comment\">//第三种写法也可以传递其他类型的数据，同样需要在Detail组件中props接收</span></span><br><span class=\"line\">            <span class=\"attr\">a</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\">            <span class=\"attr\">b</span>: <span class=\"string\">&#x27;我是b&#x27;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//第三种中利用解构赋值简化写法，解构出$route对象中的&#123;query&#125;</span></span><br><span class=\"line\">    <span class=\"title function_\">props</span>(<span class=\"params\">&#123;query&#125;</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">id</span>:query.<span class=\"property\">id</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">title</span>:query.<span class=\"property\">title</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//第三种中利用解构赋值的嵌套写法，再次简化写法，继续解构处query对象中的id和title &#123;query:&#123;id,title&#125;&#125;</span></span><br><span class=\"line\">    <span class=\"title function_\">props</span>(<span class=\"params\">&#123;query:&#123;id,title&#125;&#125;</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\tid,<span class=\"comment\">//简写形式</span></span><br><span class=\"line\">\t\t\ttitle</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-lt-router-link-gt-的replace属性\"><a href=\"#8-lt-router-link-gt-的replace属性\" class=\"headerlink\" title=\"8.&lt;router-link&gt;的replace属性\"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>\n<li>作用：控制路由跳转时操作浏览器历史记录的模式，可以通过浏览的前进和后退指针进行跳转</li>\n<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>（它就相当于入栈，点击一次router-link，就会把当前的跳转的路径压入栈中）和<code>replace</code>（它相当于入栈的时候把栈顶元素替换掉，就是把当前栈顶的路径替换为本次跳转的路径），<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>\n<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>\n</ol>\n<h3 id=\"9-编程式路由导航\"><a href=\"#9-编程式路由导航\" class=\"headerlink\" title=\"9.编程式路由导航\"></a>9.编程式路由导航</h3><ol>\n<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>\n</li>\n<li><p>具体编码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//$router的两个API</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&#x27;xiangqing&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">params</span>:&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">id</span>:xxx,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">title</span>:xxx</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">replace</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&#x27;xiangqing&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"attr\">params</span>:&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">id</span>:xxx,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">title</span>:xxx</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">forward</span>() <span class=\"comment\">//前进</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">back</span>() <span class=\"comment\">//后退</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">go</span>() <span class=\"comment\">//可前进go(3)前进3步 也可后退go(-3)后退三步</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"10-缓存路由组件\"><a href=\"#10-缓存路由组件\" class=\"headerlink\" title=\"10.缓存路由组件\"></a>10.缓存路由组件</h3><ol>\n<li><p>作用：让不展示的路由组件保持挂载，不被销毁。<span style=\"color:#3cb371\">（一般想要保留数据的组件）</span></p>\n</li>\n<li><p>具体编码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class=\"line\">    &lt;!-- 一定是包在&lt;router-view&gt;标签的外部 --&gt; </span><br><span class=\"line\">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p><span style=\"color:#3cb371\">1. 上述中指定include=”xxx” 这个名字是组件的名字，也就是vc中的name属性配置</span></p>\n<p><span style=\"color:#3cb371\">2. 也可以不指定include，这时展示在router-view中的组件都会保持挂载，不会销毁</span></p>\n<ol start=\"3\">\n<li>如果需要在多个组件中挑选出其中的几个组件来使其保持挂载，那么可以用冒号绑定还有数组包裹<span style=\"color:#3cb371\"> :include=”[‘组件名1’,’组件名2’]”</span></li>\n</ol>\n</blockquote>\n<h3 id=\"11-两个新的生命周期钩子\"><a href=\"#11-两个新的生命周期钩子\" class=\"headerlink\" title=\"11.两个新的生命周期钩子\"></a>11.两个新的生命周期钩子</h3><ol>\n<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>\n<li>具体名字：<ol>\n<li><code>activated</code>路由组件被激活时触发。</li>\n<li><code>deactivated</code>路由组件失活时触发。</li>\n</ol>\n</li>\n<li>小结生命钩子：beforeCreate(),creared(),beforeMount(),mounted(),beforeUpdate(),updated(),beforeDestory(),destoryed(),<span style=\"color:#3cb371\">activated(),deactivated(),$nextTick()</span></li>\n</ol>\n<h3 id=\"12-路由守卫\"><a href=\"#12-路由守卫\" class=\"headerlink\" title=\"12.路由守卫\"></a>12.路由守卫</h3><ol>\n<li><p>作用：对路由进行权限控制</p>\n</li>\n<li><p>分类：全局守卫、独享守卫、组件内守卫</p>\n</li>\n<li><p>全局守卫:</p>\n<ol>\n<li>全局前置守卫和后置守卫，两个函数都有to,from参数，to{name:”xxx”,path:”/xxx”,meta:{}}表示的目的路径信息 <span style=\"color:#3cb371\">(这个组件的路由信息其实和目的组件中的$route信息相同)，</span>from{}表示的是起点路径信息</li>\n<li>前置守卫的next参数表明 是否放行该路径,只有next()放行了才会真正到达目的组件<span style=\"color:#3cb371\">（注意如果没有放行该路由，也就是没有到达目的to组件，这时全局后置路由是不会执行的！只有全局前置路由执行！）</span></li>\n<li>to.meta{}，meta对象中是包含的是路由的元信息，也就是coder自己定义的一些数据 </li>\n<li>对于全局守卫而言，他是router身上的函数，所以需要在index.js接收这个路由器router,而不是直接将路由器暴露</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class=\"line\">router.<span class=\"title function_\">beforeEach</span>(<span class=\"function\">(<span class=\"params\">to,<span class=\"keyword\">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;beforeEach&#x27;</span>,to,<span class=\"keyword\">from</span>)</span><br><span class=\"line\">    <span class=\"comment\">//这里需要在路由器的routes的配置中，对需要判断是否要有权限的路由，给他的meta自定义一组key:value </span></span><br><span class=\"line\">    <span class=\"comment\">//meta:&#123;isAuth:true&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(to.<span class=\"property\">meta</span>.<span class=\"property\">isAuth</span>)&#123; <span class=\"comment\">//判断当前路由是否需要进行权限控制</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;school&#x27;</span>) === <span class=\"string\">&#x27;atguigu&#x27;</span>)&#123; <span class=\"comment\">//权限控制的具体规则</span></span><br><span class=\"line\">\t\t\t<span class=\"title function_\">next</span>() <span class=\"comment\">//放行</span></span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;暂无权限查看&#x27;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"title function_\">next</span>() <span class=\"comment\">//放行</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class=\"line\"><span class=\"comment\">//⭐注意如果前置路由中没有放行，那么这里的后置路由也不会执行</span></span><br><span class=\"line\">router.<span class=\"title function_\">afterEach</span>(<span class=\"function\">(<span class=\"params\">to,<span class=\"keyword\">from</span></span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;afterEach&#x27;</span>,to,<span class=\"keyword\">from</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(to.<span class=\"property\">meta</span>.<span class=\"property\">title</span>)&#123; </span><br><span class=\"line\">\t\t<span class=\"variable language_\">document</span>.<span class=\"property\">title</span> = to.<span class=\"property\">meta</span>.<span class=\"property\">title</span> <span class=\"comment\">//修改网页的title</span></span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">document</span>.<span class=\"property\">title</span> = <span class=\"string\">&#x27;vue_test&#x27;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>独享守卫: 他写在该组件的路由配置中 <span style=\"color:#3cb371\">独享只有前置守卫！他可以和全局后置守卫搭配使用</span></p>\n<p>beforeEnter(){}他是一个函数，不像全局守卫类似定时器回调</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">beforeEnter</span>(<span class=\"params\">to,<span class=\"keyword\">from</span>,next</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;beforeEnter&#x27;</span>,to,<span class=\"keyword\">from</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(to.<span class=\"property\">meta</span>.<span class=\"property\">isAuth</span>)&#123; <span class=\"comment\">//判断当前路由是否需要进行权限控制</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;school&#x27;</span>) === <span class=\"string\">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">next</span>()</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;暂无权限查看&#x27;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"title function_\">next</span>()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p> 组件内守卫：</p>\n</li>\n<li><p>组件内守卫首先是组件独有的，进入守卫和离开守卫都是定义在组件的vc中</p>\n</li>\n<li><p>两个守卫都是需要通过路由规则，也就是需要经过路由器指定匹配的路径的组件</p>\n</li>\n<li><p>两个守卫都有next参数，进入和离开都需要设置是否放行next()</p>\n</li>\n<li><p>进入守卫的to和离开守卫的from对应的路由信息都是本次组件的路由信息</p>\n</li>\n<li><p>当进入守卫中没有放行next()该路由时，那么页面是进入不到该路径里的！</p>\n</li>\n<li><p>同样的，它也可以和全局后置守卫搭配使用</p>\n</li>\n</ol>\n   <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//进入守卫：通过路由规则，进入该组件之前被调用</span></span><br><span class=\"line\">beforeRouteEnter (to, <span class=\"keyword\">from</span>, next) &#123;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"comment\">//离开守卫：通过路由规则，离开该组件时被调用，注意他和全局后置守卫的区别，离开守卫是当离开了该组件时(路由已经切换完了)，他才会调用</span></span><br><span class=\"line\"><span class=\"comment\">//而全局后置守卫是只要我本次路由切换完毕我就会调用</span></span><br><span class=\"line\">beforeRouteLeave (to, <span class=\"keyword\">from</span>, next) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-路由器的两种工作模式\"><a href=\"#13-路由器的两种工作模式\" class=\"headerlink\" title=\"13.路由器的两种工作模式\"></a>13.路由器的两种工作模式</h3><ol>\n<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>\n<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>\n<li>hash模式：<ol>\n<li>地址中永远带着#号，不美观 。</li>\n<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>\n<li>兼容性较好。</li>\n</ol>\n</li>\n<li>history模式：<ol>\n<li>地址干净，美观 。</li>\n<li>兼容性和hash模式相比略差。</li>\n<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>\n</ol>\n</li>\n<li>在路由器router配置中加上 mode:’history’ 就可以把路由器的工作模式转换为history模式，默认是hash模式</li>\n<li>项目的最终打包：npm run build 该命令会把vue文件都转换成为静态的前端代码html+css+js</li>\n</ol>\n"},{"title":"js测试","data":"2022-6-15","description":"这里是description","copyright_author":"wxb","copyright_author_href":"https://xxxxxx.com","copyright_url":"https://xxxxxx.com","copyright_info":"此文章版权归wxb所有，如有转载，请註明来自原作者","_content":"\n```js\n        //模拟获取  用户数据  订单数据  商品数据 \n        function getUsers() {\n            setTimeout(() => {\n                let data = '用户数据';let data1 = '用户数据';let data2 = '用户数据';let data3 = '用户数据';let data4 = '用户数据';let data5 = '用户数据';let data7 = '用户数据';\n                //调用 next 方法, 并且将数据传入\n                iterator.next(data);//这里开始第二次next，并将这个实参data传递给上一个yield返回值\n            }, 1000);\n        }\n\n        function getOrders() {\n            setTimeout(() => {\n                let data = '订单数据';\n                iterator.next(data);//第三次next\n            }, 1000)\n        }\n\n        function getGoods() {\n            setTimeout(() => {\n                let data = '商品数据';\n                iterator.next(data);//第四次next\n            }, 1000)\n        }\n\n        function* gen() {\n            let users = yield getUsers();//第一次调用next结束，同时执行getUsers()函数\n            //函数中第二次调用了next，并传入了实参，这时的实参将返回给上一次yield\n            console.log(users);\n            let orders = yield getOrders();//第二次next结束\n            console.log(orders);\n            let goods = yield getGoods();//第三次next结束\n            console.log(goods);\n            //第四次next结束\n        }\n\n        //调用生成器函数\n        let iterator = gen();\n        iterator.next();\n\n```","source":"_posts/test.md","raw":"---\ntitle: js测试\ndata: '2022-6-15'\ndescription: '这里是description'\ncopyright_author: wxb\ncopyright_author_href: https://xxxxxx.com\ncopyright_url: https://xxxxxx.com\ncopyright_info: 此文章版权归wxb所有，如有转载，请註明来自原作者\n---\n\n```js\n        //模拟获取  用户数据  订单数据  商品数据 \n        function getUsers() {\n            setTimeout(() => {\n                let data = '用户数据';let data1 = '用户数据';let data2 = '用户数据';let data3 = '用户数据';let data4 = '用户数据';let data5 = '用户数据';let data7 = '用户数据';\n                //调用 next 方法, 并且将数据传入\n                iterator.next(data);//这里开始第二次next，并将这个实参data传递给上一个yield返回值\n            }, 1000);\n        }\n\n        function getOrders() {\n            setTimeout(() => {\n                let data = '订单数据';\n                iterator.next(data);//第三次next\n            }, 1000)\n        }\n\n        function getGoods() {\n            setTimeout(() => {\n                let data = '商品数据';\n                iterator.next(data);//第四次next\n            }, 1000)\n        }\n\n        function* gen() {\n            let users = yield getUsers();//第一次调用next结束，同时执行getUsers()函数\n            //函数中第二次调用了next，并传入了实参，这时的实参将返回给上一次yield\n            console.log(users);\n            let orders = yield getOrders();//第二次next结束\n            console.log(orders);\n            let goods = yield getGoods();//第三次next结束\n            console.log(goods);\n            //第四次next结束\n        }\n\n        //调用生成器函数\n        let iterator = gen();\n        iterator.next();\n\n```","slug":"test","published":1,"date":"2022-06-14T03:28:55.832Z","updated":"2022-06-15T05:28:54.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4glk6rr00042wtm55tp8rvu","content":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟获取  用户数据  订单数据  商品数据 </span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getUsers</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data1 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data2 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data3 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data4 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data5 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data7 = <span class=\"string\">&#x27;用户数据&#x27;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用 next 方法, 并且将数据传入</span></span><br><span class=\"line\">        iterator.<span class=\"title function_\">next</span>(data);<span class=\"comment\">//这里开始第二次next，并将这个实参data传递给上一个yield返回值</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getOrders</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"string\">&#x27;订单数据&#x27;</span>;</span><br><span class=\"line\">        iterator.<span class=\"title function_\">next</span>(data);<span class=\"comment\">//第三次next</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getGoods</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"string\">&#x27;商品数据&#x27;</span>;</span><br><span class=\"line\">        iterator.<span class=\"title function_\">next</span>(data);<span class=\"comment\">//第四次next</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">gen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> users = <span class=\"keyword\">yield</span> <span class=\"title function_\">getUsers</span>();<span class=\"comment\">//第一次调用next结束，同时执行getUsers()函数</span></span><br><span class=\"line\">    <span class=\"comment\">//函数中第二次调用了next，并传入了实参，这时的实参将返回给上一次yield</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(users);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> orders = <span class=\"keyword\">yield</span> <span class=\"title function_\">getOrders</span>();<span class=\"comment\">//第二次next结束</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(orders);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> goods = <span class=\"keyword\">yield</span> <span class=\"title function_\">getGoods</span>();<span class=\"comment\">//第三次next结束</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(goods);</span><br><span class=\"line\">    <span class=\"comment\">//第四次next结束</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用生成器函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = <span class=\"title function_\">gen</span>();</span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{"link":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}},"cover":"./images/touxiang2.jpg","excerpt":"","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟获取  用户数据  订单数据  商品数据 </span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getUsers</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data1 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data2 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data3 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data4 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data5 = <span class=\"string\">&#x27;用户数据&#x27;</span>;<span class=\"keyword\">let</span> data7 = <span class=\"string\">&#x27;用户数据&#x27;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用 next 方法, 并且将数据传入</span></span><br><span class=\"line\">        iterator.<span class=\"title function_\">next</span>(data);<span class=\"comment\">//这里开始第二次next，并将这个实参data传递给上一个yield返回值</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getOrders</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"string\">&#x27;订单数据&#x27;</span>;</span><br><span class=\"line\">        iterator.<span class=\"title function_\">next</span>(data);<span class=\"comment\">//第三次next</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getGoods</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"string\">&#x27;商品数据&#x27;</span>;</span><br><span class=\"line\">        iterator.<span class=\"title function_\">next</span>(data);<span class=\"comment\">//第四次next</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">gen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> users = <span class=\"keyword\">yield</span> <span class=\"title function_\">getUsers</span>();<span class=\"comment\">//第一次调用next结束，同时执行getUsers()函数</span></span><br><span class=\"line\">    <span class=\"comment\">//函数中第二次调用了next，并传入了实参，这时的实参将返回给上一次yield</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(users);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> orders = <span class=\"keyword\">yield</span> <span class=\"title function_\">getOrders</span>();<span class=\"comment\">//第二次next结束</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(orders);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> goods = <span class=\"keyword\">yield</span> <span class=\"title function_\">getGoods</span>();<span class=\"comment\">//第三次next结束</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(goods);</span><br><span class=\"line\">    <span class=\"comment\">//第四次next结束</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用生成器函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = <span class=\"title function_\">gen</span>();</span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"面试笔记","data":"2022-6-15","description":"这里是description","sticky":1,"copyright_author":"wxb","copyright_author_href":"https://xxxxxx.com","copyright_url":"https://xxxxxx.com","copyright_info":"此文章版权归wxb所有，如有转载，请註明来自原作者","_content":"\n1. 用语义化标签就会标记出每个区域的作用并且更好是实现页面布局\n\n   ```html\n   <header></header>  头部\n   <nav></nav>  导航栏\n   <section></section>  区块（有语义化的div）\n   <main></main>  主要区域\n   <article></article>  主要内容\n   <aside></aside>  侧边栏\n   <footer></footer>  底部\n   ```\n\n   \n\n2. HTML5有哪些更新\n\n   ```\n   （1）新增语义化标签：nav、header、footer、aside、section、article\n   （2）音频、视频标签：audio、video\n   （3）数据存储：localStorage、sessionStorage\n   （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）\n   （5）input标签新增属性：placeholder、autocomplete、autofocus、required\n   （6）history API：go、forward、back、pushstate\n   ```\n   \n   1.语义化标签，使⽤语义类标签增强了可读性，开发者也能够清晰地看出⽹⻚的结构。\n\n   ```\n   ● header：定义文档的页眉（头部）；\n   ● nav：定义导航链接的部分；\n   ● footer：定义文档或节的页脚（底部）；\n   ● article：定义文章内容；\n   ● section：定义文档中的节（section、区段）；\n   ● aside：定义其所处内容之外的内容（侧边）；\n   ```\n   \n   2.媒体标签\n   \n   ```\n   audio：音频\n   video视频\n   source标签\n   ```\n   \n   3.表单\n   \n   ```\n   表单类型\n   - email ：能够验证当前输入的邮箱地址是否合法\n   - url ： 验证URL\n   - number ： 只能输入数字，其他输入不了\n   表单属性：\n    placeholder ：提示信息\n   表单事件：\n   oninput 每当input里的输入框内容发生变化都会触发此事件。\n   oninvalid 当验证不通过时触发此事件。\n   ```\n   \n   4.进度条\n   \n   progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少\n   \n   5.DOM查询操作\n   \n   ```\n   - document.querySelector()\n   - document.querySelectorAll()\n   它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)\n   ```\n   \n   6.Web存储\n   \n   ```\n   HTML5 提供了两种在客户端存储数据的新方法：\n   - localStorage - 没有时间限制的数据存储\n   - sessionStorage - 针对一个 session 的数据存储\n   ```\n\n3. Css选择器的优先级\n\n```\ncss是通过计算这些选择器的权重来去判定他们优先级的高低\n首先用!important的权重最高，之后是内联样式权重为1000，其次是id选择器权重为100，之后是类选择器，伪类选择器，属性选择器的权重都为10，标签选择是1，其余的一些子选择器，后代选择器为0\n\n```\n\n4. 盒子模型的属性\n\n```\nwidth、height、margin、border、padding\n```\n\n5. 对盒模型的理解\n\n```\n标准盒子模型、IE盒子模型\n盒模型都是由四个部分组成的，分别是margin、border、padding和content。\n标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：\n● 标准盒模型的width和height属性的范围只包含了content，\n● IE盒模型的width和height属性的范围包含了border、padding和content。\n可以通过修改元素的box-sizing属性来改变元素的盒模型：\n● box-sizing: content-box表示标准盒模型（默认值）\n● box-sizing: border-box表示IE盒模型（怪异盒模型）\n```\n\n6.CSS3中有哪些新特性\n\n```\n● 新增各种CSS选择器,child来匹配父元素的相应的子元素\n● 圆角 （border-radius:8px）\n●css弹性盒子模型\n● 增加过渡，动画\n```\n\n7.两栏布局的实现\n\n```\n首先3大类：flex弹性布局，绝对定位，浮动\n1.将左右盒子的父盒子display设定为flex，之后将左盒子设定宽度w，右盒子的flex：1(1,1,0%) flex-grow，flex-shrink，flex-basis 使其等比缩放\n2. 父盒子相对定位，左盒子绝对定位并指定宽度，右盒子margin-left值为左盒子宽度值\n                右盒子绝对定位，将右盒子左方向值设定为左盒子的宽度值\n3. 左盒子进行左浮动并设定宽度值，右盒子的margin-left值为左盒子的宽度，右盒子的宽度为auto\n   左盒子进行左浮动并设定负定宽高，右盒子的overflo：hidden\n```\n\n8.三栏布局的实现\n\n```\n有三种形式，flex弹性布局，绝对定位，浮动\n1.将三栏的父盒子的display谁当为flex，左右两栏设定固定的宽度，之后中间栏的flex:1\n2.将三栏的父盒子相对定位，左右盒子绝对定位，分别居于左右两侧，中间栏设定margin-left和margin-right分别为左右两栏的宽度值\n3.将左右盒子分别作左右浮动，中间栏设定margin-left和margin-right分别为左右两栏的宽度值\n```\n\n9.水平垂直居中\n\n```\n我可能知道的不全面，目前我知道有两种方式，flex弹性布局和绝对定位\n1.将父盒子dispaly设定为flex，设定水平轴justify-content:center 还有垂直轴align-items:center\n2.将父盒子相对定位，子盒子绝对定位，将左上方向50%移动至页面中央，最后通过translate或者margin的负值来调整元素中心值至页面中央 \n3.自盒子绝对定位之后，所有方向都为0，最后margin为auto\n```\n\n10.==操作符的强制类型转化规则\n\n```\n1.==首先会看两者的数据类型是否一致\n2.如果不一致的会进行强制转换，首先看是否是null == undefine ,是则返回true\n3.再看是否是string == number ，将string强转为number型在进行对比\n4.再看是否是boolean == number， 将boolean继续转为number\n5.最后如果是一个对象 == 非对象string，则会将该对象通过toPrimitive转为基本数据类型在进行对比\n注意如果是两个对象比较，则是比较的是地址空间，因为对象数组这些引用类型都是存储在堆中的，分配相应的引用地址\n```\n\n11. js的8大数据类型\n\n```\nu are so nb  \nundefined \nsymbol string \nobject \nnumber null \nboolean bigint\n```\n\n12.如何判断一个对象是一个空对象\n\n```\n1.通过Object.keys()获取这个对象的索引数组，如果索引数组长度为0，则表明对象是空对象\n2.通过for in 遍历这个对象，如果这个对象不可遍历 则为空对象\n3.通过Json.stringfy()将对象转为字符串，并于 =='{}'比较\n```\n\n13.es6\n\n```\n1.增加了let，const关键字\n    1.有了块级作用域的特点（变量的覆盖，变量泄露）\n    2.没有变量提升，必须声明后才能使用\n    3.var 用来声明全局变量 \n    4.var，let都可以改变其指针指向，但const无法修改它的指针指向且必须赋初始值\n    5.var可以重复声明，但let和const不允许重复声明\n2.箭头函数\n3.扩展运算符... 用户合并数组或者合并对象\n4.rest参数...args  可以是用来接收剩余不确定个数的参数，将其存放在一个数组中\n5.模板字符串\n6.数组或对象的解构赋值\n7.模块化 可以避免命名冲突，提高代码复用，利于维护\n8.for of 遍历 (\n\t1.for of遍历的是键值，for in 遍历的键名\n\t2.for of只会遍历当前对象\n\t3.for in适合遍历对象，for of适合遍历数组（因为of必须要求需要有迭代器，所以他不能迭代对象）。for in遍历的是数组的索引，对象的属性，以及原型链上的属性。\n)\n9.async 和 await ，async返回一个Promise期约对象，常用于一个ajax请求，异步等待请求的结果，并对请求结果返回的Promise进行一些处理\n10.Promise期约（fulfilled，rejected，Pending（进行中））\n```\n\n14.箭头函数this的指向\n\n```\n1. 首先箭头函数没有自己的this，箭头函数定义的位置的外部最近的一个this就是他的this\n2. 对于普通函数来说他的this指向的是调用者，谁调用就指向谁，可以是window，可以是对象，只看是谁调用，不看他定义在哪个位置\n3. 切记箭头函数如果定义在一个对象里面，那么他应该还需要再去外层找，因为对象的{}不是一个作用域\n```\n\n15.axios\n\n```\naxios是通过Promise实现对ajax技术的一种封装\n    1. 浏览器端发起XMLHttpRequests请求\n    2. 支持Promise API\n    3. 监听请求和返回\n    4. 自动转换json数据\n    5. 支持拦截请求和响应\n```\n\n16.ajax\n\n```\najax的全称是async javascript xml 异步的js和xml\n1、什么是ajax\n\tAjax是对原生XHR的封装，发送一个异步请求，不用刷新网页\n2、ajax的原理？\n\t客户端通过ajax向服务器发起请求，服务器作出响应之后返回给客户端，客户端接收到数据后，实现页面无刷新更新数据\n3. ajax请求的五个步骤\n    1. 创建XMLHttpRequest异步对象xml\n    2. open初始化 设置请求方法和 url，请求参数\n    3. send发送数据\n    4. 绑定事件回调，处理服务端返回的结果\n    5. 在回调函数中针对不同的响应状态进行处理（首先会判断xml状态为4，之后再判断返回的相应状态码200-300）\n4.他的缺点：\n\t1.安全问题 ajax暴露了与服务器交互的细节\n\t2.ajax不能很好的支持移动设备\n\t3.ajax不能使用Back和history功能，即对浏览器机制的破坏。\n```\n\n17.跨域\n\n```\n1.什么跨域？当违背了ajax的同源策略即为跨域\n\t请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域,其实这是浏览器的一种同源策略(Same origin policy)，为了减小网络攻击\n2.解决跨域的方法：\n    前端解决：3种\n        1.jsonp jsonp实现跨域的本质是通过script标签的src属性在引入外部资源时，不受到同源限制的特点来实现的，但是只能解决get请求，要求前后端配合写法\n        2.利用代理服务器---WebPack-proxy会启动一个本地开发的服务器，即跨域所使用的代理服务器，代理服务器会响应本地请求，继而转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，代理服务器再将数据返回给本地。\n        在此阶段中不涉及任何跨域问题，因为代理服务器跟本地同源，而服务器之间不存在跨域问题，跨域问题是浏览器安全策略限制\n        3.Nginx反向代理，但这个我目前还不是很了解，只是知道有这种方法\n    后端解决：\n        cros： cors 真正解决了跨域问题，只需要在服务端设置响应头允许跨域即可\n\t\n```\n\n18.对原型的理解\n\n```\nJavaScript使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法\n```\n\n19.原型链\n\n```\n每个构造函数都有一个prototype的原型对象，通过构造函数得到的实例化对象具有__proto__属性并指向该构造函数的原型对象，而原型对象上的constructor又指向对应的构造函数，对于该构造函数的原型对象也可以理解为时Object的实例化对象，他的__proto__指向的是Object构造函数的原型对象，而object的原型对象的__proto__指向原型链的终点null\n```\n\n20.闭包\n\n```\n闭包就是一个作用域引用了另一个作用域的变量或者方法，因为存在引用，所以被引用变量所在的作用域就不会被垃圾回收机制，因此就形成了闭包。\n作用：\n 1. 可以延申变量的作用域范围\n 2. 用于保存数据，因为闭包中变量被引用，所以不会被垃圾回收机制回收\n```\n\n21.异步编程\n\n```\navaScript中的异步机制可以分为以下几种：\n● 回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\n● Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\n● async await\n```\n\n22.垃圾回收\n\n```\n1.什么是垃圾回收：js代码运行中，系统需要分配内存空间给这些变量和值，当他们不在被使用的时候，系统就需要释放掉他们之前占用的内存空间\n2.垃圾回收的机制：js具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存\n3.垃圾回收的方式(两种)\n\t1.标记清除：当变量在被使用时，会被浏览器标记为’进入环境‘，当变量不再被使用时，会被重新标记为’离开环境‘，标记为离开环境的变量会被内存释放\n\t2.引用计数：变量每被引用一次时，引用次数会加1，当该变量的引用次数为0时，这时该变量会被内存释放\n4.内存泄漏\n```\n\n23.内存泄漏\n\n```\n内存泄漏：就是一个变量该让他释放内存空间的时候没有被释放，始终占用着内存\n什么情况下会发生内存泄漏：\n\t1.不合理的使用闭包，因为在闭包中会发生内部函数对外部变量的引用，该变量会因为这个引用的存在而不会被垃圾回收机制清除\n\t2.遗忘的定时器，对于设定的某个循环定时器但是忘记取消他，该定时器若是有对外部变量的引用时，这时该变量所占用的内存也不会被回收\n\t3. 意外的全局变量，使用了未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n\t4.脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收\n```\n\n24.Vue中的双向绑定原理\n\n```\n1. Observer实现对MVVM自身model数据劫持（底层是通过Object.defineProperty()为对data里的数据进行递归的添加getter和setter），监听数据的属性变更，并在变动时进行notify\n2. Compile实现指令解析，初始化视图，并订阅数据变化，绑定好更新函数\n3. Watcher（订阅者）一方面接收Observer通过dep(消息订阅器)传递过来的数据变化，一方面通知Compile进行view update\nMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果\n```\n\n25.MVVM、MVC、MVP的区别\n\n```\nMVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。\n\t1. MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。(注意在MVC中 model和view是耦合的，可以相互直接通信)\n\t2. MVVM 分为 Model、View、ViewModel：\n\t\t1.Model代表数据模型，数据和业务逻辑都在Model层中定义；\n\t\t2.View代表UI视图，负责数据的展示；\n\t\t3.ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；\t\n\t\tModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM\n\t3.MVP View和Model之间不能直接进行交互，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部\n```\n\n26.computed和watch的区别\n\n```\ncomputed:\n\t1. 他是基于响应式依赖(data和props里面的数据)进行缓存的，当依赖的数据发生变化时，下一次获取 computed 的值时才会重新计算 computed 的值\n\t2. 不支持异步操作，当computed中有异步操作时，无法监听到数据的变化\nwatch：\n\t1. 不支持缓存，只要监听的数据(data和props里面的数)发生变化，就会执行对应的handler回调\n\t2. 支持异步监听\n两者的应用场景：\n\t1.computed：当想要获取的数据是依赖于其他数据计算出来的，这时候可以利用computed的缓存特点(只要他依赖的数据没变，那么这个数据他就不会变化直接从缓存取出来即可)，可以不用每次获取这个数据时就重新计算一次了\n\t2.watch：当想要对某个数据变化时进行实时监听并进行一些异步操作(例如API请求)，这时就需要通过watch进行操作\n```\n\n27.computed和methods\n\n```\ncomputed：他是基于响应式依赖进行缓存的，就是说只有当所依赖的数据发生变化的时候，才会重新计算新的computed值\nmethods：只要调用了就会执行该函数\n```\n\n28.v-if和v-show的区别\n\n```\n1.方法：v-if是动态的给dom树添加或删除dom元素，v-show是将样式display设置为none\n2.原理：v-if在生成虚拟dom的时候会忽略掉这个虚拟节点vnode，之后再render渲染真实dom的时候也就没有了该节点\n       v-show生成虚拟dom的时候会生成这个虚拟节点，render渲染成真实dom，并将该节点的样式display设置为none\n3.特点：v-if如果初始条件为flase时，是不会被编译（加快页面加载速度），只有变为true时才会被编译\n       v-show无论初始条件为true还是false，都会被编译，并生成真实的dom元素\n4.使用场景：v-if适用于低频的的切换，v-show适合高频的显示隐藏切换\n```\n\n29.v-model的原理，语法糖的本质是什么\n\n```\nv-model是对表单或者组件的一种双向绑定的语法糖，本质是v-bind和v-on的语法糖\n● v-bind绑定响应数据\n● 触发事件并传递数据\n其中v-bind是对model层对view层的单向绑定，加上了v-on(进行一些函数操作，通过event.target.value获取当前触发事件的元素值)后又实现了view层对model的单向绑定，两者结合实现了model与view的双向绑定\n```\n\n30.单页面应用和多页面应用\n\n```\n● SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用路由跳转，只是切换到相关的组件，仅仅刷新局部资源。\n● MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。\nSPA的优点：\n\t1. 页面相应速度块，用户体验优，因为不需要一直跳转网页\n\t2. 因为不需要重复加载资源，所以spa可以减小服务器的压力\n\t3. 前后端分离，架构清晰，前端进行交互逻辑，后端股则负责数据处理\n\t缺点：\n\t1. 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载\t\n```\n\n31. v-if和v-for哪一个优先级更高？如果同时出现，需要怎么做？\n\n```\n对于vue2来说v-for的优先级会更高，总是会优先执行循环再去判断，尽量使不要同时出现，会浪费性能，因为循环不可避免，所以每次都要进行if判断\n解决方式是在外面嵌套一层v-if，里面使用v-for\n```\n\n32.前端性能优化\n\n```\n1. 路由和图片的懒加载\n2. v-for和v-if避免同时使用\n3. 第三方插件按需引入\n4.keep-alive缓存页面\n```\n\n33.Vue生命周期\n\n```\n每一个组件都需要经过创建，初始化，挂载，更新，销毁这些声明周期\n1.beforeCreate()\n\t初始化事件和生命周期函数,数据代理还未开始，此时无法访问data，computed，watch，methods\n2.created()\n\tvue实例vm创建完成，vm上的配置：data，computed，watch，methods已经配置完成，可以访问得到\n3.beforeMount()\n\t在挂载之前调用，相关的render函数首次被调用，解析模板生成虚拟dom，但此时还未挂载到真实页面上\n4.mounted()\n\t将内存中的虚拟dom转为真实dom并挂载到真实页面中，此时可以进行一些异步请求(网上有很多说在created中，但我在实际项目中，还是在mounted钩子中异步请求)，开启定时器，绑定自定义事件等等\n5.beforeUpdated()\n\t响应式数据更新时调用，这时数据已经更新了，但是真实dom还未被渲染，此时页面和数据尚未同步\n6.updated()\n\t新旧的虚拟dom进行对比，进行页面更新，此时页面和数据已经同步\n7.beforeDestroy()\n\t实例vm销毁之前调用，这时vm仍然可用，this仍可以获取到实例，在此阶段一般关闭定时器，解绑自定义事件等等\n8.destroyed()\n\t实例销毁后调用，解绑指令和移除事件监听，子实例也会被销毁\n```\n\n34.keep-alive中的生命周期有哪些\n\n```\nkeep-alive用来缓存组件，在组件切换的时候将状态保留在缓存中，防止重复渲染dom\n如果为一个组件包裹keep-alive，那么他就会多出两个生命周期函数：deactivated，activated同时beforeDestroy和destroyed两个钩子也不会执行了，因为组件不会被销毁\n当组件被换掉时，他会保留在缓存中并触发deactivated钩子，当组件被切回来时，再去缓存中找到该组件，并触发activated钩子\n```\n\n35.组件间通信\n\n```\n1.父给子传递数据：利用pros\n\t子组件通过pros属性来接收父组件传递过来的数据\n2.子给父传递数据：利用自定义事件\n\t$on/$emit，其中在父组件中绑定自定义事件@name='callback'，并定义相应的回调函数用来接收子组件传递的数据(若是父组件直接在标签内就绑定了，就不用再通过$on去绑定了),子组件就需要通过$emit('name',params)，来触发相应的自定义事件name，并将所要传递的数据params通过参数传递\n3.任意组件之间传递(也可兄弟组件)：全局事件总线$bus,在vue实例身上安装$bus，这样所有的组件实例对象都可以通过原型链向上找到这个$bus\n\t接收数据的组件需要绑定事件，在自身的组件中的$bus.$on去绑定事件\n\t提供数据的组件需要触发事件，在自身的组件中的$bus.$emit来触发该事件，并传递数据\n```\n\n36.路由的懒加载\n\n```\n为了避免在webpack打包时，JavaScript变得非常大，影响页面加载，这时可以利用路由懒加载\n原理：它是将路由对应的组件打包成一个个js代码块，当该路由被访问的时候才会去加载对应的组件，否则不加载\n实现的三种方式：\n\t1.利用箭头函数+import()动态加载\n\t2.利用箭头函数+require()动态加载\n\t3.利用webpack的require.ensure技术\n```\n\n37.路由的两种工作模式\n\n```\nhash模式和history模式\n1.hash模式\n\t在url中会有/#，但是hasn值(#及其后面的内容)不会包含在http请求中，也就是不会将这些信息带给服务器\n\t他的地址中一直带着#，但是兼容性好，也是默认的路由模式\n2.history模式\n\turl地址干净美观，但是兼容性较差，需要后端人员支持，解决刷新页面服务器端404问题\n\tAPI：包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。\n```\n\n\n\n38.两种工作模式的对比\n\n```\n1.对于history.pushState()修改浏览器的历史记录栈，对比直接修改hasn值，有以下好处\n\t1.pushState可以修改与当前url同源的任意路径，但是hash只能修改#之后的内容，也就是只能设置和当前url同文档的url\n\t2.pushState设置的新的url可以和当前url一致，会把该记录加入到栈中；但是hash必须要求新的url与当前不同才会把记录加入到栈中\n2. 在hash模式中，#之前的内容都会放在http请求中，即使后端没有对路由进行全覆盖，也不会返回404的错误\n\t在history模式中，必须要求前端的url和向后端发起请求的url保持一致，后端如果没有对使用的路由处理，会有404的错误\n```\n\n39. $route 和$router的区别\n\n```\n$route是路由实例对象，包含了路由跳转方法，钩子函数（导航守卫）等\n$router是路由信息对象，包含了name，path，fullPath，query，params等路由信息参数\n```\n\n40.常见的http请求方法有哪些？\n\n```\nget:向服务器请求数据\npost：携带数据向服务器发起请求，最终会在服务器端创建新的数据（重点是创建新的数据，例如注册用户业务）\nput：上传数据，更新服务器的数据（重点是更新数据）\ndelete：删除服务器上的数据\nhead：获取报文的首部，与get相比不返回相应实体数据\noptions：询问服务器支持的请求方法，用来跨域请求\ntrace：回显服务器收到的请求，用于测试或诊断\n```\n\n41.get和post请求的区别\n\n```\n1.应用场景：get用于不需要对服务器资源产生影响的场景，仅仅只用来获取数据\n\t        post用于需要对服务器资源产生影响的场景，最终服务器端会产生新的数据（例如用户注册业务）\n2.发送的报文格式：get请求报文实体部分为空\n\t             post的请求报文实体部分一般是向服务器发送的数据\n3.安全性：get请求的中参数会放在url中向服务器发送过去，这种相对于post来说是不安全的\n4.参数类型：post请求中参数传递支持更多的数据\n```\n\n42.常见的http请求头和响应头\n\n```\n1. 请求头：\n        1. Accept-Charset:浏览器能够显示的字符集\n        2. Accept-Encoding：浏览器能够处理的压缩编码\n        3. Accept-Language：浏览器当前设置的语言(可接受的字符集，编码，语言)\n        4. Host：请求将被发送的目的地（仅包括域名+端口号）\n        5. Origin 用来说明请求从哪里发起的（仅包括协议和域名）\n2.响应头：\n\t\t1. Date：表示响应消息发出的时间\n\t\t2. server：表示服务器的名称\n\t\t3. Allow：服务器支持那些请求方法\n\t\t4. Access-Control-Allow-Origin：哪些网站跨域\n\t\t5. Content-Encoding：响应资源的编码\n\t\t6. Content-Language:响应资源的语言\n```\n\n43.http和https协议的区别\n\n```\n1.https是超文本传输安全协议（他是在http的基础上通过加密传输和身份验证来保证传输的安全性），需要CA证书，费用很高，但\thttp不需要\n2.http是超文本传输协议，信息是明文传输的，而https是通过SSL加密传输的更安全\n3.使用的端口号不同，http默认端口为80，https默认端口为443\n4.https通过加密传输和身份验证来保证传输安全，对比http更安全\n```\n\n44.当用户在浏览器中输入www.google.com会发生什么\n\n```\n1.解析URL，分析所使用的传输协议和请求资源的路径\n2.缓存判断，看请求的资源是否在缓存中，如果请求的资源在缓存中且没有失效就直接使用，否则就向服务器发起请求\n3.DNS解析，dns服务器将url解析为对应的ip地址\n4.获取MAC地址，浏览器得到ip地址后，还需要知道目的主机的mac地址，网络层下发至链路层时使用\n5.TCP建立连接（三次握手），通过三次握手保证客户端和服务器都能保证自己发送数据和接收数据的能力，并建建立起连接\n6.HTTPS握手，如果https协议，那么还存在一个TLS的四次握手，四次握手之后客户端和服务器通过握手得到的3个随机数进行加密得到密钥，以后双方通过该密钥进行通信\n7.返回数据，服务器返回一个html文件作为响应，浏览器接收到响应后，开始页面渲染\n8.页面渲染，浏览器根据html构建dom树，最后渲染出整个页面\n9.TCP断开连接（四次挥手），四次挥手后，客户端和服务器双方断开连接，结束所有通信\n```\n\n45.http的请求报文和响应报文\n\n```\n1.请求报文\n\t\t请求行：请求方法，url，http协议版本\n\t\t请求头：key：value形式\n\t\t空行\n\t\t请求体：post，put等请求携带的数据\n2.响应报文\n\t\t响应行：协议版本，状态码，状态码原因短语\n\t\t响应头：key：value\n\t\t空行\n\t\t响应体：服务器响应的数据\n```\n\n46.三次握手和四次挥手\n\n```\n1.三次握手：客户端和服务器建立TCP连接时，需要三次握手，来保证双方发送和接收数据的能力\n\t\t客户端向服务器发送syn连接请求报文，\n\t\t服务器收到请求后向客户端发送syn和ack报文，确认本次连接请求，\n\t\t客户端接收到确认应答后，进入连接状态，同时也向服务器发送一个ack确认报文，服务器收到该确认后，也进入连接状态，\n\t\t至此双方的连接建立完成\n2.四次挥手：客户端和服务器断开TCP连接时，需要进行四次挥手\n\t\t客户端向服务器发送fin断开请求报文\n\t\t服务器收到请求后向客户端发送ack报文，确认本次断开连接请求（但是TCP是全双工，也就是说此时服务器又可能还有数据要传给客户端）\n\t\t所以双方想要断开连接，服务器还需再一次向客户端发送一个fin断开连接请求报文，\n\t\t客户端收到报文后，向服务器发送ack确认报文，自己进入超时等待\n\t\t服务端收到ack报文后，就立即关闭连接，之后客户端继续等待超时时间，若是中间没有来自服务器的数据，此时客户端也关闭连接，否则重置超时时间\n```\n\n47.针对于https中的四次握手（利用中间的三次随机数加密形成密钥进行通信）\n\n```\n四次握手：客户端向服务器发起请求，包括一个随机数和加密方法\n\t\t服务器收到请求后，给出服务器证书，确认加密方法，并生成一个随机数这些都再次传给客户端\n\t\t客户端收到后，确认证书有效，并生成一个随机数，利用证书来加密该随机数并发送给服务器\n\t\t服务器收到后，解密该随机数\n\t\t此时双方已经三个随机数了，之后双方通过约定的加密方法对三个随机数进行加密，形成密钥进行通信\n```\n\n48.http状态码\n\n```\n2xx 成功状态码，表示请求正常处理完毕\n\t \t200：ok，表示客户端的请求已经被服务器正常处理了\n3xx 重定向，表示需要附加操作完成请求\n\t \t301：永久重定向，表示请求的资源已经被分配到了新的uri\n\t \t302：临时重定向，表示请求的资源被临时分配到新的uri，希望用户使用新的uri访问资源\n4xx 客户端错误，服务器无法处理请求\n\t \t400：表示报文存在语法错误\n\t \t403：表示访问资源的请求被服务器拒绝了\n\t \t404：服务器无法找到请求的资源\n5xx 服务器错误，服务器处理请求出错\n\t \t500：表示服务端在处理请求时发生错误\n\t \t503：表示服务器暂时处于超负载或停机维护，无法处理请求\n```\n\n49.网络模型\n\n```\n1.OSI七层\n\t应用层-表示层-会话层-运输层-网络层-链路层-物理层\n2.TCP/IP五层\n\t应用层-传输层-网络层-链路层-物理层\n\t应用层：如 HTTP协议，https协议、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）\n\t传输层：UDP和TCP\n\t网络层：选择合适的路由将数据传递给目的主机\n\t数据链路层：将网络层传递下来的ip数据报封装成帧，在链路传送帧\n\t物理层：物理介质的传输\n```\n\n50.TCP和UDP的区别\n\n```\ntcp和udp都时传输层的协议，都属于tcp/ip协议族\n\ttcp提供的是面向连接的，可靠的数据传输服务，数据传输的单位是报文段，适用于精确传输，例如文件传输\n\tudp提供的是无连接的，尽最大努力的数据传输服务，但不保证数据的可靠性，数据传输的单位是用户数据报，适用于要求精确度较低的场景，例如视频聊天，即时通话\n```\n\n51.TCP的拥塞控制机制\n\n```\ntcp的拥塞控制主要通过慢开始，拥塞避免，快速重传，快速恢复四个机制\n\t1.首先是慢开始，设定拥塞窗口=1，最后逐渐增加拥塞窗口的大小，设定一个慢开始门限(当拥塞窗口达到这个门限后，就不会执行慢开始了，而是进入拥塞避免阶段)\n\t2.当拥塞窗口>慢开始门限，进入拥塞避免阶段，此阶段拥塞窗口线性增长，每次自增1，当发送方判断网络出现了拥塞后，将慢开始门限调整为本次出现拥塞窗口的一半，将这时的拥塞窗口重置为1，重新开始慢开始算法\n\t3.快重传，当接收方收到一个失序的报文段时就立即发出重复确认，发送到只要连续收到三个重复确认就袭击重传对方缺失的报文段\n\t4.快恢复，当发送放执行了快重传后，会将慢开始门限和下一次的拥塞窗口调整为本次拥塞窗口的一半，这时直接进入拥塞避免阶段\n```\n\n面试【高频的面试】:项目的性能优化手段有哪些？\n\n```\nv-if|v-show:尽可能采用v-show\n按需引入【lodash、elementUI】\n防抖与节流\n路由懒加载：当用户访问的时候，加载对应组件进行展示。\n```\n\n\n\n","source":"_posts/面试笔记.md","raw":"---\ntitle: 面试笔记\ndata: '2022-6-15'\ndescription: '这里是description'\nsticky: 1\ncopyright_author: wxb\ncopyright_author_href: https://xxxxxx.com\ncopyright_url: https://xxxxxx.com\ncopyright_info: 此文章版权归wxb所有，如有转载，请註明来自原作者\n---\n\n1. 用语义化标签就会标记出每个区域的作用并且更好是实现页面布局\n\n   ```html\n   <header></header>  头部\n   <nav></nav>  导航栏\n   <section></section>  区块（有语义化的div）\n   <main></main>  主要区域\n   <article></article>  主要内容\n   <aside></aside>  侧边栏\n   <footer></footer>  底部\n   ```\n\n   \n\n2. HTML5有哪些更新\n\n   ```\n   （1）新增语义化标签：nav、header、footer、aside、section、article\n   （2）音频、视频标签：audio、video\n   （3）数据存储：localStorage、sessionStorage\n   （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）\n   （5）input标签新增属性：placeholder、autocomplete、autofocus、required\n   （6）history API：go、forward、back、pushstate\n   ```\n   \n   1.语义化标签，使⽤语义类标签增强了可读性，开发者也能够清晰地看出⽹⻚的结构。\n\n   ```\n   ● header：定义文档的页眉（头部）；\n   ● nav：定义导航链接的部分；\n   ● footer：定义文档或节的页脚（底部）；\n   ● article：定义文章内容；\n   ● section：定义文档中的节（section、区段）；\n   ● aside：定义其所处内容之外的内容（侧边）；\n   ```\n   \n   2.媒体标签\n   \n   ```\n   audio：音频\n   video视频\n   source标签\n   ```\n   \n   3.表单\n   \n   ```\n   表单类型\n   - email ：能够验证当前输入的邮箱地址是否合法\n   - url ： 验证URL\n   - number ： 只能输入数字，其他输入不了\n   表单属性：\n    placeholder ：提示信息\n   表单事件：\n   oninput 每当input里的输入框内容发生变化都会触发此事件。\n   oninvalid 当验证不通过时触发此事件。\n   ```\n   \n   4.进度条\n   \n   progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少\n   \n   5.DOM查询操作\n   \n   ```\n   - document.querySelector()\n   - document.querySelectorAll()\n   它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)\n   ```\n   \n   6.Web存储\n   \n   ```\n   HTML5 提供了两种在客户端存储数据的新方法：\n   - localStorage - 没有时间限制的数据存储\n   - sessionStorage - 针对一个 session 的数据存储\n   ```\n\n3. Css选择器的优先级\n\n```\ncss是通过计算这些选择器的权重来去判定他们优先级的高低\n首先用!important的权重最高，之后是内联样式权重为1000，其次是id选择器权重为100，之后是类选择器，伪类选择器，属性选择器的权重都为10，标签选择是1，其余的一些子选择器，后代选择器为0\n\n```\n\n4. 盒子模型的属性\n\n```\nwidth、height、margin、border、padding\n```\n\n5. 对盒模型的理解\n\n```\n标准盒子模型、IE盒子模型\n盒模型都是由四个部分组成的，分别是margin、border、padding和content。\n标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：\n● 标准盒模型的width和height属性的范围只包含了content，\n● IE盒模型的width和height属性的范围包含了border、padding和content。\n可以通过修改元素的box-sizing属性来改变元素的盒模型：\n● box-sizing: content-box表示标准盒模型（默认值）\n● box-sizing: border-box表示IE盒模型（怪异盒模型）\n```\n\n6.CSS3中有哪些新特性\n\n```\n● 新增各种CSS选择器,child来匹配父元素的相应的子元素\n● 圆角 （border-radius:8px）\n●css弹性盒子模型\n● 增加过渡，动画\n```\n\n7.两栏布局的实现\n\n```\n首先3大类：flex弹性布局，绝对定位，浮动\n1.将左右盒子的父盒子display设定为flex，之后将左盒子设定宽度w，右盒子的flex：1(1,1,0%) flex-grow，flex-shrink，flex-basis 使其等比缩放\n2. 父盒子相对定位，左盒子绝对定位并指定宽度，右盒子margin-left值为左盒子宽度值\n                右盒子绝对定位，将右盒子左方向值设定为左盒子的宽度值\n3. 左盒子进行左浮动并设定宽度值，右盒子的margin-left值为左盒子的宽度，右盒子的宽度为auto\n   左盒子进行左浮动并设定负定宽高，右盒子的overflo：hidden\n```\n\n8.三栏布局的实现\n\n```\n有三种形式，flex弹性布局，绝对定位，浮动\n1.将三栏的父盒子的display谁当为flex，左右两栏设定固定的宽度，之后中间栏的flex:1\n2.将三栏的父盒子相对定位，左右盒子绝对定位，分别居于左右两侧，中间栏设定margin-left和margin-right分别为左右两栏的宽度值\n3.将左右盒子分别作左右浮动，中间栏设定margin-left和margin-right分别为左右两栏的宽度值\n```\n\n9.水平垂直居中\n\n```\n我可能知道的不全面，目前我知道有两种方式，flex弹性布局和绝对定位\n1.将父盒子dispaly设定为flex，设定水平轴justify-content:center 还有垂直轴align-items:center\n2.将父盒子相对定位，子盒子绝对定位，将左上方向50%移动至页面中央，最后通过translate或者margin的负值来调整元素中心值至页面中央 \n3.自盒子绝对定位之后，所有方向都为0，最后margin为auto\n```\n\n10.==操作符的强制类型转化规则\n\n```\n1.==首先会看两者的数据类型是否一致\n2.如果不一致的会进行强制转换，首先看是否是null == undefine ,是则返回true\n3.再看是否是string == number ，将string强转为number型在进行对比\n4.再看是否是boolean == number， 将boolean继续转为number\n5.最后如果是一个对象 == 非对象string，则会将该对象通过toPrimitive转为基本数据类型在进行对比\n注意如果是两个对象比较，则是比较的是地址空间，因为对象数组这些引用类型都是存储在堆中的，分配相应的引用地址\n```\n\n11. js的8大数据类型\n\n```\nu are so nb  \nundefined \nsymbol string \nobject \nnumber null \nboolean bigint\n```\n\n12.如何判断一个对象是一个空对象\n\n```\n1.通过Object.keys()获取这个对象的索引数组，如果索引数组长度为0，则表明对象是空对象\n2.通过for in 遍历这个对象，如果这个对象不可遍历 则为空对象\n3.通过Json.stringfy()将对象转为字符串，并于 =='{}'比较\n```\n\n13.es6\n\n```\n1.增加了let，const关键字\n    1.有了块级作用域的特点（变量的覆盖，变量泄露）\n    2.没有变量提升，必须声明后才能使用\n    3.var 用来声明全局变量 \n    4.var，let都可以改变其指针指向，但const无法修改它的指针指向且必须赋初始值\n    5.var可以重复声明，但let和const不允许重复声明\n2.箭头函数\n3.扩展运算符... 用户合并数组或者合并对象\n4.rest参数...args  可以是用来接收剩余不确定个数的参数，将其存放在一个数组中\n5.模板字符串\n6.数组或对象的解构赋值\n7.模块化 可以避免命名冲突，提高代码复用，利于维护\n8.for of 遍历 (\n\t1.for of遍历的是键值，for in 遍历的键名\n\t2.for of只会遍历当前对象\n\t3.for in适合遍历对象，for of适合遍历数组（因为of必须要求需要有迭代器，所以他不能迭代对象）。for in遍历的是数组的索引，对象的属性，以及原型链上的属性。\n)\n9.async 和 await ，async返回一个Promise期约对象，常用于一个ajax请求，异步等待请求的结果，并对请求结果返回的Promise进行一些处理\n10.Promise期约（fulfilled，rejected，Pending（进行中））\n```\n\n14.箭头函数this的指向\n\n```\n1. 首先箭头函数没有自己的this，箭头函数定义的位置的外部最近的一个this就是他的this\n2. 对于普通函数来说他的this指向的是调用者，谁调用就指向谁，可以是window，可以是对象，只看是谁调用，不看他定义在哪个位置\n3. 切记箭头函数如果定义在一个对象里面，那么他应该还需要再去外层找，因为对象的{}不是一个作用域\n```\n\n15.axios\n\n```\naxios是通过Promise实现对ajax技术的一种封装\n    1. 浏览器端发起XMLHttpRequests请求\n    2. 支持Promise API\n    3. 监听请求和返回\n    4. 自动转换json数据\n    5. 支持拦截请求和响应\n```\n\n16.ajax\n\n```\najax的全称是async javascript xml 异步的js和xml\n1、什么是ajax\n\tAjax是对原生XHR的封装，发送一个异步请求，不用刷新网页\n2、ajax的原理？\n\t客户端通过ajax向服务器发起请求，服务器作出响应之后返回给客户端，客户端接收到数据后，实现页面无刷新更新数据\n3. ajax请求的五个步骤\n    1. 创建XMLHttpRequest异步对象xml\n    2. open初始化 设置请求方法和 url，请求参数\n    3. send发送数据\n    4. 绑定事件回调，处理服务端返回的结果\n    5. 在回调函数中针对不同的响应状态进行处理（首先会判断xml状态为4，之后再判断返回的相应状态码200-300）\n4.他的缺点：\n\t1.安全问题 ajax暴露了与服务器交互的细节\n\t2.ajax不能很好的支持移动设备\n\t3.ajax不能使用Back和history功能，即对浏览器机制的破坏。\n```\n\n17.跨域\n\n```\n1.什么跨域？当违背了ajax的同源策略即为跨域\n\t请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域,其实这是浏览器的一种同源策略(Same origin policy)，为了减小网络攻击\n2.解决跨域的方法：\n    前端解决：3种\n        1.jsonp jsonp实现跨域的本质是通过script标签的src属性在引入外部资源时，不受到同源限制的特点来实现的，但是只能解决get请求，要求前后端配合写法\n        2.利用代理服务器---WebPack-proxy会启动一个本地开发的服务器，即跨域所使用的代理服务器，代理服务器会响应本地请求，继而转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，代理服务器再将数据返回给本地。\n        在此阶段中不涉及任何跨域问题，因为代理服务器跟本地同源，而服务器之间不存在跨域问题，跨域问题是浏览器安全策略限制\n        3.Nginx反向代理，但这个我目前还不是很了解，只是知道有这种方法\n    后端解决：\n        cros： cors 真正解决了跨域问题，只需要在服务端设置响应头允许跨域即可\n\t\n```\n\n18.对原型的理解\n\n```\nJavaScript使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法\n```\n\n19.原型链\n\n```\n每个构造函数都有一个prototype的原型对象，通过构造函数得到的实例化对象具有__proto__属性并指向该构造函数的原型对象，而原型对象上的constructor又指向对应的构造函数，对于该构造函数的原型对象也可以理解为时Object的实例化对象，他的__proto__指向的是Object构造函数的原型对象，而object的原型对象的__proto__指向原型链的终点null\n```\n\n20.闭包\n\n```\n闭包就是一个作用域引用了另一个作用域的变量或者方法，因为存在引用，所以被引用变量所在的作用域就不会被垃圾回收机制，因此就形成了闭包。\n作用：\n 1. 可以延申变量的作用域范围\n 2. 用于保存数据，因为闭包中变量被引用，所以不会被垃圾回收机制回收\n```\n\n21.异步编程\n\n```\navaScript中的异步机制可以分为以下几种：\n● 回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\n● Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\n● async await\n```\n\n22.垃圾回收\n\n```\n1.什么是垃圾回收：js代码运行中，系统需要分配内存空间给这些变量和值，当他们不在被使用的时候，系统就需要释放掉他们之前占用的内存空间\n2.垃圾回收的机制：js具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存\n3.垃圾回收的方式(两种)\n\t1.标记清除：当变量在被使用时，会被浏览器标记为’进入环境‘，当变量不再被使用时，会被重新标记为’离开环境‘，标记为离开环境的变量会被内存释放\n\t2.引用计数：变量每被引用一次时，引用次数会加1，当该变量的引用次数为0时，这时该变量会被内存释放\n4.内存泄漏\n```\n\n23.内存泄漏\n\n```\n内存泄漏：就是一个变量该让他释放内存空间的时候没有被释放，始终占用着内存\n什么情况下会发生内存泄漏：\n\t1.不合理的使用闭包，因为在闭包中会发生内部函数对外部变量的引用，该变量会因为这个引用的存在而不会被垃圾回收机制清除\n\t2.遗忘的定时器，对于设定的某个循环定时器但是忘记取消他，该定时器若是有对外部变量的引用时，这时该变量所占用的内存也不会被回收\n\t3. 意外的全局变量，使用了未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n\t4.脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收\n```\n\n24.Vue中的双向绑定原理\n\n```\n1. Observer实现对MVVM自身model数据劫持（底层是通过Object.defineProperty()为对data里的数据进行递归的添加getter和setter），监听数据的属性变更，并在变动时进行notify\n2. Compile实现指令解析，初始化视图，并订阅数据变化，绑定好更新函数\n3. Watcher（订阅者）一方面接收Observer通过dep(消息订阅器)传递过来的数据变化，一方面通知Compile进行view update\nMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果\n```\n\n25.MVVM、MVC、MVP的区别\n\n```\nMVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。\n\t1. MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。(注意在MVC中 model和view是耦合的，可以相互直接通信)\n\t2. MVVM 分为 Model、View、ViewModel：\n\t\t1.Model代表数据模型，数据和业务逻辑都在Model层中定义；\n\t\t2.View代表UI视图，负责数据的展示；\n\t\t3.ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；\t\n\t\tModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM\n\t3.MVP View和Model之间不能直接进行交互，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部\n```\n\n26.computed和watch的区别\n\n```\ncomputed:\n\t1. 他是基于响应式依赖(data和props里面的数据)进行缓存的，当依赖的数据发生变化时，下一次获取 computed 的值时才会重新计算 computed 的值\n\t2. 不支持异步操作，当computed中有异步操作时，无法监听到数据的变化\nwatch：\n\t1. 不支持缓存，只要监听的数据(data和props里面的数)发生变化，就会执行对应的handler回调\n\t2. 支持异步监听\n两者的应用场景：\n\t1.computed：当想要获取的数据是依赖于其他数据计算出来的，这时候可以利用computed的缓存特点(只要他依赖的数据没变，那么这个数据他就不会变化直接从缓存取出来即可)，可以不用每次获取这个数据时就重新计算一次了\n\t2.watch：当想要对某个数据变化时进行实时监听并进行一些异步操作(例如API请求)，这时就需要通过watch进行操作\n```\n\n27.computed和methods\n\n```\ncomputed：他是基于响应式依赖进行缓存的，就是说只有当所依赖的数据发生变化的时候，才会重新计算新的computed值\nmethods：只要调用了就会执行该函数\n```\n\n28.v-if和v-show的区别\n\n```\n1.方法：v-if是动态的给dom树添加或删除dom元素，v-show是将样式display设置为none\n2.原理：v-if在生成虚拟dom的时候会忽略掉这个虚拟节点vnode，之后再render渲染真实dom的时候也就没有了该节点\n       v-show生成虚拟dom的时候会生成这个虚拟节点，render渲染成真实dom，并将该节点的样式display设置为none\n3.特点：v-if如果初始条件为flase时，是不会被编译（加快页面加载速度），只有变为true时才会被编译\n       v-show无论初始条件为true还是false，都会被编译，并生成真实的dom元素\n4.使用场景：v-if适用于低频的的切换，v-show适合高频的显示隐藏切换\n```\n\n29.v-model的原理，语法糖的本质是什么\n\n```\nv-model是对表单或者组件的一种双向绑定的语法糖，本质是v-bind和v-on的语法糖\n● v-bind绑定响应数据\n● 触发事件并传递数据\n其中v-bind是对model层对view层的单向绑定，加上了v-on(进行一些函数操作，通过event.target.value获取当前触发事件的元素值)后又实现了view层对model的单向绑定，两者结合实现了model与view的双向绑定\n```\n\n30.单页面应用和多页面应用\n\n```\n● SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用路由跳转，只是切换到相关的组件，仅仅刷新局部资源。\n● MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。\nSPA的优点：\n\t1. 页面相应速度块，用户体验优，因为不需要一直跳转网页\n\t2. 因为不需要重复加载资源，所以spa可以减小服务器的压力\n\t3. 前后端分离，架构清晰，前端进行交互逻辑，后端股则负责数据处理\n\t缺点：\n\t1. 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载\t\n```\n\n31. v-if和v-for哪一个优先级更高？如果同时出现，需要怎么做？\n\n```\n对于vue2来说v-for的优先级会更高，总是会优先执行循环再去判断，尽量使不要同时出现，会浪费性能，因为循环不可避免，所以每次都要进行if判断\n解决方式是在外面嵌套一层v-if，里面使用v-for\n```\n\n32.前端性能优化\n\n```\n1. 路由和图片的懒加载\n2. v-for和v-if避免同时使用\n3. 第三方插件按需引入\n4.keep-alive缓存页面\n```\n\n33.Vue生命周期\n\n```\n每一个组件都需要经过创建，初始化，挂载，更新，销毁这些声明周期\n1.beforeCreate()\n\t初始化事件和生命周期函数,数据代理还未开始，此时无法访问data，computed，watch，methods\n2.created()\n\tvue实例vm创建完成，vm上的配置：data，computed，watch，methods已经配置完成，可以访问得到\n3.beforeMount()\n\t在挂载之前调用，相关的render函数首次被调用，解析模板生成虚拟dom，但此时还未挂载到真实页面上\n4.mounted()\n\t将内存中的虚拟dom转为真实dom并挂载到真实页面中，此时可以进行一些异步请求(网上有很多说在created中，但我在实际项目中，还是在mounted钩子中异步请求)，开启定时器，绑定自定义事件等等\n5.beforeUpdated()\n\t响应式数据更新时调用，这时数据已经更新了，但是真实dom还未被渲染，此时页面和数据尚未同步\n6.updated()\n\t新旧的虚拟dom进行对比，进行页面更新，此时页面和数据已经同步\n7.beforeDestroy()\n\t实例vm销毁之前调用，这时vm仍然可用，this仍可以获取到实例，在此阶段一般关闭定时器，解绑自定义事件等等\n8.destroyed()\n\t实例销毁后调用，解绑指令和移除事件监听，子实例也会被销毁\n```\n\n34.keep-alive中的生命周期有哪些\n\n```\nkeep-alive用来缓存组件，在组件切换的时候将状态保留在缓存中，防止重复渲染dom\n如果为一个组件包裹keep-alive，那么他就会多出两个生命周期函数：deactivated，activated同时beforeDestroy和destroyed两个钩子也不会执行了，因为组件不会被销毁\n当组件被换掉时，他会保留在缓存中并触发deactivated钩子，当组件被切回来时，再去缓存中找到该组件，并触发activated钩子\n```\n\n35.组件间通信\n\n```\n1.父给子传递数据：利用pros\n\t子组件通过pros属性来接收父组件传递过来的数据\n2.子给父传递数据：利用自定义事件\n\t$on/$emit，其中在父组件中绑定自定义事件@name='callback'，并定义相应的回调函数用来接收子组件传递的数据(若是父组件直接在标签内就绑定了，就不用再通过$on去绑定了),子组件就需要通过$emit('name',params)，来触发相应的自定义事件name，并将所要传递的数据params通过参数传递\n3.任意组件之间传递(也可兄弟组件)：全局事件总线$bus,在vue实例身上安装$bus，这样所有的组件实例对象都可以通过原型链向上找到这个$bus\n\t接收数据的组件需要绑定事件，在自身的组件中的$bus.$on去绑定事件\n\t提供数据的组件需要触发事件，在自身的组件中的$bus.$emit来触发该事件，并传递数据\n```\n\n36.路由的懒加载\n\n```\n为了避免在webpack打包时，JavaScript变得非常大，影响页面加载，这时可以利用路由懒加载\n原理：它是将路由对应的组件打包成一个个js代码块，当该路由被访问的时候才会去加载对应的组件，否则不加载\n实现的三种方式：\n\t1.利用箭头函数+import()动态加载\n\t2.利用箭头函数+require()动态加载\n\t3.利用webpack的require.ensure技术\n```\n\n37.路由的两种工作模式\n\n```\nhash模式和history模式\n1.hash模式\n\t在url中会有/#，但是hasn值(#及其后面的内容)不会包含在http请求中，也就是不会将这些信息带给服务器\n\t他的地址中一直带着#，但是兼容性好，也是默认的路由模式\n2.history模式\n\turl地址干净美观，但是兼容性较差，需要后端人员支持，解决刷新页面服务器端404问题\n\tAPI：包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。\n```\n\n\n\n38.两种工作模式的对比\n\n```\n1.对于history.pushState()修改浏览器的历史记录栈，对比直接修改hasn值，有以下好处\n\t1.pushState可以修改与当前url同源的任意路径，但是hash只能修改#之后的内容，也就是只能设置和当前url同文档的url\n\t2.pushState设置的新的url可以和当前url一致，会把该记录加入到栈中；但是hash必须要求新的url与当前不同才会把记录加入到栈中\n2. 在hash模式中，#之前的内容都会放在http请求中，即使后端没有对路由进行全覆盖，也不会返回404的错误\n\t在history模式中，必须要求前端的url和向后端发起请求的url保持一致，后端如果没有对使用的路由处理，会有404的错误\n```\n\n39. $route 和$router的区别\n\n```\n$route是路由实例对象，包含了路由跳转方法，钩子函数（导航守卫）等\n$router是路由信息对象，包含了name，path，fullPath，query，params等路由信息参数\n```\n\n40.常见的http请求方法有哪些？\n\n```\nget:向服务器请求数据\npost：携带数据向服务器发起请求，最终会在服务器端创建新的数据（重点是创建新的数据，例如注册用户业务）\nput：上传数据，更新服务器的数据（重点是更新数据）\ndelete：删除服务器上的数据\nhead：获取报文的首部，与get相比不返回相应实体数据\noptions：询问服务器支持的请求方法，用来跨域请求\ntrace：回显服务器收到的请求，用于测试或诊断\n```\n\n41.get和post请求的区别\n\n```\n1.应用场景：get用于不需要对服务器资源产生影响的场景，仅仅只用来获取数据\n\t        post用于需要对服务器资源产生影响的场景，最终服务器端会产生新的数据（例如用户注册业务）\n2.发送的报文格式：get请求报文实体部分为空\n\t             post的请求报文实体部分一般是向服务器发送的数据\n3.安全性：get请求的中参数会放在url中向服务器发送过去，这种相对于post来说是不安全的\n4.参数类型：post请求中参数传递支持更多的数据\n```\n\n42.常见的http请求头和响应头\n\n```\n1. 请求头：\n        1. Accept-Charset:浏览器能够显示的字符集\n        2. Accept-Encoding：浏览器能够处理的压缩编码\n        3. Accept-Language：浏览器当前设置的语言(可接受的字符集，编码，语言)\n        4. Host：请求将被发送的目的地（仅包括域名+端口号）\n        5. Origin 用来说明请求从哪里发起的（仅包括协议和域名）\n2.响应头：\n\t\t1. Date：表示响应消息发出的时间\n\t\t2. server：表示服务器的名称\n\t\t3. Allow：服务器支持那些请求方法\n\t\t4. Access-Control-Allow-Origin：哪些网站跨域\n\t\t5. Content-Encoding：响应资源的编码\n\t\t6. Content-Language:响应资源的语言\n```\n\n43.http和https协议的区别\n\n```\n1.https是超文本传输安全协议（他是在http的基础上通过加密传输和身份验证来保证传输的安全性），需要CA证书，费用很高，但\thttp不需要\n2.http是超文本传输协议，信息是明文传输的，而https是通过SSL加密传输的更安全\n3.使用的端口号不同，http默认端口为80，https默认端口为443\n4.https通过加密传输和身份验证来保证传输安全，对比http更安全\n```\n\n44.当用户在浏览器中输入www.google.com会发生什么\n\n```\n1.解析URL，分析所使用的传输协议和请求资源的路径\n2.缓存判断，看请求的资源是否在缓存中，如果请求的资源在缓存中且没有失效就直接使用，否则就向服务器发起请求\n3.DNS解析，dns服务器将url解析为对应的ip地址\n4.获取MAC地址，浏览器得到ip地址后，还需要知道目的主机的mac地址，网络层下发至链路层时使用\n5.TCP建立连接（三次握手），通过三次握手保证客户端和服务器都能保证自己发送数据和接收数据的能力，并建建立起连接\n6.HTTPS握手，如果https协议，那么还存在一个TLS的四次握手，四次握手之后客户端和服务器通过握手得到的3个随机数进行加密得到密钥，以后双方通过该密钥进行通信\n7.返回数据，服务器返回一个html文件作为响应，浏览器接收到响应后，开始页面渲染\n8.页面渲染，浏览器根据html构建dom树，最后渲染出整个页面\n9.TCP断开连接（四次挥手），四次挥手后，客户端和服务器双方断开连接，结束所有通信\n```\n\n45.http的请求报文和响应报文\n\n```\n1.请求报文\n\t\t请求行：请求方法，url，http协议版本\n\t\t请求头：key：value形式\n\t\t空行\n\t\t请求体：post，put等请求携带的数据\n2.响应报文\n\t\t响应行：协议版本，状态码，状态码原因短语\n\t\t响应头：key：value\n\t\t空行\n\t\t响应体：服务器响应的数据\n```\n\n46.三次握手和四次挥手\n\n```\n1.三次握手：客户端和服务器建立TCP连接时，需要三次握手，来保证双方发送和接收数据的能力\n\t\t客户端向服务器发送syn连接请求报文，\n\t\t服务器收到请求后向客户端发送syn和ack报文，确认本次连接请求，\n\t\t客户端接收到确认应答后，进入连接状态，同时也向服务器发送一个ack确认报文，服务器收到该确认后，也进入连接状态，\n\t\t至此双方的连接建立完成\n2.四次挥手：客户端和服务器断开TCP连接时，需要进行四次挥手\n\t\t客户端向服务器发送fin断开请求报文\n\t\t服务器收到请求后向客户端发送ack报文，确认本次断开连接请求（但是TCP是全双工，也就是说此时服务器又可能还有数据要传给客户端）\n\t\t所以双方想要断开连接，服务器还需再一次向客户端发送一个fin断开连接请求报文，\n\t\t客户端收到报文后，向服务器发送ack确认报文，自己进入超时等待\n\t\t服务端收到ack报文后，就立即关闭连接，之后客户端继续等待超时时间，若是中间没有来自服务器的数据，此时客户端也关闭连接，否则重置超时时间\n```\n\n47.针对于https中的四次握手（利用中间的三次随机数加密形成密钥进行通信）\n\n```\n四次握手：客户端向服务器发起请求，包括一个随机数和加密方法\n\t\t服务器收到请求后，给出服务器证书，确认加密方法，并生成一个随机数这些都再次传给客户端\n\t\t客户端收到后，确认证书有效，并生成一个随机数，利用证书来加密该随机数并发送给服务器\n\t\t服务器收到后，解密该随机数\n\t\t此时双方已经三个随机数了，之后双方通过约定的加密方法对三个随机数进行加密，形成密钥进行通信\n```\n\n48.http状态码\n\n```\n2xx 成功状态码，表示请求正常处理完毕\n\t \t200：ok，表示客户端的请求已经被服务器正常处理了\n3xx 重定向，表示需要附加操作完成请求\n\t \t301：永久重定向，表示请求的资源已经被分配到了新的uri\n\t \t302：临时重定向，表示请求的资源被临时分配到新的uri，希望用户使用新的uri访问资源\n4xx 客户端错误，服务器无法处理请求\n\t \t400：表示报文存在语法错误\n\t \t403：表示访问资源的请求被服务器拒绝了\n\t \t404：服务器无法找到请求的资源\n5xx 服务器错误，服务器处理请求出错\n\t \t500：表示服务端在处理请求时发生错误\n\t \t503：表示服务器暂时处于超负载或停机维护，无法处理请求\n```\n\n49.网络模型\n\n```\n1.OSI七层\n\t应用层-表示层-会话层-运输层-网络层-链路层-物理层\n2.TCP/IP五层\n\t应用层-传输层-网络层-链路层-物理层\n\t应用层：如 HTTP协议，https协议、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）\n\t传输层：UDP和TCP\n\t网络层：选择合适的路由将数据传递给目的主机\n\t数据链路层：将网络层传递下来的ip数据报封装成帧，在链路传送帧\n\t物理层：物理介质的传输\n```\n\n50.TCP和UDP的区别\n\n```\ntcp和udp都时传输层的协议，都属于tcp/ip协议族\n\ttcp提供的是面向连接的，可靠的数据传输服务，数据传输的单位是报文段，适用于精确传输，例如文件传输\n\tudp提供的是无连接的，尽最大努力的数据传输服务，但不保证数据的可靠性，数据传输的单位是用户数据报，适用于要求精确度较低的场景，例如视频聊天，即时通话\n```\n\n51.TCP的拥塞控制机制\n\n```\ntcp的拥塞控制主要通过慢开始，拥塞避免，快速重传，快速恢复四个机制\n\t1.首先是慢开始，设定拥塞窗口=1，最后逐渐增加拥塞窗口的大小，设定一个慢开始门限(当拥塞窗口达到这个门限后，就不会执行慢开始了，而是进入拥塞避免阶段)\n\t2.当拥塞窗口>慢开始门限，进入拥塞避免阶段，此阶段拥塞窗口线性增长，每次自增1，当发送方判断网络出现了拥塞后，将慢开始门限调整为本次出现拥塞窗口的一半，将这时的拥塞窗口重置为1，重新开始慢开始算法\n\t3.快重传，当接收方收到一个失序的报文段时就立即发出重复确认，发送到只要连续收到三个重复确认就袭击重传对方缺失的报文段\n\t4.快恢复，当发送放执行了快重传后，会将慢开始门限和下一次的拥塞窗口调整为本次拥塞窗口的一半，这时直接进入拥塞避免阶段\n```\n\n面试【高频的面试】:项目的性能优化手段有哪些？\n\n```\nv-if|v-show:尽可能采用v-show\n按需引入【lodash、elementUI】\n防抖与节流\n路由懒加载：当用户访问的时候，加载对应组件进行展示。\n```\n\n\n\n","slug":"面试笔记","published":1,"date":"2022-06-15T05:26:14.286Z","updated":"2022-06-15T05:29:48.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4glk6rs00052wtmgyy08lyk","content":"<ol>\n<li><p>用语义化标签就会标记出每个区域的作用并且更好是实现页面布局</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span>  头部</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span>  导航栏</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span>  主要区域</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">article</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span>  主要内容</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aside</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">aside</span>&gt;</span>  侧边栏</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure></li>\n<li><p>HTML5有哪些更新</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）新增语义化标签：nav、header、footer、aside、section、article</span><br><span class=\"line\">（2）音频、视频标签：audio、video</span><br><span class=\"line\">（3）数据存储：localStorage、sessionStorage</span><br><span class=\"line\">（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</span><br><span class=\"line\">（5）input标签新增属性：placeholder、autocomplete、autofocus、required</span><br><span class=\"line\">（6）history API：go、forward、back、pushstate</span><br></pre></td></tr></table></figure>\n\n<p>1.语义化标签，使⽤语义类标签增强了可读性，开发者也能够清晰地看出⽹⻚的结构。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">● header：定义文档的页眉（头部）；</span><br><span class=\"line\">● nav：定义导航链接的部分；</span><br><span class=\"line\">● footer：定义文档或节的页脚（底部）；</span><br><span class=\"line\">● article：定义文章内容；</span><br><span class=\"line\">● section：定义文档中的节（section、区段）；</span><br><span class=\"line\">● aside：定义其所处内容之外的内容（侧边）；</span><br></pre></td></tr></table></figure>\n\n<p>2.媒体标签</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">audio：音频</span><br><span class=\"line\">video视频</span><br><span class=\"line\">source标签</span><br></pre></td></tr></table></figure>\n\n<p>3.表单</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表单类型</span><br><span class=\"line\">- email ：能够验证当前输入的邮箱地址是否合法</span><br><span class=\"line\">- url ： 验证URL</span><br><span class=\"line\">- number ： 只能输入数字，其他输入不了</span><br><span class=\"line\">表单属性：</span><br><span class=\"line\"> placeholder ：提示信息</span><br><span class=\"line\">表单事件：</span><br><span class=\"line\">oninput 每当input里的输入框内容发生变化都会触发此事件。</span><br><span class=\"line\">oninvalid 当验证不通过时触发此事件。</span><br></pre></td></tr></table></figure>\n\n<p>4.进度条</p>\n<p>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</p>\n<p>5.DOM查询操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- document.querySelector()</span><br><span class=\"line\">- document.querySelectorAll()</span><br><span class=\"line\">它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</span><br></pre></td></tr></table></figure>\n\n<p>6.Web存储</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML5 提供了两种在客户端存储数据的新方法：</span><br><span class=\"line\">- localStorage - 没有时间限制的数据存储</span><br><span class=\"line\">- sessionStorage - 针对一个 session 的数据存储</span><br></pre></td></tr></table></figure></li>\n<li><p>Css选择器的优先级</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">css是通过计算这些选择器的权重来去判定他们优先级的高低</span><br><span class=\"line\">首先用!important的权重最高，之后是内联样式权重为1000，其次是id选择器权重为100，之后是类选择器，伪类选择器，属性选择器的权重都为10，标签选择是1，其余的一些子选择器，后代选择器为0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>盒子模型的属性</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width、height、margin、border、padding</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>对盒模型的理解</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">标准盒子模型、IE盒子模型</span><br><span class=\"line\">盒模型都是由四个部分组成的，分别是margin、border、padding和content。</span><br><span class=\"line\">标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</span><br><span class=\"line\">● 标准盒模型的width和height属性的范围只包含了content，</span><br><span class=\"line\">● IE盒模型的width和height属性的范围包含了border、padding和content。</span><br><span class=\"line\">可以通过修改元素的box-sizing属性来改变元素的盒模型：</span><br><span class=\"line\">● box-sizing: content-box表示标准盒模型（默认值）</span><br><span class=\"line\">● box-sizing: border-box表示IE盒模型（怪异盒模型）</span><br></pre></td></tr></table></figure>\n\n<p>6.CSS3中有哪些新特性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">● 新增各种CSS选择器,child来匹配父元素的相应的子元素</span><br><span class=\"line\">● 圆角 （border-radius:8px）</span><br><span class=\"line\">●css弹性盒子模型</span><br><span class=\"line\">● 增加过渡，动画</span><br></pre></td></tr></table></figure>\n\n<p>7.两栏布局的实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先3大类：flex弹性布局，绝对定位，浮动</span><br><span class=\"line\">1.将左右盒子的父盒子display设定为flex，之后将左盒子设定宽度w，右盒子的flex：1(1,1,0%) flex-grow，flex-shrink，flex-basis 使其等比缩放</span><br><span class=\"line\">2. 父盒子相对定位，左盒子绝对定位并指定宽度，右盒子margin-left值为左盒子宽度值</span><br><span class=\"line\">                右盒子绝对定位，将右盒子左方向值设定为左盒子的宽度值</span><br><span class=\"line\">3. 左盒子进行左浮动并设定宽度值，右盒子的margin-left值为左盒子的宽度，右盒子的宽度为auto</span><br><span class=\"line\">   左盒子进行左浮动并设定负定宽高，右盒子的overflo：hidden</span><br></pre></td></tr></table></figure>\n\n<p>8.三栏布局的实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有三种形式，flex弹性布局，绝对定位，浮动</span><br><span class=\"line\">1.将三栏的父盒子的display谁当为flex，左右两栏设定固定的宽度，之后中间栏的flex:1</span><br><span class=\"line\">2.将三栏的父盒子相对定位，左右盒子绝对定位，分别居于左右两侧，中间栏设定margin-left和margin-right分别为左右两栏的宽度值</span><br><span class=\"line\">3.将左右盒子分别作左右浮动，中间栏设定margin-left和margin-right分别为左右两栏的宽度值</span><br></pre></td></tr></table></figure>\n\n<p>9.水平垂直居中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我可能知道的不全面，目前我知道有两种方式，flex弹性布局和绝对定位</span><br><span class=\"line\">1.将父盒子dispaly设定为flex，设定水平轴justify-content:center 还有垂直轴align-items:center</span><br><span class=\"line\">2.将父盒子相对定位，子盒子绝对定位，将左上方向50%移动至页面中央，最后通过translate或者margin的负值来调整元素中心值至页面中央 </span><br><span class=\"line\">3.自盒子绝对定位之后，所有方向都为0，最后margin为auto</span><br></pre></td></tr></table></figure>\n\n<p>10.==操作符的强制类型转化规则</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.==首先会看两者的数据类型是否一致</span><br><span class=\"line\">2.如果不一致的会进行强制转换，首先看是否是null == undefine ,是则返回true</span><br><span class=\"line\">3.再看是否是string == number ，将string强转为number型在进行对比</span><br><span class=\"line\">4.再看是否是boolean == number， 将boolean继续转为number</span><br><span class=\"line\">5.最后如果是一个对象 == 非对象string，则会将该对象通过toPrimitive转为基本数据类型在进行对比</span><br><span class=\"line\">注意如果是两个对象比较，则是比较的是地址空间，因为对象数组这些引用类型都是存储在堆中的，分配相应的引用地址</span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li>js的8大数据类型</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u are so nb  </span><br><span class=\"line\">undefined </span><br><span class=\"line\">symbol string </span><br><span class=\"line\">object </span><br><span class=\"line\">number null </span><br><span class=\"line\">boolean bigint</span><br></pre></td></tr></table></figure>\n\n<p>12.如何判断一个对象是一个空对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.通过Object.keys()获取这个对象的索引数组，如果索引数组长度为0，则表明对象是空对象</span><br><span class=\"line\">2.通过for in 遍历这个对象，如果这个对象不可遍历 则为空对象</span><br><span class=\"line\">3.通过Json.stringfy()将对象转为字符串，并于 ==&#x27;&#123;&#125;&#x27;比较</span><br></pre></td></tr></table></figure>\n\n<p>13.es6</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.增加了let，const关键字</span><br><span class=\"line\">    1.有了块级作用域的特点（变量的覆盖，变量泄露）</span><br><span class=\"line\">    2.没有变量提升，必须声明后才能使用</span><br><span class=\"line\">    3.var 用来声明全局变量 </span><br><span class=\"line\">    4.var，let都可以改变其指针指向，但const无法修改它的指针指向且必须赋初始值</span><br><span class=\"line\">    5.var可以重复声明，但let和const不允许重复声明</span><br><span class=\"line\">2.箭头函数</span><br><span class=\"line\">3.扩展运算符... 用户合并数组或者合并对象</span><br><span class=\"line\">4.rest参数...args  可以是用来接收剩余不确定个数的参数，将其存放在一个数组中</span><br><span class=\"line\">5.模板字符串</span><br><span class=\"line\">6.数组或对象的解构赋值</span><br><span class=\"line\">7.模块化 可以避免命名冲突，提高代码复用，利于维护</span><br><span class=\"line\">8.for of 遍历 (</span><br><span class=\"line\">\t1.for of遍历的是键值，for in 遍历的键名</span><br><span class=\"line\">\t2.for of只会遍历当前对象</span><br><span class=\"line\">\t3.for in适合遍历对象，for of适合遍历数组（因为of必须要求需要有迭代器，所以他不能迭代对象）。for in遍历的是数组的索引，对象的属性，以及原型链上的属性。</span><br><span class=\"line\">)</span><br><span class=\"line\">9.async 和 await ，async返回一个Promise期约对象，常用于一个ajax请求，异步等待请求的结果，并对请求结果返回的Promise进行一些处理</span><br><span class=\"line\">10.Promise期约（fulfilled，rejected，Pending（进行中））</span><br></pre></td></tr></table></figure>\n\n<p>14.箭头函数this的指向</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 首先箭头函数没有自己的this，箭头函数定义的位置的外部最近的一个this就是他的this</span><br><span class=\"line\">2. 对于普通函数来说他的this指向的是调用者，谁调用就指向谁，可以是window，可以是对象，只看是谁调用，不看他定义在哪个位置</span><br><span class=\"line\">3. 切记箭头函数如果定义在一个对象里面，那么他应该还需要再去外层找，因为对象的&#123;&#125;不是一个作用域</span><br></pre></td></tr></table></figure>\n\n<p>15.axios</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios是通过Promise实现对ajax技术的一种封装</span><br><span class=\"line\">    1. 浏览器端发起XMLHttpRequests请求</span><br><span class=\"line\">    2. 支持Promise API</span><br><span class=\"line\">    3. 监听请求和返回</span><br><span class=\"line\">    4. 自动转换json数据</span><br><span class=\"line\">    5. 支持拦截请求和响应</span><br></pre></td></tr></table></figure>\n\n<p>16.ajax</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax的全称是async javascript xml 异步的js和xml</span><br><span class=\"line\">1、什么是ajax</span><br><span class=\"line\">\tAjax是对原生XHR的封装，发送一个异步请求，不用刷新网页</span><br><span class=\"line\">2、ajax的原理？</span><br><span class=\"line\">\t客户端通过ajax向服务器发起请求，服务器作出响应之后返回给客户端，客户端接收到数据后，实现页面无刷新更新数据</span><br><span class=\"line\">3. ajax请求的五个步骤</span><br><span class=\"line\">    1. 创建XMLHttpRequest异步对象xml</span><br><span class=\"line\">    2. open初始化 设置请求方法和 url，请求参数</span><br><span class=\"line\">    3. send发送数据</span><br><span class=\"line\">    4. 绑定事件回调，处理服务端返回的结果</span><br><span class=\"line\">    5. 在回调函数中针对不同的响应状态进行处理（首先会判断xml状态为4，之后再判断返回的相应状态码200-300）</span><br><span class=\"line\">4.他的缺点：</span><br><span class=\"line\">\t1.安全问题 ajax暴露了与服务器交互的细节</span><br><span class=\"line\">\t2.ajax不能很好的支持移动设备</span><br><span class=\"line\">\t3.ajax不能使用Back和history功能，即对浏览器机制的破坏。</span><br></pre></td></tr></table></figure>\n\n<p>17.跨域</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.什么跨域？当违背了ajax的同源策略即为跨域</span><br><span class=\"line\">\t请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域,其实这是浏览器的一种同源策略(Same origin policy)，为了减小网络攻击</span><br><span class=\"line\">2.解决跨域的方法：</span><br><span class=\"line\">    前端解决：3种</span><br><span class=\"line\">        1.jsonp jsonp实现跨域的本质是通过script标签的src属性在引入外部资源时，不受到同源限制的特点来实现的，但是只能解决get请求，要求前后端配合写法</span><br><span class=\"line\">        2.利用代理服务器---WebPack-proxy会启动一个本地开发的服务器，即跨域所使用的代理服务器，代理服务器会响应本地请求，继而转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，代理服务器再将数据返回给本地。</span><br><span class=\"line\">        在此阶段中不涉及任何跨域问题，因为代理服务器跟本地同源，而服务器之间不存在跨域问题，跨域问题是浏览器安全策略限制</span><br><span class=\"line\">        3.Nginx反向代理，但这个我目前还不是很了解，只是知道有这种方法</span><br><span class=\"line\">    后端解决：</span><br><span class=\"line\">        cros： cors 真正解决了跨域问题，只需要在服务端设置响应头允许跨域即可</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>18.对原型的理解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法</span><br></pre></td></tr></table></figure>\n\n<p>19.原型链</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个构造函数都有一个prototype的原型对象，通过构造函数得到的实例化对象具有__proto__属性并指向该构造函数的原型对象，而原型对象上的constructor又指向对应的构造函数，对于该构造函数的原型对象也可以理解为时Object的实例化对象，他的__proto__指向的是Object构造函数的原型对象，而object的原型对象的__proto__指向原型链的终点null</span><br></pre></td></tr></table></figure>\n\n<p>20.闭包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闭包就是一个作用域引用了另一个作用域的变量或者方法，因为存在引用，所以被引用变量所在的作用域就不会被垃圾回收机制，因此就形成了闭包。</span><br><span class=\"line\">作用：</span><br><span class=\"line\"> 1. 可以延申变量的作用域范围</span><br><span class=\"line\"> 2. 用于保存数据，因为闭包中变量被引用，所以不会被垃圾回收机制回收</span><br></pre></td></tr></table></figure>\n\n<p>21.异步编程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avaScript中的异步机制可以分为以下几种：</span><br><span class=\"line\">● 回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</span><br><span class=\"line\">● Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</span><br><span class=\"line\">● async await</span><br></pre></td></tr></table></figure>\n\n<p>22.垃圾回收</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.什么是垃圾回收：js代码运行中，系统需要分配内存空间给这些变量和值，当他们不在被使用的时候，系统就需要释放掉他们之前占用的内存空间</span><br><span class=\"line\">2.垃圾回收的机制：js具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存</span><br><span class=\"line\">3.垃圾回收的方式(两种)</span><br><span class=\"line\">\t1.标记清除：当变量在被使用时，会被浏览器标记为’进入环境‘，当变量不再被使用时，会被重新标记为’离开环境‘，标记为离开环境的变量会被内存释放</span><br><span class=\"line\">\t2.引用计数：变量每被引用一次时，引用次数会加1，当该变量的引用次数为0时，这时该变量会被内存释放</span><br><span class=\"line\">4.内存泄漏</span><br></pre></td></tr></table></figure>\n\n<p>23.内存泄漏</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内存泄漏：就是一个变量该让他释放内存空间的时候没有被释放，始终占用着内存</span><br><span class=\"line\">什么情况下会发生内存泄漏：</span><br><span class=\"line\">\t1.不合理的使用闭包，因为在闭包中会发生内部函数对外部变量的引用，该变量会因为这个引用的存在而不会被垃圾回收机制清除</span><br><span class=\"line\">\t2.遗忘的定时器，对于设定的某个循环定时器但是忘记取消他，该定时器若是有对外部变量的引用时，这时该变量所占用的内存也不会被回收</span><br><span class=\"line\">\t3. 意外的全局变量，使用了未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class=\"line\">\t4.脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收</span><br></pre></td></tr></table></figure>\n\n<p>24.Vue中的双向绑定原理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Observer实现对MVVM自身model数据劫持（底层是通过Object.defineProperty()为对data里的数据进行递归的添加getter和setter），监听数据的属性变更，并在变动时进行notify</span><br><span class=\"line\">2. Compile实现指令解析，初始化视图，并订阅数据变化，绑定好更新函数</span><br><span class=\"line\">3. Watcher（订阅者）一方面接收Observer通过dep(消息订阅器)传递过来的数据变化，一方面通知Compile进行view update</span><br><span class=\"line\">MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果</span><br></pre></td></tr></table></figure>\n\n<p>25.MVVM、MVC、MVP的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</span><br><span class=\"line\">\t1. MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。(注意在MVC中 model和view是耦合的，可以相互直接通信)</span><br><span class=\"line\">\t2. MVVM 分为 Model、View、ViewModel：</span><br><span class=\"line\">\t\t1.Model代表数据模型，数据和业务逻辑都在Model层中定义；</span><br><span class=\"line\">\t\t2.View代表UI视图，负责数据的展示；</span><br><span class=\"line\">\t\t3.ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；\t</span><br><span class=\"line\">\t\tModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM</span><br><span class=\"line\">\t3.MVP View和Model之间不能直接进行交互，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部</span><br></pre></td></tr></table></figure>\n\n<p>26.computed和watch的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:</span><br><span class=\"line\">\t1. 他是基于响应式依赖(data和props里面的数据)进行缓存的，当依赖的数据发生变化时，下一次获取 computed 的值时才会重新计算 computed 的值</span><br><span class=\"line\">\t2. 不支持异步操作，当computed中有异步操作时，无法监听到数据的变化</span><br><span class=\"line\">watch：</span><br><span class=\"line\">\t1. 不支持缓存，只要监听的数据(data和props里面的数)发生变化，就会执行对应的handler回调</span><br><span class=\"line\">\t2. 支持异步监听</span><br><span class=\"line\">两者的应用场景：</span><br><span class=\"line\">\t1.computed：当想要获取的数据是依赖于其他数据计算出来的，这时候可以利用computed的缓存特点(只要他依赖的数据没变，那么这个数据他就不会变化直接从缓存取出来即可)，可以不用每次获取这个数据时就重新计算一次了</span><br><span class=\"line\">\t2.watch：当想要对某个数据变化时进行实时监听并进行一些异步操作(例如API请求)，这时就需要通过watch进行操作</span><br></pre></td></tr></table></figure>\n\n<p>27.computed和methods</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed：他是基于响应式依赖进行缓存的，就是说只有当所依赖的数据发生变化的时候，才会重新计算新的computed值</span><br><span class=\"line\">methods：只要调用了就会执行该函数</span><br></pre></td></tr></table></figure>\n\n<p>28.v-if和v-show的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.方法：v-if是动态的给dom树添加或删除dom元素，v-show是将样式display设置为none</span><br><span class=\"line\">2.原理：v-if在生成虚拟dom的时候会忽略掉这个虚拟节点vnode，之后再render渲染真实dom的时候也就没有了该节点</span><br><span class=\"line\">       v-show生成虚拟dom的时候会生成这个虚拟节点，render渲染成真实dom，并将该节点的样式display设置为none</span><br><span class=\"line\">3.特点：v-if如果初始条件为flase时，是不会被编译（加快页面加载速度），只有变为true时才会被编译</span><br><span class=\"line\">       v-show无论初始条件为true还是false，都会被编译，并生成真实的dom元素</span><br><span class=\"line\">4.使用场景：v-if适用于低频的的切换，v-show适合高频的显示隐藏切换</span><br></pre></td></tr></table></figure>\n\n<p>29.v-model的原理，语法糖的本质是什么</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v-model是对表单或者组件的一种双向绑定的语法糖，本质是v-bind和v-on的语法糖</span><br><span class=\"line\">● v-bind绑定响应数据</span><br><span class=\"line\">● 触发事件并传递数据</span><br><span class=\"line\">其中v-bind是对model层对view层的单向绑定，加上了v-on(进行一些函数操作，通过event.target.value获取当前触发事件的元素值)后又实现了view层对model的单向绑定，两者结合实现了model与view的双向绑定</span><br></pre></td></tr></table></figure>\n\n<p>30.单页面应用和多页面应用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">● SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用路由跳转，只是切换到相关的组件，仅仅刷新局部资源。</span><br><span class=\"line\">● MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</span><br><span class=\"line\">SPA的优点：</span><br><span class=\"line\">\t1. 页面相应速度块，用户体验优，因为不需要一直跳转网页</span><br><span class=\"line\">\t2. 因为不需要重复加载资源，所以spa可以减小服务器的压力</span><br><span class=\"line\">\t3. 前后端分离，架构清晰，前端进行交互逻辑，后端股则负责数据处理</span><br><span class=\"line\">\t缺点：</span><br><span class=\"line\">\t1. 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载\t</span><br></pre></td></tr></table></figure>\n\n<ol start=\"31\">\n<li>v-if和v-for哪一个优先级更高？如果同时出现，需要怎么做？</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于vue2来说v-for的优先级会更高，总是会优先执行循环再去判断，尽量使不要同时出现，会浪费性能，因为循环不可避免，所以每次都要进行if判断</span><br><span class=\"line\">解决方式是在外面嵌套一层v-if，里面使用v-for</span><br></pre></td></tr></table></figure>\n\n<p>32.前端性能优化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 路由和图片的懒加载</span><br><span class=\"line\">2. v-for和v-if避免同时使用</span><br><span class=\"line\">3. 第三方插件按需引入</span><br><span class=\"line\">4.keep-alive缓存页面</span><br></pre></td></tr></table></figure>\n\n<p>33.Vue生命周期</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每一个组件都需要经过创建，初始化，挂载，更新，销毁这些声明周期</span><br><span class=\"line\">1.beforeCreate()</span><br><span class=\"line\">\t初始化事件和生命周期函数,数据代理还未开始，此时无法访问data，computed，watch，methods</span><br><span class=\"line\">2.created()</span><br><span class=\"line\">\tvue实例vm创建完成，vm上的配置：data，computed，watch，methods已经配置完成，可以访问得到</span><br><span class=\"line\">3.beforeMount()</span><br><span class=\"line\">\t在挂载之前调用，相关的render函数首次被调用，解析模板生成虚拟dom，但此时还未挂载到真实页面上</span><br><span class=\"line\">4.mounted()</span><br><span class=\"line\">\t将内存中的虚拟dom转为真实dom并挂载到真实页面中，此时可以进行一些异步请求(网上有很多说在created中，但我在实际项目中，还是在mounted钩子中异步请求)，开启定时器，绑定自定义事件等等</span><br><span class=\"line\">5.beforeUpdated()</span><br><span class=\"line\">\t响应式数据更新时调用，这时数据已经更新了，但是真实dom还未被渲染，此时页面和数据尚未同步</span><br><span class=\"line\">6.updated()</span><br><span class=\"line\">\t新旧的虚拟dom进行对比，进行页面更新，此时页面和数据已经同步</span><br><span class=\"line\">7.beforeDestroy()</span><br><span class=\"line\">\t实例vm销毁之前调用，这时vm仍然可用，this仍可以获取到实例，在此阶段一般关闭定时器，解绑自定义事件等等</span><br><span class=\"line\">8.destroyed()</span><br><span class=\"line\">\t实例销毁后调用，解绑指令和移除事件监听，子实例也会被销毁</span><br></pre></td></tr></table></figure>\n\n<p>34.keep-alive中的生命周期有哪些</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keep-alive用来缓存组件，在组件切换的时候将状态保留在缓存中，防止重复渲染dom</span><br><span class=\"line\">如果为一个组件包裹keep-alive，那么他就会多出两个生命周期函数：deactivated，activated同时beforeDestroy和destroyed两个钩子也不会执行了，因为组件不会被销毁</span><br><span class=\"line\">当组件被换掉时，他会保留在缓存中并触发deactivated钩子，当组件被切回来时，再去缓存中找到该组件，并触发activated钩子</span><br></pre></td></tr></table></figure>\n\n<p>35.组件间通信</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.父给子传递数据：利用pros</span><br><span class=\"line\">\t子组件通过pros属性来接收父组件传递过来的数据</span><br><span class=\"line\">2.子给父传递数据：利用自定义事件</span><br><span class=\"line\">\t$on/$emit，其中在父组件中绑定自定义事件@name=&#x27;callback&#x27;，并定义相应的回调函数用来接收子组件传递的数据(若是父组件直接在标签内就绑定了，就不用再通过$on去绑定了),子组件就需要通过$emit(&#x27;name&#x27;,params)，来触发相应的自定义事件name，并将所要传递的数据params通过参数传递</span><br><span class=\"line\">3.任意组件之间传递(也可兄弟组件)：全局事件总线$bus,在vue实例身上安装$bus，这样所有的组件实例对象都可以通过原型链向上找到这个$bus</span><br><span class=\"line\">\t接收数据的组件需要绑定事件，在自身的组件中的$bus.$on去绑定事件</span><br><span class=\"line\">\t提供数据的组件需要触发事件，在自身的组件中的$bus.$emit来触发该事件，并传递数据</span><br></pre></td></tr></table></figure>\n\n<p>36.路由的懒加载</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了避免在webpack打包时，JavaScript变得非常大，影响页面加载，这时可以利用路由懒加载</span><br><span class=\"line\">原理：它是将路由对应的组件打包成一个个js代码块，当该路由被访问的时候才会去加载对应的组件，否则不加载</span><br><span class=\"line\">实现的三种方式：</span><br><span class=\"line\">\t1.利用箭头函数+import()动态加载</span><br><span class=\"line\">\t2.利用箭头函数+require()动态加载</span><br><span class=\"line\">\t3.利用webpack的require.ensure技术</span><br></pre></td></tr></table></figure>\n\n<p>37.路由的两种工作模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash模式和history模式</span><br><span class=\"line\">1.hash模式</span><br><span class=\"line\">\t在url中会有/#，但是hasn值(#及其后面的内容)不会包含在http请求中，也就是不会将这些信息带给服务器</span><br><span class=\"line\">\t他的地址中一直带着#，但是兼容性好，也是默认的路由模式</span><br><span class=\"line\">2.history模式</span><br><span class=\"line\">\turl地址干净美观，但是兼容性较差，需要后端人员支持，解决刷新页面服务器端404问题</span><br><span class=\"line\">\tAPI：包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>38.两种工作模式的对比</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.对于history.pushState()修改浏览器的历史记录栈，对比直接修改hasn值，有以下好处</span><br><span class=\"line\">\t1.pushState可以修改与当前url同源的任意路径，但是hash只能修改#之后的内容，也就是只能设置和当前url同文档的url</span><br><span class=\"line\">\t2.pushState设置的新的url可以和当前url一致，会把该记录加入到栈中；但是hash必须要求新的url与当前不同才会把记录加入到栈中</span><br><span class=\"line\">2. 在hash模式中，#之前的内容都会放在http请求中，即使后端没有对路由进行全覆盖，也不会返回404的错误</span><br><span class=\"line\">\t在history模式中，必须要求前端的url和向后端发起请求的url保持一致，后端如果没有对使用的路由处理，会有404的错误</span><br></pre></td></tr></table></figure>\n\n<ol start=\"39\">\n<li>$route 和$router的区别</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$route是路由实例对象，包含了路由跳转方法，钩子函数（导航守卫）等</span><br><span class=\"line\">$router是路由信息对象，包含了name，path，fullPath，query，params等路由信息参数</span><br></pre></td></tr></table></figure>\n\n<p>40.常见的http请求方法有哪些？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get:向服务器请求数据</span><br><span class=\"line\">post：携带数据向服务器发起请求，最终会在服务器端创建新的数据（重点是创建新的数据，例如注册用户业务）</span><br><span class=\"line\">put：上传数据，更新服务器的数据（重点是更新数据）</span><br><span class=\"line\">delete：删除服务器上的数据</span><br><span class=\"line\">head：获取报文的首部，与get相比不返回相应实体数据</span><br><span class=\"line\">options：询问服务器支持的请求方法，用来跨域请求</span><br><span class=\"line\">trace：回显服务器收到的请求，用于测试或诊断</span><br></pre></td></tr></table></figure>\n\n<p>41.get和post请求的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.应用场景：get用于不需要对服务器资源产生影响的场景，仅仅只用来获取数据</span><br><span class=\"line\">\t        post用于需要对服务器资源产生影响的场景，最终服务器端会产生新的数据（例如用户注册业务）</span><br><span class=\"line\">2.发送的报文格式：get请求报文实体部分为空</span><br><span class=\"line\">\t             post的请求报文实体部分一般是向服务器发送的数据</span><br><span class=\"line\">3.安全性：get请求的中参数会放在url中向服务器发送过去，这种相对于post来说是不安全的</span><br><span class=\"line\">4.参数类型：post请求中参数传递支持更多的数据</span><br></pre></td></tr></table></figure>\n\n<p>42.常见的http请求头和响应头</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 请求头：</span><br><span class=\"line\">        1. Accept-Charset:浏览器能够显示的字符集</span><br><span class=\"line\">        2. Accept-Encoding：浏览器能够处理的压缩编码</span><br><span class=\"line\">        3. Accept-Language：浏览器当前设置的语言(可接受的字符集，编码，语言)</span><br><span class=\"line\">        4. Host：请求将被发送的目的地（仅包括域名+端口号）</span><br><span class=\"line\">        5. Origin 用来说明请求从哪里发起的（仅包括协议和域名）</span><br><span class=\"line\">2.响应头：</span><br><span class=\"line\">\t\t1. Date：表示响应消息发出的时间</span><br><span class=\"line\">\t\t2. server：表示服务器的名称</span><br><span class=\"line\">\t\t3. Allow：服务器支持那些请求方法</span><br><span class=\"line\">\t\t4. Access-Control-Allow-Origin：哪些网站跨域</span><br><span class=\"line\">\t\t5. Content-Encoding：响应资源的编码</span><br><span class=\"line\">\t\t6. Content-Language:响应资源的语言</span><br></pre></td></tr></table></figure>\n\n<p>43.http和https协议的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.https是超文本传输安全协议（他是在http的基础上通过加密传输和身份验证来保证传输的安全性），需要CA证书，费用很高，但\thttp不需要</span><br><span class=\"line\">2.http是超文本传输协议，信息是明文传输的，而https是通过SSL加密传输的更安全</span><br><span class=\"line\">3.使用的端口号不同，http默认端口为80，https默认端口为443</span><br><span class=\"line\">4.https通过加密传输和身份验证来保证传输安全，对比http更安全</span><br></pre></td></tr></table></figure>\n\n<p>44.当用户在浏览器中输入<a href=\"http://www.google.com会发生什么/\">www.google.com会发生什么</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.解析URL，分析所使用的传输协议和请求资源的路径</span><br><span class=\"line\">2.缓存判断，看请求的资源是否在缓存中，如果请求的资源在缓存中且没有失效就直接使用，否则就向服务器发起请求</span><br><span class=\"line\">3.DNS解析，dns服务器将url解析为对应的ip地址</span><br><span class=\"line\">4.获取MAC地址，浏览器得到ip地址后，还需要知道目的主机的mac地址，网络层下发至链路层时使用</span><br><span class=\"line\">5.TCP建立连接（三次握手），通过三次握手保证客户端和服务器都能保证自己发送数据和接收数据的能力，并建建立起连接</span><br><span class=\"line\">6.HTTPS握手，如果https协议，那么还存在一个TLS的四次握手，四次握手之后客户端和服务器通过握手得到的3个随机数进行加密得到密钥，以后双方通过该密钥进行通信</span><br><span class=\"line\">7.返回数据，服务器返回一个html文件作为响应，浏览器接收到响应后，开始页面渲染</span><br><span class=\"line\">8.页面渲染，浏览器根据html构建dom树，最后渲染出整个页面</span><br><span class=\"line\">9.TCP断开连接（四次挥手），四次挥手后，客户端和服务器双方断开连接，结束所有通信</span><br></pre></td></tr></table></figure>\n\n<p>45.http的请求报文和响应报文</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.请求报文</span><br><span class=\"line\">\t\t请求行：请求方法，url，http协议版本</span><br><span class=\"line\">\t\t请求头：key：value形式</span><br><span class=\"line\">\t\t空行</span><br><span class=\"line\">\t\t请求体：post，put等请求携带的数据</span><br><span class=\"line\">2.响应报文</span><br><span class=\"line\">\t\t响应行：协议版本，状态码，状态码原因短语</span><br><span class=\"line\">\t\t响应头：key：value</span><br><span class=\"line\">\t\t空行</span><br><span class=\"line\">\t\t响应体：服务器响应的数据</span><br></pre></td></tr></table></figure>\n\n<p>46.三次握手和四次挥手</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.三次握手：客户端和服务器建立TCP连接时，需要三次握手，来保证双方发送和接收数据的能力</span><br><span class=\"line\">\t\t客户端向服务器发送syn连接请求报文，</span><br><span class=\"line\">\t\t服务器收到请求后向客户端发送syn和ack报文，确认本次连接请求，</span><br><span class=\"line\">\t\t客户端接收到确认应答后，进入连接状态，同时也向服务器发送一个ack确认报文，服务器收到该确认后，也进入连接状态，</span><br><span class=\"line\">\t\t至此双方的连接建立完成</span><br><span class=\"line\">2.四次挥手：客户端和服务器断开TCP连接时，需要进行四次挥手</span><br><span class=\"line\">\t\t客户端向服务器发送fin断开请求报文</span><br><span class=\"line\">\t\t服务器收到请求后向客户端发送ack报文，确认本次断开连接请求（但是TCP是全双工，也就是说此时服务器又可能还有数据要传给客户端）</span><br><span class=\"line\">\t\t所以双方想要断开连接，服务器还需再一次向客户端发送一个fin断开连接请求报文，</span><br><span class=\"line\">\t\t客户端收到报文后，向服务器发送ack确认报文，自己进入超时等待</span><br><span class=\"line\">\t\t服务端收到ack报文后，就立即关闭连接，之后客户端继续等待超时时间，若是中间没有来自服务器的数据，此时客户端也关闭连接，否则重置超时时间</span><br></pre></td></tr></table></figure>\n\n<p>47.针对于https中的四次握手（利用中间的三次随机数加密形成密钥进行通信）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">四次握手：客户端向服务器发起请求，包括一个随机数和加密方法</span><br><span class=\"line\">\t\t服务器收到请求后，给出服务器证书，确认加密方法，并生成一个随机数这些都再次传给客户端</span><br><span class=\"line\">\t\t客户端收到后，确认证书有效，并生成一个随机数，利用证书来加密该随机数并发送给服务器</span><br><span class=\"line\">\t\t服务器收到后，解密该随机数</span><br><span class=\"line\">\t\t此时双方已经三个随机数了，之后双方通过约定的加密方法对三个随机数进行加密，形成密钥进行通信</span><br></pre></td></tr></table></figure>\n\n<p>48.http状态码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2xx 成功状态码，表示请求正常处理完毕</span><br><span class=\"line\">\t \t200：ok，表示客户端的请求已经被服务器正常处理了</span><br><span class=\"line\">3xx 重定向，表示需要附加操作完成请求</span><br><span class=\"line\">\t \t301：永久重定向，表示请求的资源已经被分配到了新的uri</span><br><span class=\"line\">\t \t302：临时重定向，表示请求的资源被临时分配到新的uri，希望用户使用新的uri访问资源</span><br><span class=\"line\">4xx 客户端错误，服务器无法处理请求</span><br><span class=\"line\">\t \t400：表示报文存在语法错误</span><br><span class=\"line\">\t \t403：表示访问资源的请求被服务器拒绝了</span><br><span class=\"line\">\t \t404：服务器无法找到请求的资源</span><br><span class=\"line\">5xx 服务器错误，服务器处理请求出错</span><br><span class=\"line\">\t \t500：表示服务端在处理请求时发生错误</span><br><span class=\"line\">\t \t503：表示服务器暂时处于超负载或停机维护，无法处理请求</span><br></pre></td></tr></table></figure>\n\n<p>49.网络模型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.OSI七层</span><br><span class=\"line\">\t应用层-表示层-会话层-运输层-网络层-链路层-物理层</span><br><span class=\"line\">2.TCP/IP五层</span><br><span class=\"line\">\t应用层-传输层-网络层-链路层-物理层</span><br><span class=\"line\">\t应用层：如 HTTP协议，https协议、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）</span><br><span class=\"line\">\t传输层：UDP和TCP</span><br><span class=\"line\">\t网络层：选择合适的路由将数据传递给目的主机</span><br><span class=\"line\">\t数据链路层：将网络层传递下来的ip数据报封装成帧，在链路传送帧</span><br><span class=\"line\">\t物理层：物理介质的传输</span><br></pre></td></tr></table></figure>\n\n<p>50.TCP和UDP的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp和udp都时传输层的协议，都属于tcp/ip协议族</span><br><span class=\"line\">\ttcp提供的是面向连接的，可靠的数据传输服务，数据传输的单位是报文段，适用于精确传输，例如文件传输</span><br><span class=\"line\">\tudp提供的是无连接的，尽最大努力的数据传输服务，但不保证数据的可靠性，数据传输的单位是用户数据报，适用于要求精确度较低的场景，例如视频聊天，即时通话</span><br></pre></td></tr></table></figure>\n\n<p>51.TCP的拥塞控制机制</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp的拥塞控制主要通过慢开始，拥塞避免，快速重传，快速恢复四个机制</span><br><span class=\"line\">\t1.首先是慢开始，设定拥塞窗口=1，最后逐渐增加拥塞窗口的大小，设定一个慢开始门限(当拥塞窗口达到这个门限后，就不会执行慢开始了，而是进入拥塞避免阶段)</span><br><span class=\"line\">\t2.当拥塞窗口&gt;慢开始门限，进入拥塞避免阶段，此阶段拥塞窗口线性增长，每次自增1，当发送方判断网络出现了拥塞后，将慢开始门限调整为本次出现拥塞窗口的一半，将这时的拥塞窗口重置为1，重新开始慢开始算法</span><br><span class=\"line\">\t3.快重传，当接收方收到一个失序的报文段时就立即发出重复确认，发送到只要连续收到三个重复确认就袭击重传对方缺失的报文段</span><br><span class=\"line\">\t4.快恢复，当发送放执行了快重传后，会将慢开始门限和下一次的拥塞窗口调整为本次拥塞窗口的一半，这时直接进入拥塞避免阶段</span><br></pre></td></tr></table></figure>\n\n<p>面试【高频的面试】:项目的性能优化手段有哪些？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v-if|v-show:尽可能采用v-show</span><br><span class=\"line\">按需引入【lodash、elementUI】</span><br><span class=\"line\">防抖与节流</span><br><span class=\"line\">路由懒加载：当用户访问的时候，加载对应组件进行展示。</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{"link":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}},"cover":"./images/touxiang2.jpg","excerpt":"","more":"<ol>\n<li><p>用语义化标签就会标记出每个区域的作用并且更好是实现页面布局</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span>  头部</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span>  导航栏</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span>  主要区域</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">article</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span>  主要内容</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aside</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">aside</span>&gt;</span>  侧边栏</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure></li>\n<li><p>HTML5有哪些更新</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）新增语义化标签：nav、header、footer、aside、section、article</span><br><span class=\"line\">（2）音频、视频标签：audio、video</span><br><span class=\"line\">（3）数据存储：localStorage、sessionStorage</span><br><span class=\"line\">（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</span><br><span class=\"line\">（5）input标签新增属性：placeholder、autocomplete、autofocus、required</span><br><span class=\"line\">（6）history API：go、forward、back、pushstate</span><br></pre></td></tr></table></figure>\n\n<p>1.语义化标签，使⽤语义类标签增强了可读性，开发者也能够清晰地看出⽹⻚的结构。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">● header：定义文档的页眉（头部）；</span><br><span class=\"line\">● nav：定义导航链接的部分；</span><br><span class=\"line\">● footer：定义文档或节的页脚（底部）；</span><br><span class=\"line\">● article：定义文章内容；</span><br><span class=\"line\">● section：定义文档中的节（section、区段）；</span><br><span class=\"line\">● aside：定义其所处内容之外的内容（侧边）；</span><br></pre></td></tr></table></figure>\n\n<p>2.媒体标签</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">audio：音频</span><br><span class=\"line\">video视频</span><br><span class=\"line\">source标签</span><br></pre></td></tr></table></figure>\n\n<p>3.表单</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表单类型</span><br><span class=\"line\">- email ：能够验证当前输入的邮箱地址是否合法</span><br><span class=\"line\">- url ： 验证URL</span><br><span class=\"line\">- number ： 只能输入数字，其他输入不了</span><br><span class=\"line\">表单属性：</span><br><span class=\"line\"> placeholder ：提示信息</span><br><span class=\"line\">表单事件：</span><br><span class=\"line\">oninput 每当input里的输入框内容发生变化都会触发此事件。</span><br><span class=\"line\">oninvalid 当验证不通过时触发此事件。</span><br></pre></td></tr></table></figure>\n\n<p>4.进度条</p>\n<p>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</p>\n<p>5.DOM查询操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- document.querySelector()</span><br><span class=\"line\">- document.querySelectorAll()</span><br><span class=\"line\">它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</span><br></pre></td></tr></table></figure>\n\n<p>6.Web存储</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML5 提供了两种在客户端存储数据的新方法：</span><br><span class=\"line\">- localStorage - 没有时间限制的数据存储</span><br><span class=\"line\">- sessionStorage - 针对一个 session 的数据存储</span><br></pre></td></tr></table></figure></li>\n<li><p>Css选择器的优先级</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">css是通过计算这些选择器的权重来去判定他们优先级的高低</span><br><span class=\"line\">首先用!important的权重最高，之后是内联样式权重为1000，其次是id选择器权重为100，之后是类选择器，伪类选择器，属性选择器的权重都为10，标签选择是1，其余的一些子选择器，后代选择器为0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>盒子模型的属性</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width、height、margin、border、padding</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>对盒模型的理解</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">标准盒子模型、IE盒子模型</span><br><span class=\"line\">盒模型都是由四个部分组成的，分别是margin、border、padding和content。</span><br><span class=\"line\">标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</span><br><span class=\"line\">● 标准盒模型的width和height属性的范围只包含了content，</span><br><span class=\"line\">● IE盒模型的width和height属性的范围包含了border、padding和content。</span><br><span class=\"line\">可以通过修改元素的box-sizing属性来改变元素的盒模型：</span><br><span class=\"line\">● box-sizing: content-box表示标准盒模型（默认值）</span><br><span class=\"line\">● box-sizing: border-box表示IE盒模型（怪异盒模型）</span><br></pre></td></tr></table></figure>\n\n<p>6.CSS3中有哪些新特性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">● 新增各种CSS选择器,child来匹配父元素的相应的子元素</span><br><span class=\"line\">● 圆角 （border-radius:8px）</span><br><span class=\"line\">●css弹性盒子模型</span><br><span class=\"line\">● 增加过渡，动画</span><br></pre></td></tr></table></figure>\n\n<p>7.两栏布局的实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先3大类：flex弹性布局，绝对定位，浮动</span><br><span class=\"line\">1.将左右盒子的父盒子display设定为flex，之后将左盒子设定宽度w，右盒子的flex：1(1,1,0%) flex-grow，flex-shrink，flex-basis 使其等比缩放</span><br><span class=\"line\">2. 父盒子相对定位，左盒子绝对定位并指定宽度，右盒子margin-left值为左盒子宽度值</span><br><span class=\"line\">                右盒子绝对定位，将右盒子左方向值设定为左盒子的宽度值</span><br><span class=\"line\">3. 左盒子进行左浮动并设定宽度值，右盒子的margin-left值为左盒子的宽度，右盒子的宽度为auto</span><br><span class=\"line\">   左盒子进行左浮动并设定负定宽高，右盒子的overflo：hidden</span><br></pre></td></tr></table></figure>\n\n<p>8.三栏布局的实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有三种形式，flex弹性布局，绝对定位，浮动</span><br><span class=\"line\">1.将三栏的父盒子的display谁当为flex，左右两栏设定固定的宽度，之后中间栏的flex:1</span><br><span class=\"line\">2.将三栏的父盒子相对定位，左右盒子绝对定位，分别居于左右两侧，中间栏设定margin-left和margin-right分别为左右两栏的宽度值</span><br><span class=\"line\">3.将左右盒子分别作左右浮动，中间栏设定margin-left和margin-right分别为左右两栏的宽度值</span><br></pre></td></tr></table></figure>\n\n<p>9.水平垂直居中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我可能知道的不全面，目前我知道有两种方式，flex弹性布局和绝对定位</span><br><span class=\"line\">1.将父盒子dispaly设定为flex，设定水平轴justify-content:center 还有垂直轴align-items:center</span><br><span class=\"line\">2.将父盒子相对定位，子盒子绝对定位，将左上方向50%移动至页面中央，最后通过translate或者margin的负值来调整元素中心值至页面中央 </span><br><span class=\"line\">3.自盒子绝对定位之后，所有方向都为0，最后margin为auto</span><br></pre></td></tr></table></figure>\n\n<p>10.==操作符的强制类型转化规则</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.==首先会看两者的数据类型是否一致</span><br><span class=\"line\">2.如果不一致的会进行强制转换，首先看是否是null == undefine ,是则返回true</span><br><span class=\"line\">3.再看是否是string == number ，将string强转为number型在进行对比</span><br><span class=\"line\">4.再看是否是boolean == number， 将boolean继续转为number</span><br><span class=\"line\">5.最后如果是一个对象 == 非对象string，则会将该对象通过toPrimitive转为基本数据类型在进行对比</span><br><span class=\"line\">注意如果是两个对象比较，则是比较的是地址空间，因为对象数组这些引用类型都是存储在堆中的，分配相应的引用地址</span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li>js的8大数据类型</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u are so nb  </span><br><span class=\"line\">undefined </span><br><span class=\"line\">symbol string </span><br><span class=\"line\">object </span><br><span class=\"line\">number null </span><br><span class=\"line\">boolean bigint</span><br></pre></td></tr></table></figure>\n\n<p>12.如何判断一个对象是一个空对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.通过Object.keys()获取这个对象的索引数组，如果索引数组长度为0，则表明对象是空对象</span><br><span class=\"line\">2.通过for in 遍历这个对象，如果这个对象不可遍历 则为空对象</span><br><span class=\"line\">3.通过Json.stringfy()将对象转为字符串，并于 ==&#x27;&#123;&#125;&#x27;比较</span><br></pre></td></tr></table></figure>\n\n<p>13.es6</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.增加了let，const关键字</span><br><span class=\"line\">    1.有了块级作用域的特点（变量的覆盖，变量泄露）</span><br><span class=\"line\">    2.没有变量提升，必须声明后才能使用</span><br><span class=\"line\">    3.var 用来声明全局变量 </span><br><span class=\"line\">    4.var，let都可以改变其指针指向，但const无法修改它的指针指向且必须赋初始值</span><br><span class=\"line\">    5.var可以重复声明，但let和const不允许重复声明</span><br><span class=\"line\">2.箭头函数</span><br><span class=\"line\">3.扩展运算符... 用户合并数组或者合并对象</span><br><span class=\"line\">4.rest参数...args  可以是用来接收剩余不确定个数的参数，将其存放在一个数组中</span><br><span class=\"line\">5.模板字符串</span><br><span class=\"line\">6.数组或对象的解构赋值</span><br><span class=\"line\">7.模块化 可以避免命名冲突，提高代码复用，利于维护</span><br><span class=\"line\">8.for of 遍历 (</span><br><span class=\"line\">\t1.for of遍历的是键值，for in 遍历的键名</span><br><span class=\"line\">\t2.for of只会遍历当前对象</span><br><span class=\"line\">\t3.for in适合遍历对象，for of适合遍历数组（因为of必须要求需要有迭代器，所以他不能迭代对象）。for in遍历的是数组的索引，对象的属性，以及原型链上的属性。</span><br><span class=\"line\">)</span><br><span class=\"line\">9.async 和 await ，async返回一个Promise期约对象，常用于一个ajax请求，异步等待请求的结果，并对请求结果返回的Promise进行一些处理</span><br><span class=\"line\">10.Promise期约（fulfilled，rejected，Pending（进行中））</span><br></pre></td></tr></table></figure>\n\n<p>14.箭头函数this的指向</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 首先箭头函数没有自己的this，箭头函数定义的位置的外部最近的一个this就是他的this</span><br><span class=\"line\">2. 对于普通函数来说他的this指向的是调用者，谁调用就指向谁，可以是window，可以是对象，只看是谁调用，不看他定义在哪个位置</span><br><span class=\"line\">3. 切记箭头函数如果定义在一个对象里面，那么他应该还需要再去外层找，因为对象的&#123;&#125;不是一个作用域</span><br></pre></td></tr></table></figure>\n\n<p>15.axios</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios是通过Promise实现对ajax技术的一种封装</span><br><span class=\"line\">    1. 浏览器端发起XMLHttpRequests请求</span><br><span class=\"line\">    2. 支持Promise API</span><br><span class=\"line\">    3. 监听请求和返回</span><br><span class=\"line\">    4. 自动转换json数据</span><br><span class=\"line\">    5. 支持拦截请求和响应</span><br></pre></td></tr></table></figure>\n\n<p>16.ajax</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax的全称是async javascript xml 异步的js和xml</span><br><span class=\"line\">1、什么是ajax</span><br><span class=\"line\">\tAjax是对原生XHR的封装，发送一个异步请求，不用刷新网页</span><br><span class=\"line\">2、ajax的原理？</span><br><span class=\"line\">\t客户端通过ajax向服务器发起请求，服务器作出响应之后返回给客户端，客户端接收到数据后，实现页面无刷新更新数据</span><br><span class=\"line\">3. ajax请求的五个步骤</span><br><span class=\"line\">    1. 创建XMLHttpRequest异步对象xml</span><br><span class=\"line\">    2. open初始化 设置请求方法和 url，请求参数</span><br><span class=\"line\">    3. send发送数据</span><br><span class=\"line\">    4. 绑定事件回调，处理服务端返回的结果</span><br><span class=\"line\">    5. 在回调函数中针对不同的响应状态进行处理（首先会判断xml状态为4，之后再判断返回的相应状态码200-300）</span><br><span class=\"line\">4.他的缺点：</span><br><span class=\"line\">\t1.安全问题 ajax暴露了与服务器交互的细节</span><br><span class=\"line\">\t2.ajax不能很好的支持移动设备</span><br><span class=\"line\">\t3.ajax不能使用Back和history功能，即对浏览器机制的破坏。</span><br></pre></td></tr></table></figure>\n\n<p>17.跨域</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.什么跨域？当违背了ajax的同源策略即为跨域</span><br><span class=\"line\">\t请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域,其实这是浏览器的一种同源策略(Same origin policy)，为了减小网络攻击</span><br><span class=\"line\">2.解决跨域的方法：</span><br><span class=\"line\">    前端解决：3种</span><br><span class=\"line\">        1.jsonp jsonp实现跨域的本质是通过script标签的src属性在引入外部资源时，不受到同源限制的特点来实现的，但是只能解决get请求，要求前后端配合写法</span><br><span class=\"line\">        2.利用代理服务器---WebPack-proxy会启动一个本地开发的服务器，即跨域所使用的代理服务器，代理服务器会响应本地请求，继而转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，代理服务器再将数据返回给本地。</span><br><span class=\"line\">        在此阶段中不涉及任何跨域问题，因为代理服务器跟本地同源，而服务器之间不存在跨域问题，跨域问题是浏览器安全策略限制</span><br><span class=\"line\">        3.Nginx反向代理，但这个我目前还不是很了解，只是知道有这种方法</span><br><span class=\"line\">    后端解决：</span><br><span class=\"line\">        cros： cors 真正解决了跨域问题，只需要在服务端设置响应头允许跨域即可</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>18.对原型的理解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法</span><br></pre></td></tr></table></figure>\n\n<p>19.原型链</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个构造函数都有一个prototype的原型对象，通过构造函数得到的实例化对象具有__proto__属性并指向该构造函数的原型对象，而原型对象上的constructor又指向对应的构造函数，对于该构造函数的原型对象也可以理解为时Object的实例化对象，他的__proto__指向的是Object构造函数的原型对象，而object的原型对象的__proto__指向原型链的终点null</span><br></pre></td></tr></table></figure>\n\n<p>20.闭包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闭包就是一个作用域引用了另一个作用域的变量或者方法，因为存在引用，所以被引用变量所在的作用域就不会被垃圾回收机制，因此就形成了闭包。</span><br><span class=\"line\">作用：</span><br><span class=\"line\"> 1. 可以延申变量的作用域范围</span><br><span class=\"line\"> 2. 用于保存数据，因为闭包中变量被引用，所以不会被垃圾回收机制回收</span><br></pre></td></tr></table></figure>\n\n<p>21.异步编程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avaScript中的异步机制可以分为以下几种：</span><br><span class=\"line\">● 回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</span><br><span class=\"line\">● Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</span><br><span class=\"line\">● async await</span><br></pre></td></tr></table></figure>\n\n<p>22.垃圾回收</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.什么是垃圾回收：js代码运行中，系统需要分配内存空间给这些变量和值，当他们不在被使用的时候，系统就需要释放掉他们之前占用的内存空间</span><br><span class=\"line\">2.垃圾回收的机制：js具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存</span><br><span class=\"line\">3.垃圾回收的方式(两种)</span><br><span class=\"line\">\t1.标记清除：当变量在被使用时，会被浏览器标记为’进入环境‘，当变量不再被使用时，会被重新标记为’离开环境‘，标记为离开环境的变量会被内存释放</span><br><span class=\"line\">\t2.引用计数：变量每被引用一次时，引用次数会加1，当该变量的引用次数为0时，这时该变量会被内存释放</span><br><span class=\"line\">4.内存泄漏</span><br></pre></td></tr></table></figure>\n\n<p>23.内存泄漏</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内存泄漏：就是一个变量该让他释放内存空间的时候没有被释放，始终占用着内存</span><br><span class=\"line\">什么情况下会发生内存泄漏：</span><br><span class=\"line\">\t1.不合理的使用闭包，因为在闭包中会发生内部函数对外部变量的引用，该变量会因为这个引用的存在而不会被垃圾回收机制清除</span><br><span class=\"line\">\t2.遗忘的定时器，对于设定的某个循环定时器但是忘记取消他，该定时器若是有对外部变量的引用时，这时该变量所占用的内存也不会被回收</span><br><span class=\"line\">\t3. 意外的全局变量，使用了未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class=\"line\">\t4.脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收</span><br></pre></td></tr></table></figure>\n\n<p>24.Vue中的双向绑定原理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Observer实现对MVVM自身model数据劫持（底层是通过Object.defineProperty()为对data里的数据进行递归的添加getter和setter），监听数据的属性变更，并在变动时进行notify</span><br><span class=\"line\">2. Compile实现指令解析，初始化视图，并订阅数据变化，绑定好更新函数</span><br><span class=\"line\">3. Watcher（订阅者）一方面接收Observer通过dep(消息订阅器)传递过来的数据变化，一方面通知Compile进行view update</span><br><span class=\"line\">MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果</span><br></pre></td></tr></table></figure>\n\n<p>25.MVVM、MVC、MVP的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</span><br><span class=\"line\">\t1. MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。(注意在MVC中 model和view是耦合的，可以相互直接通信)</span><br><span class=\"line\">\t2. MVVM 分为 Model、View、ViewModel：</span><br><span class=\"line\">\t\t1.Model代表数据模型，数据和业务逻辑都在Model层中定义；</span><br><span class=\"line\">\t\t2.View代表UI视图，负责数据的展示；</span><br><span class=\"line\">\t\t3.ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；\t</span><br><span class=\"line\">\t\tModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM</span><br><span class=\"line\">\t3.MVP View和Model之间不能直接进行交互，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部</span><br></pre></td></tr></table></figure>\n\n<p>26.computed和watch的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:</span><br><span class=\"line\">\t1. 他是基于响应式依赖(data和props里面的数据)进行缓存的，当依赖的数据发生变化时，下一次获取 computed 的值时才会重新计算 computed 的值</span><br><span class=\"line\">\t2. 不支持异步操作，当computed中有异步操作时，无法监听到数据的变化</span><br><span class=\"line\">watch：</span><br><span class=\"line\">\t1. 不支持缓存，只要监听的数据(data和props里面的数)发生变化，就会执行对应的handler回调</span><br><span class=\"line\">\t2. 支持异步监听</span><br><span class=\"line\">两者的应用场景：</span><br><span class=\"line\">\t1.computed：当想要获取的数据是依赖于其他数据计算出来的，这时候可以利用computed的缓存特点(只要他依赖的数据没变，那么这个数据他就不会变化直接从缓存取出来即可)，可以不用每次获取这个数据时就重新计算一次了</span><br><span class=\"line\">\t2.watch：当想要对某个数据变化时进行实时监听并进行一些异步操作(例如API请求)，这时就需要通过watch进行操作</span><br></pre></td></tr></table></figure>\n\n<p>27.computed和methods</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed：他是基于响应式依赖进行缓存的，就是说只有当所依赖的数据发生变化的时候，才会重新计算新的computed值</span><br><span class=\"line\">methods：只要调用了就会执行该函数</span><br></pre></td></tr></table></figure>\n\n<p>28.v-if和v-show的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.方法：v-if是动态的给dom树添加或删除dom元素，v-show是将样式display设置为none</span><br><span class=\"line\">2.原理：v-if在生成虚拟dom的时候会忽略掉这个虚拟节点vnode，之后再render渲染真实dom的时候也就没有了该节点</span><br><span class=\"line\">       v-show生成虚拟dom的时候会生成这个虚拟节点，render渲染成真实dom，并将该节点的样式display设置为none</span><br><span class=\"line\">3.特点：v-if如果初始条件为flase时，是不会被编译（加快页面加载速度），只有变为true时才会被编译</span><br><span class=\"line\">       v-show无论初始条件为true还是false，都会被编译，并生成真实的dom元素</span><br><span class=\"line\">4.使用场景：v-if适用于低频的的切换，v-show适合高频的显示隐藏切换</span><br></pre></td></tr></table></figure>\n\n<p>29.v-model的原理，语法糖的本质是什么</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v-model是对表单或者组件的一种双向绑定的语法糖，本质是v-bind和v-on的语法糖</span><br><span class=\"line\">● v-bind绑定响应数据</span><br><span class=\"line\">● 触发事件并传递数据</span><br><span class=\"line\">其中v-bind是对model层对view层的单向绑定，加上了v-on(进行一些函数操作，通过event.target.value获取当前触发事件的元素值)后又实现了view层对model的单向绑定，两者结合实现了model与view的双向绑定</span><br></pre></td></tr></table></figure>\n\n<p>30.单页面应用和多页面应用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">● SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用路由跳转，只是切换到相关的组件，仅仅刷新局部资源。</span><br><span class=\"line\">● MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</span><br><span class=\"line\">SPA的优点：</span><br><span class=\"line\">\t1. 页面相应速度块，用户体验优，因为不需要一直跳转网页</span><br><span class=\"line\">\t2. 因为不需要重复加载资源，所以spa可以减小服务器的压力</span><br><span class=\"line\">\t3. 前后端分离，架构清晰，前端进行交互逻辑，后端股则负责数据处理</span><br><span class=\"line\">\t缺点：</span><br><span class=\"line\">\t1. 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载\t</span><br></pre></td></tr></table></figure>\n\n<ol start=\"31\">\n<li>v-if和v-for哪一个优先级更高？如果同时出现，需要怎么做？</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于vue2来说v-for的优先级会更高，总是会优先执行循环再去判断，尽量使不要同时出现，会浪费性能，因为循环不可避免，所以每次都要进行if判断</span><br><span class=\"line\">解决方式是在外面嵌套一层v-if，里面使用v-for</span><br></pre></td></tr></table></figure>\n\n<p>32.前端性能优化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 路由和图片的懒加载</span><br><span class=\"line\">2. v-for和v-if避免同时使用</span><br><span class=\"line\">3. 第三方插件按需引入</span><br><span class=\"line\">4.keep-alive缓存页面</span><br></pre></td></tr></table></figure>\n\n<p>33.Vue生命周期</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每一个组件都需要经过创建，初始化，挂载，更新，销毁这些声明周期</span><br><span class=\"line\">1.beforeCreate()</span><br><span class=\"line\">\t初始化事件和生命周期函数,数据代理还未开始，此时无法访问data，computed，watch，methods</span><br><span class=\"line\">2.created()</span><br><span class=\"line\">\tvue实例vm创建完成，vm上的配置：data，computed，watch，methods已经配置完成，可以访问得到</span><br><span class=\"line\">3.beforeMount()</span><br><span class=\"line\">\t在挂载之前调用，相关的render函数首次被调用，解析模板生成虚拟dom，但此时还未挂载到真实页面上</span><br><span class=\"line\">4.mounted()</span><br><span class=\"line\">\t将内存中的虚拟dom转为真实dom并挂载到真实页面中，此时可以进行一些异步请求(网上有很多说在created中，但我在实际项目中，还是在mounted钩子中异步请求)，开启定时器，绑定自定义事件等等</span><br><span class=\"line\">5.beforeUpdated()</span><br><span class=\"line\">\t响应式数据更新时调用，这时数据已经更新了，但是真实dom还未被渲染，此时页面和数据尚未同步</span><br><span class=\"line\">6.updated()</span><br><span class=\"line\">\t新旧的虚拟dom进行对比，进行页面更新，此时页面和数据已经同步</span><br><span class=\"line\">7.beforeDestroy()</span><br><span class=\"line\">\t实例vm销毁之前调用，这时vm仍然可用，this仍可以获取到实例，在此阶段一般关闭定时器，解绑自定义事件等等</span><br><span class=\"line\">8.destroyed()</span><br><span class=\"line\">\t实例销毁后调用，解绑指令和移除事件监听，子实例也会被销毁</span><br></pre></td></tr></table></figure>\n\n<p>34.keep-alive中的生命周期有哪些</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keep-alive用来缓存组件，在组件切换的时候将状态保留在缓存中，防止重复渲染dom</span><br><span class=\"line\">如果为一个组件包裹keep-alive，那么他就会多出两个生命周期函数：deactivated，activated同时beforeDestroy和destroyed两个钩子也不会执行了，因为组件不会被销毁</span><br><span class=\"line\">当组件被换掉时，他会保留在缓存中并触发deactivated钩子，当组件被切回来时，再去缓存中找到该组件，并触发activated钩子</span><br></pre></td></tr></table></figure>\n\n<p>35.组件间通信</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.父给子传递数据：利用pros</span><br><span class=\"line\">\t子组件通过pros属性来接收父组件传递过来的数据</span><br><span class=\"line\">2.子给父传递数据：利用自定义事件</span><br><span class=\"line\">\t$on/$emit，其中在父组件中绑定自定义事件@name=&#x27;callback&#x27;，并定义相应的回调函数用来接收子组件传递的数据(若是父组件直接在标签内就绑定了，就不用再通过$on去绑定了),子组件就需要通过$emit(&#x27;name&#x27;,params)，来触发相应的自定义事件name，并将所要传递的数据params通过参数传递</span><br><span class=\"line\">3.任意组件之间传递(也可兄弟组件)：全局事件总线$bus,在vue实例身上安装$bus，这样所有的组件实例对象都可以通过原型链向上找到这个$bus</span><br><span class=\"line\">\t接收数据的组件需要绑定事件，在自身的组件中的$bus.$on去绑定事件</span><br><span class=\"line\">\t提供数据的组件需要触发事件，在自身的组件中的$bus.$emit来触发该事件，并传递数据</span><br></pre></td></tr></table></figure>\n\n<p>36.路由的懒加载</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了避免在webpack打包时，JavaScript变得非常大，影响页面加载，这时可以利用路由懒加载</span><br><span class=\"line\">原理：它是将路由对应的组件打包成一个个js代码块，当该路由被访问的时候才会去加载对应的组件，否则不加载</span><br><span class=\"line\">实现的三种方式：</span><br><span class=\"line\">\t1.利用箭头函数+import()动态加载</span><br><span class=\"line\">\t2.利用箭头函数+require()动态加载</span><br><span class=\"line\">\t3.利用webpack的require.ensure技术</span><br></pre></td></tr></table></figure>\n\n<p>37.路由的两种工作模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash模式和history模式</span><br><span class=\"line\">1.hash模式</span><br><span class=\"line\">\t在url中会有/#，但是hasn值(#及其后面的内容)不会包含在http请求中，也就是不会将这些信息带给服务器</span><br><span class=\"line\">\t他的地址中一直带着#，但是兼容性好，也是默认的路由模式</span><br><span class=\"line\">2.history模式</span><br><span class=\"line\">\turl地址干净美观，但是兼容性较差，需要后端人员支持，解决刷新页面服务器端404问题</span><br><span class=\"line\">\tAPI：包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>38.两种工作模式的对比</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.对于history.pushState()修改浏览器的历史记录栈，对比直接修改hasn值，有以下好处</span><br><span class=\"line\">\t1.pushState可以修改与当前url同源的任意路径，但是hash只能修改#之后的内容，也就是只能设置和当前url同文档的url</span><br><span class=\"line\">\t2.pushState设置的新的url可以和当前url一致，会把该记录加入到栈中；但是hash必须要求新的url与当前不同才会把记录加入到栈中</span><br><span class=\"line\">2. 在hash模式中，#之前的内容都会放在http请求中，即使后端没有对路由进行全覆盖，也不会返回404的错误</span><br><span class=\"line\">\t在history模式中，必须要求前端的url和向后端发起请求的url保持一致，后端如果没有对使用的路由处理，会有404的错误</span><br></pre></td></tr></table></figure>\n\n<ol start=\"39\">\n<li>$route 和$router的区别</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$route是路由实例对象，包含了路由跳转方法，钩子函数（导航守卫）等</span><br><span class=\"line\">$router是路由信息对象，包含了name，path，fullPath，query，params等路由信息参数</span><br></pre></td></tr></table></figure>\n\n<p>40.常见的http请求方法有哪些？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get:向服务器请求数据</span><br><span class=\"line\">post：携带数据向服务器发起请求，最终会在服务器端创建新的数据（重点是创建新的数据，例如注册用户业务）</span><br><span class=\"line\">put：上传数据，更新服务器的数据（重点是更新数据）</span><br><span class=\"line\">delete：删除服务器上的数据</span><br><span class=\"line\">head：获取报文的首部，与get相比不返回相应实体数据</span><br><span class=\"line\">options：询问服务器支持的请求方法，用来跨域请求</span><br><span class=\"line\">trace：回显服务器收到的请求，用于测试或诊断</span><br></pre></td></tr></table></figure>\n\n<p>41.get和post请求的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.应用场景：get用于不需要对服务器资源产生影响的场景，仅仅只用来获取数据</span><br><span class=\"line\">\t        post用于需要对服务器资源产生影响的场景，最终服务器端会产生新的数据（例如用户注册业务）</span><br><span class=\"line\">2.发送的报文格式：get请求报文实体部分为空</span><br><span class=\"line\">\t             post的请求报文实体部分一般是向服务器发送的数据</span><br><span class=\"line\">3.安全性：get请求的中参数会放在url中向服务器发送过去，这种相对于post来说是不安全的</span><br><span class=\"line\">4.参数类型：post请求中参数传递支持更多的数据</span><br></pre></td></tr></table></figure>\n\n<p>42.常见的http请求头和响应头</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 请求头：</span><br><span class=\"line\">        1. Accept-Charset:浏览器能够显示的字符集</span><br><span class=\"line\">        2. Accept-Encoding：浏览器能够处理的压缩编码</span><br><span class=\"line\">        3. Accept-Language：浏览器当前设置的语言(可接受的字符集，编码，语言)</span><br><span class=\"line\">        4. Host：请求将被发送的目的地（仅包括域名+端口号）</span><br><span class=\"line\">        5. Origin 用来说明请求从哪里发起的（仅包括协议和域名）</span><br><span class=\"line\">2.响应头：</span><br><span class=\"line\">\t\t1. Date：表示响应消息发出的时间</span><br><span class=\"line\">\t\t2. server：表示服务器的名称</span><br><span class=\"line\">\t\t3. Allow：服务器支持那些请求方法</span><br><span class=\"line\">\t\t4. Access-Control-Allow-Origin：哪些网站跨域</span><br><span class=\"line\">\t\t5. Content-Encoding：响应资源的编码</span><br><span class=\"line\">\t\t6. Content-Language:响应资源的语言</span><br></pre></td></tr></table></figure>\n\n<p>43.http和https协议的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.https是超文本传输安全协议（他是在http的基础上通过加密传输和身份验证来保证传输的安全性），需要CA证书，费用很高，但\thttp不需要</span><br><span class=\"line\">2.http是超文本传输协议，信息是明文传输的，而https是通过SSL加密传输的更安全</span><br><span class=\"line\">3.使用的端口号不同，http默认端口为80，https默认端口为443</span><br><span class=\"line\">4.https通过加密传输和身份验证来保证传输安全，对比http更安全</span><br></pre></td></tr></table></figure>\n\n<p>44.当用户在浏览器中输入<a href=\"http://www.google.com会发生什么/\">www.google.com会发生什么</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.解析URL，分析所使用的传输协议和请求资源的路径</span><br><span class=\"line\">2.缓存判断，看请求的资源是否在缓存中，如果请求的资源在缓存中且没有失效就直接使用，否则就向服务器发起请求</span><br><span class=\"line\">3.DNS解析，dns服务器将url解析为对应的ip地址</span><br><span class=\"line\">4.获取MAC地址，浏览器得到ip地址后，还需要知道目的主机的mac地址，网络层下发至链路层时使用</span><br><span class=\"line\">5.TCP建立连接（三次握手），通过三次握手保证客户端和服务器都能保证自己发送数据和接收数据的能力，并建建立起连接</span><br><span class=\"line\">6.HTTPS握手，如果https协议，那么还存在一个TLS的四次握手，四次握手之后客户端和服务器通过握手得到的3个随机数进行加密得到密钥，以后双方通过该密钥进行通信</span><br><span class=\"line\">7.返回数据，服务器返回一个html文件作为响应，浏览器接收到响应后，开始页面渲染</span><br><span class=\"line\">8.页面渲染，浏览器根据html构建dom树，最后渲染出整个页面</span><br><span class=\"line\">9.TCP断开连接（四次挥手），四次挥手后，客户端和服务器双方断开连接，结束所有通信</span><br></pre></td></tr></table></figure>\n\n<p>45.http的请求报文和响应报文</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.请求报文</span><br><span class=\"line\">\t\t请求行：请求方法，url，http协议版本</span><br><span class=\"line\">\t\t请求头：key：value形式</span><br><span class=\"line\">\t\t空行</span><br><span class=\"line\">\t\t请求体：post，put等请求携带的数据</span><br><span class=\"line\">2.响应报文</span><br><span class=\"line\">\t\t响应行：协议版本，状态码，状态码原因短语</span><br><span class=\"line\">\t\t响应头：key：value</span><br><span class=\"line\">\t\t空行</span><br><span class=\"line\">\t\t响应体：服务器响应的数据</span><br></pre></td></tr></table></figure>\n\n<p>46.三次握手和四次挥手</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.三次握手：客户端和服务器建立TCP连接时，需要三次握手，来保证双方发送和接收数据的能力</span><br><span class=\"line\">\t\t客户端向服务器发送syn连接请求报文，</span><br><span class=\"line\">\t\t服务器收到请求后向客户端发送syn和ack报文，确认本次连接请求，</span><br><span class=\"line\">\t\t客户端接收到确认应答后，进入连接状态，同时也向服务器发送一个ack确认报文，服务器收到该确认后，也进入连接状态，</span><br><span class=\"line\">\t\t至此双方的连接建立完成</span><br><span class=\"line\">2.四次挥手：客户端和服务器断开TCP连接时，需要进行四次挥手</span><br><span class=\"line\">\t\t客户端向服务器发送fin断开请求报文</span><br><span class=\"line\">\t\t服务器收到请求后向客户端发送ack报文，确认本次断开连接请求（但是TCP是全双工，也就是说此时服务器又可能还有数据要传给客户端）</span><br><span class=\"line\">\t\t所以双方想要断开连接，服务器还需再一次向客户端发送一个fin断开连接请求报文，</span><br><span class=\"line\">\t\t客户端收到报文后，向服务器发送ack确认报文，自己进入超时等待</span><br><span class=\"line\">\t\t服务端收到ack报文后，就立即关闭连接，之后客户端继续等待超时时间，若是中间没有来自服务器的数据，此时客户端也关闭连接，否则重置超时时间</span><br></pre></td></tr></table></figure>\n\n<p>47.针对于https中的四次握手（利用中间的三次随机数加密形成密钥进行通信）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">四次握手：客户端向服务器发起请求，包括一个随机数和加密方法</span><br><span class=\"line\">\t\t服务器收到请求后，给出服务器证书，确认加密方法，并生成一个随机数这些都再次传给客户端</span><br><span class=\"line\">\t\t客户端收到后，确认证书有效，并生成一个随机数，利用证书来加密该随机数并发送给服务器</span><br><span class=\"line\">\t\t服务器收到后，解密该随机数</span><br><span class=\"line\">\t\t此时双方已经三个随机数了，之后双方通过约定的加密方法对三个随机数进行加密，形成密钥进行通信</span><br></pre></td></tr></table></figure>\n\n<p>48.http状态码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2xx 成功状态码，表示请求正常处理完毕</span><br><span class=\"line\">\t \t200：ok，表示客户端的请求已经被服务器正常处理了</span><br><span class=\"line\">3xx 重定向，表示需要附加操作完成请求</span><br><span class=\"line\">\t \t301：永久重定向，表示请求的资源已经被分配到了新的uri</span><br><span class=\"line\">\t \t302：临时重定向，表示请求的资源被临时分配到新的uri，希望用户使用新的uri访问资源</span><br><span class=\"line\">4xx 客户端错误，服务器无法处理请求</span><br><span class=\"line\">\t \t400：表示报文存在语法错误</span><br><span class=\"line\">\t \t403：表示访问资源的请求被服务器拒绝了</span><br><span class=\"line\">\t \t404：服务器无法找到请求的资源</span><br><span class=\"line\">5xx 服务器错误，服务器处理请求出错</span><br><span class=\"line\">\t \t500：表示服务端在处理请求时发生错误</span><br><span class=\"line\">\t \t503：表示服务器暂时处于超负载或停机维护，无法处理请求</span><br></pre></td></tr></table></figure>\n\n<p>49.网络模型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.OSI七层</span><br><span class=\"line\">\t应用层-表示层-会话层-运输层-网络层-链路层-物理层</span><br><span class=\"line\">2.TCP/IP五层</span><br><span class=\"line\">\t应用层-传输层-网络层-链路层-物理层</span><br><span class=\"line\">\t应用层：如 HTTP协议，https协议、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）</span><br><span class=\"line\">\t传输层：UDP和TCP</span><br><span class=\"line\">\t网络层：选择合适的路由将数据传递给目的主机</span><br><span class=\"line\">\t数据链路层：将网络层传递下来的ip数据报封装成帧，在链路传送帧</span><br><span class=\"line\">\t物理层：物理介质的传输</span><br></pre></td></tr></table></figure>\n\n<p>50.TCP和UDP的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp和udp都时传输层的协议，都属于tcp/ip协议族</span><br><span class=\"line\">\ttcp提供的是面向连接的，可靠的数据传输服务，数据传输的单位是报文段，适用于精确传输，例如文件传输</span><br><span class=\"line\">\tudp提供的是无连接的，尽最大努力的数据传输服务，但不保证数据的可靠性，数据传输的单位是用户数据报，适用于要求精确度较低的场景，例如视频聊天，即时通话</span><br></pre></td></tr></table></figure>\n\n<p>51.TCP的拥塞控制机制</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp的拥塞控制主要通过慢开始，拥塞避免，快速重传，快速恢复四个机制</span><br><span class=\"line\">\t1.首先是慢开始，设定拥塞窗口=1，最后逐渐增加拥塞窗口的大小，设定一个慢开始门限(当拥塞窗口达到这个门限后，就不会执行慢开始了，而是进入拥塞避免阶段)</span><br><span class=\"line\">\t2.当拥塞窗口&gt;慢开始门限，进入拥塞避免阶段，此阶段拥塞窗口线性增长，每次自增1，当发送方判断网络出现了拥塞后，将慢开始门限调整为本次出现拥塞窗口的一半，将这时的拥塞窗口重置为1，重新开始慢开始算法</span><br><span class=\"line\">\t3.快重传，当接收方收到一个失序的报文段时就立即发出重复确认，发送到只要连续收到三个重复确认就袭击重传对方缺失的报文段</span><br><span class=\"line\">\t4.快恢复，当发送放执行了快重传后，会将慢开始门限和下一次的拥塞窗口调整为本次拥塞窗口的一半，这时直接进入拥塞避免阶段</span><br></pre></td></tr></table></figure>\n\n<p>面试【高频的面试】:项目的性能优化手段有哪些？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v-if|v-show:尽可能采用v-show</span><br><span class=\"line\">按需引入【lodash、elementUI】</span><br><span class=\"line\">防抖与节流</span><br><span class=\"line\">路由懒加载：当用户访问的时候，加载对应组件进行展示。</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"测试图片加名称","data":"2022-6-16","description":"这里是description","cover":"./images/bg2.jpg","_content":"\n![小黑柴](https://img2.baidu.com/it/u=1820426694,3444617145&fm=253&fmt=auto&app=138&f=JPEG?w=456&h=500)\n\n","source":"_posts/test2.md","raw":"---\ntitle: 测试图片加名称\ndata: '2022-6-16'\ndescription: '这里是description'\ncover: ./images/bg2.jpg\n---\n\n![小黑柴](https://img2.baidu.com/it/u=1820426694,3444617145&fm=253&fmt=auto&app=138&f=JPEG?w=456&h=500)\n\n","slug":"test2","published":1,"date":"2022-06-15T05:16:56.500Z","updated":"2022-06-15T05:57:18.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4glk6rs00062wtm7a2k6ceb","content":"<p><img src=\"https://img2.baidu.com/it/u=1820426694,3444617145&fm=253&fmt=auto&app=138&f=JPEG?w=456&h=500\" alt=\"小黑柴\"></p>\n","site":{"data":{"link":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}},"excerpt":"","more":"<p><img src=\"https://img2.baidu.com/it/u=1820426694,3444617145&fm=253&fmt=auto&app=138&f=JPEG?w=456&h=500\" alt=\"小黑柴\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}